<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>论坛项目-小微书</title>
      <link href="/2025/04/10/xiao-wei-shu/"/>
      <url>/2025/04/10/xiao-wei-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="小微书"><a href="#小微书" class="headerlink" title="小微书"></a>小微书</h1><p>AOP：横向关注点</p><p>mvc模式：m:model，v：views，c：control </p><p>跨域请求：只要协议、域名、端口有一个不同就是跨域请求。</p><p>启动前端：npm run dev</p><p>启动docker：docker compose （-d）</p><p>配置k8s文件： kubectl apply -f  k8s-webook-service.yaml</p><p><a href="https://github.com/wei-d-zhang/ASAFL">https://github.com/wei-d-zhang/ASAFL</a> </p>]]></content>
      
      
      <categories>
          
          <category> go项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> docker </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/04/01/cao-zuo-xi-tong/"/>
      <url>/2025/04/01/cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程、线程基础知识"><a href="#进程、线程基础知识" class="headerlink" title="进程、线程基础知识"></a>进程、线程基础知识</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程（Process）是系统进行资源分配和调度的基本单位。</p><h5 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h5><ul><li>创建状态：被创建的第一个状态</li><li>就绪状态</li><li>运行状态</li><li>阻塞状态</li><li>结束状态</li><li>挂起状态：<ul><li>阻塞挂起状态</li><li>就绪挂起状态</li></ul></li></ul><h5 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h5><p>在操作系统中，用进程控制块（PCB）数据结构来描述进程的。</p><p>PCB是进程存在的唯一标识。</p><h5 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h5><p>进程的<strong>创建</strong>、<strong>终止</strong>、<strong>阻塞</strong>、<strong>唤醒</strong>的过程，这些过程就是进程的控制。</p><h5 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h5><p>一个进程切换到另一个进程运行，称为进程的上下文切换。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是操作系统能够进行运算调度的最小单位。</p>]]></content>
      
      
      <categories>
          
          <category> 操作性系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统基础 </tag>
            
            <tag> 操作系统面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/27/admin-go-api/"/>
      <url>/2025/03/27/admin-go-api/</url>
      
        <content type="html"><![CDATA[<h1 id="admin-go-api"><a href="#admin-go-api" class="headerlink" title="admin-go-api"></a>admin-go-api</h1><h3 id="1-核心基础包"><a href="#1-核心基础包" class="headerlink" title="1. 核心基础包"></a><strong>1. 核心基础包</strong></h3><h4 id="common-包"><a href="#common-包" class="headerlink" title="common 包"></a><strong><code>common</code> 包</strong></h4><ul><li><p><strong>功能</strong>：存放全局配置、常量、通用工具类。</p></li><li><p>子包说明</p><p>：</p><ul><li><code>config</code>：解析 YAML 配置文件（如数据库、Redis、端口等）（）。</li><li><code>constant</code>：定义系统常量（如 JWT 上下文键、验证码缓存前缀）（）。</li><li><code>result</code>：封装统一响应结构与状态码（）。</li><li><code>util</code>：包含加密（MD5）、时间处理、Redis 缓存工具（）。</li></ul></li></ul><h4 id="middleware-包"><a href="#middleware-包" class="headerlink" title="middleware 包"></a><strong><code>middleware</code> 包</strong></h4><ul><li><strong>功能</strong>：中间件链处理（请求预处理 &#x2F; 后处理）。</li><li>关键组件：<ul><li><code>cors.go</code>：跨域请求处理（）。</li><li><code>authMiddleware.go</code>：JWT 鉴权与权限验证（）。</li><li><code>logger.go</code>：请求日志记录（）。</li></ul></li></ul><h3 id="2-基础设施包"><a href="#2-基础设施包" class="headerlink" title="2. 基础设施包"></a><strong>2. 基础设施包</strong></h3><h4 id="pkg-包"><a href="#pkg-包" class="headerlink" title="pkg 包"></a><strong><code>pkg</code> 包</strong></h4><ul><li><p><strong>功能</strong>：底层服务初始化与工具封装。</p></li><li><p>子包说明</p><p>：</p><ul><li><code>db</code>：GORM 数据库连接配置（）。</li><li><code>redis</code>：Redis 缓存初始化（）。</li><li><code>jwt</code>：JWT 生成与解析工具（）。</li><li><code>log</code>：日志系统（文件 &#x2F; 控制台输出）（）。</li></ul></li></ul><h4 id="router-包"><a href="#router-包" class="headerlink" title="router 包"></a><strong><code>router</code> 包</strong></h4><ul><li><p><strong>功能</strong>：路由定义与分组管理。</p></li><li><p>核心文件</p><p>：</p><ul><li><code>router.go</code>：初始化路由并绑定中间件（）。</li><li>动态路由注册（如用户、角色、菜单接口）（）。</li></ul></li></ul><h3 id="3-业务逻辑包"><a href="#3-业务逻辑包" class="headerlink" title="3. 业务逻辑包"></a><strong>3. 业务逻辑包</strong></h3><h4 id="api-包"><a href="#api-包" class="headerlink" title="api 包"></a><strong><code>api</code> 包</strong></h4><ul><li><strong>功能</strong>：业务接口实现，分层架构。</li></ul><ul><li>controller（控制器层）：<ul><li><strong>接收请求与参数校验</strong>：作为应用程序与客户端交互的入口，负责接收来自客户端（如浏览器、移动 APP 等）的各种请求，比如 HTTP 请求。同时，对请求中携带的参数进行初步校验，确保参数的格式和取值符合要求，例如检查用户注册时输入的用户名长度、密码强度等是否合规。</li><li><strong>请求分发与调用服务</strong>：根据请求的类型和路径，将请求转发给对应的 <code>Service</code> 层方法进行处理。它并不处理具体的业务逻辑，而是起到 “调度” 的作用，比如在一个电商系统中，当收到用户下单的请求时，<code>Controller</code> 层会调用 <code>Service</code> 层中处理订单业务的方法。</li><li><strong>响应处理与返回</strong>：接收 <code>Service</code> 层处理后的结果，并将其转换为合适的响应格式（如 JSON、XML 等）返回给客户端。同时，还负责处理在请求处理过程中出现的异常情况，向客户端返回相应的错误信息。</li></ul></li><li>dao（数据访问对象层，Data Access Objects）：<ul><li><strong>数据持久化操作</strong>：主要负责与数据库进行交互，实现对数据的持久化操作，包括数据的增（创建）、删（删除）、改（更新）、查（读取）等操作。例如在一个用户管理系统中，<code>DAO</code> 层会实现添加用户、删除用户、修改用户信息以及查询用户列表等功能。</li><li><strong>数据访问抽象</strong>：提供了一种抽象的数据访问接口，使得上层（如 <code>Service</code> 层）可以通过这些接口来访问数据，而不需要关心具体的数据访问实现方式，比如使用的是 MySQL、Oracle 还是其他数据库，以及具体的 SQL 语句是如何编写的。</li><li><strong>对象 - 关系映射</strong>：在一些使用 ORM（对象关系映射）框架的项目中，<code>DAO</code> 层还负责将领域对象（如业务逻辑中的实体类）和数据库表之间进行映射，实现数据在对象和数据库表之间的转换，屏蔽了底层数据库的细节，让开发人员可以使用面向对象的方式操作数据。</li></ul></li><li>entity（实体层）：<ul><li><strong>数据模型定义</strong>：用于定义与业务实体相关的数据模型，这些实体通常与数据库中的表结构相对应，但也不完全局限于此。比如在一个图书管理系统中，<code>Book</code> 实体类可能包含书名、作者、出版社、出版日期等属性，这些属性与数据库中 <code>books</code> 表的字段相对应。</li><li><strong>业务对象载体</strong>：在业务逻辑处理过程中，<code>Entity</code> 类的实例作为数据的载体，在不同的层次（如 <code>Service</code> 层、<code>DAO</code> 层）之间传递数据。例如，<code>Service</code> 层在处理图书借阅业务时，会使用 <code>Book</code> 实体类的对象来存储和传递图书的相关信息。</li><li><strong>封装业务数据</strong>：通过定义属性和方法（有时会包含一些简单的业务逻辑，如数据验证方法），对业务数据进行封装，提高数据的一致性和可维护性。例如，在 <code>Book</code> 实体类中可以定义一个方法来验证图书的出版日期是否合法。</li></ul></li><li>service（服务层）：<ul><li><strong>业务逻辑实现</strong>：是应用程序的业务逻辑核心层，负责处理具体的业务规则和流程。比如在一个电商系统中，<code>Service</code> 层会实现商品的添加、删除、修改，订单的创建、支付、发货等业务逻辑。</li><li><strong>数据处理与转换</strong>：对从 <code>DAO</code> 层获取的数据进行加工和转换，以满足业务需求。例如，在计算商品价格时，可能需要根据不同的促销活动、会员等级等因素对商品的原价进行折扣计算；在处理用户积分时，需要根据用户的消费金额和积分规则进行积分的累加或扣除等操作。</li><li><strong>事务管理</strong>：负责管理数据库事务，确保业务操作的原子性、一致性、隔离性和持久性（ACID 特性）。例如，在一个转账业务中，<code>Service</code> 层会保证转出账户的扣款和转入账户的入账操作要么同时成功，要么同时失败，以避免出现数据不一致的情况。</li><li><strong>协调多个 DAO 操作</strong>：在处理复杂业务时，通常需要协调多个 <code>DAO</code> 层的操作来完成。例如，在一个订单处理业务中，可能需要同时操作订单表、商品表、库存表等多个数据库表，<code>Service</code> 层会负责组织和协调这些操作，保证业务流程的顺利进行。</li><li><strong>代码复用与维护</strong>：将业务逻辑集中在 <code>Service</code> 层，避免在多个 <code>Controller</code> 中重复实现相同的业务逻辑，提高了代码的复用性。同时，当业务规则发生变化时，只需要在 <code>Service</code> 层进行修改，降低了代码的维护成本。</li></ul></li></ul><h3 id="4-扩展功能包"><a href="#4-扩展功能包" class="headerlink" title="4. 扩展功能包"></a><strong>4. 扩展功能包</strong></h3><h4 id="constant-包"><a href="#constant-包" class="headerlink" title="constant 包"></a><strong><code>constant</code> 包</strong></h4><ul><li><p><strong>功能</strong>：全局常量定义。</p></li><li><p>示例</p><p>：</p><ul><li><code>ContextKeyUserObj</code>：JWT 上下文用户键（）。</li><li><code>LOGIN_CODE</code>：验证码 Redis 缓存前缀（）。</li></ul></li></ul><h4 id="validator-包"><a href="#validator-包" class="headerlink" title="validator 包"></a><strong><code>validator</code> 包</strong></h4><ul><li><strong>功能</strong>：请求参数校验（如登录参数非空检查）。</li><li><strong>集成</strong>：通过<code>ShouldBind</code>自动校验请求体（）。</li></ul><h3 id="5-工具包"><a href="#5-工具包" class="headerlink" title="5. 工具包"></a><strong>5. 工具包</strong></h3><h4 id="util-包"><a href="#util-包" class="headerlink" title="util 包"></a><strong><code>util</code> 包</strong></h4><ul><li><p><strong>功能</strong>：通用工具函数。</p></li><li><p>核心工具</p><p>：</p><ul><li><code>EncryptionMd5</code>：密码加密（）。</li><li><code>RedisStore</code>：验证码 Redis 存取（）。</li><li><code>ipUtil</code>：IP 地址解析（）。</li></ul></li></ul><h3 id="6-外部依赖包"><a href="#6-外部依赖包" class="headerlink" title="6. 外部依赖包"></a><strong>6. 外部依赖包</strong></h3><h4 id="Gin-框架相关"><a href="#Gin-框架相关" class="headerlink" title="Gin 框架相关"></a><strong>Gin 框架相关</strong></h4><ul><li><p>**<code>github.com/gin-gonic/gin</code>**：核心 Web 框架，处理路由与请求（）。</p></li><li><p>中间件扩展</p><p>：</p><ul><li><code>github.com/swaggo/gin-swagger</code>：Swagger 文档生成（）。</li></ul></li></ul><h4 id="数据库与缓存"><a href="#数据库与缓存" class="headerlink" title="数据库与缓存"></a><strong>数据库与缓存</strong></h4><ul><li>**<code>gorm.io/gorm</code>**：ORM 操作 MySQL（）。</li><li>**<code>github.com/go-redis/redis/v8</code>**：Redis 客户端（）。</li></ul><h3 id="包协作示例（用户登录流程）"><a href="#包协作示例（用户登录流程）" class="headerlink" title="包协作示例（用户登录流程）"></a><strong>包协作示例（用户登录流程）</strong></h3><ol><li>**<code>controller</code>**：接收登录请求（）。</li><li>**<code>service</code>**：校验参数 → 调用<code>dao</code>查询用户（）。</li><li>**<code>dao</code>**：通过 GORM 操作 MySQL（）。</li><li>**<code>jwt</code>**：生成 JWT Token（）。</li><li>**<code>middleware</code>**：鉴权中间件验证 Token 有效性（）。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>该项目通过分层架构实现职责分离：</p><ul><li><strong>基础设施层</strong>（<code>pkg</code>、<code>common</code>）：提供底层支撑（配置、数据库、缓存）。</li><li><strong>业务逻辑层</strong>（<code>api</code>）：实现具体功能（用户、角色、菜单管理）。</li><li><strong>控制层</strong>（<code>router</code>、<code>middleware</code>）：处理请求路由与中间件逻辑。</li></ul><p>掌握这些包的功能，可快速定位代码逻辑，理解项目架构设计。</p><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p><strong>JWT 介绍</strong><br>JWT 是一种用于安全地传输信息的令牌，由三部分组成：</p><ul><li><strong>Header</strong>：声明令牌类型和加密算法。</li><li><strong>Payload</strong>：包含声明（例如用户信息）。</li><li><strong>Signature</strong>：用密钥签名确保数据的完整性。</li></ul><p><strong>JWT 的工作原理</strong>：</p><ul><li>用户登录后，服务器验证身份并生成 JWT Token。</li><li>客户端在后续请求中携带 Token，服务器验证 Token 以确认用户身份。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/16/ba-gu-su-ji-ban/"/>
      <url>/2025/03/16/ba-gu-su-ji-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="八股速记版"><a href="#八股速记版" class="headerlink" title="八股速记版"></a>八股速记版</h1><ol start="4"><li><strong>TCP与UDP的概念，特点，区别和对应的使用场景</strong></li></ol><p><strong>概念</strong></p><p><strong>TCP</strong>：（传输控制协议）是⼀种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p><strong>UDP</strong>：（用户数据报协议）为应用程序提供了⼀种无需建立连接就可以发送封装的IP数据包的方法。</p><p><strong>特点</strong></p><p>TCP ：面向连接，传输可靠，传输形式为字节流，传输效率慢，所需资源多。</p><p>UDP ：无连接、传输不可靠、传输形式为数据报文段，传输效率快，所需资源少。</p><p><strong>区别：</strong>（7个方面）</p><ul><li><p>连接</p><ul><li>TCP面向连接、传输前要建立连接</li><li>UDP直接传输</li></ul></li><li><p>可靠性</p><ul><li><p>TCP传输可靠数据</p></li><li><p>UDP不保证（但是可通过QUIC等协议实现可靠传输）</p></li></ul></li><li><p>服务对象</p><ul><li>TCP一对一</li><li>UDP一对一、一对多、多对多</li></ul></li><li><p>拥塞控制、流量控制</p><ul><li>TCP有，保证数据安全</li><li>UDP无，网络再堵，不影响它发送</li></ul></li><li><p>首部开销</p><ul><li>TCP首部可变（20~60字节，开销大）</li><li>UDP固定不变（8个字节，开销小）</li></ul></li><li><p>传输方式</p><ul><li>TCP：流式传输，无边界，可保证顺序和可靠</li><li>UDP：包发送，有边界，可能丢包和乱序<ul><li>无边界就是指TCP将数据视为连续的字节流，比如<code>helloworld</code></li></ul></li></ul></li><li><p>分片不同</p><ul><li>TCP的数据大于MSS，传输层分片</li><li>UDP的数据大于MTU，IP层分片<ul><li>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li><li>MTU：一个网络包的最大长度，以太网中一般为 1500 字节</li></ul></li></ul></li></ul><p><strong>应用场景</strong>：</p><ul><li>TCP：通信数据可靠的场景<ul><li>FTP文件传输</li><li>HTTP&#x2F;HTTPS</li></ul></li><li>UDP：通信速度高的场景<ul><li>DNS，SNMP</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul></li></ul><ol start="5"><li>HTTP请求常见状态码和字段</li></ol><p>在 HTTP 协议中：</p><ul><li><strong>HEAD 请求</strong>：它和 GET 请求类似，主要区别在于 HEAD 请求仅要求服务器返回 HTTP 响应头信息，而不返回响应体（body）数据。比如想获取某个网页的元信息（如内容类型、修改时间等），使用 HEAD 请求能快速获取，无需下载整个页面内容，节省带宽和时间。</li><li><strong>body 数据</strong>：即响应体数据，是服务器响应中包含实际内容的部分 。像访问一个网页，body 里可能是网页的 HTML 代码；请求 API 获取数据时，body 里可能是 JSON 或 XML 格式的具体业务数据。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>轮子项目-gCache</title>
      <link href="/2025/02/27/geecache/"/>
      <url>/2025/02/27/geecache/</url>
      
        <content type="html"><![CDATA[<h1 id="GeeCache"><a href="#GeeCache" class="headerlink" title="GeeCache"></a>GeeCache</h1><h2 id="LRU算法实现"><a href="#LRU算法实现" class="headerlink" title="LRU算法实现"></a>LRU算法实现</h2><p>使用的是<code>container/list&quot;</code>标准库的双向链表。</p><p>因为插入、删除、移动操作均为O(1)</p><p>go语言的<strong>类型断言</strong>：就是将一个<strong>接口类型</strong>转化成<strong>具体的动态类型</strong>（如int、string、或者自定义的类型等）</p><p><code>func (c *Cache) RemoveOldest()&#123;&#125;</code>和<code>func (c Cache) RemoveOldest()&#123;&#125;</code>区别</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>操作对象</strong></th><th align="center"><strong>适用场景</strong></th><th align="center"><strong>示例方法</strong></th></tr></thead><tbody><tr><td align="center"><code>*Cache</code></td><td align="center">原结构体指针</td><td align="center">修改数据、并发控制、LRU 管理</td><td align="center"><code>Set</code>, <code>RemoveOldest</code></td></tr><tr><td align="center"><code>Cache</code></td><td align="center">结构体副本</td><td align="center">只读操作（较少使用）</td><td align="center"><code>GetStat</code></td></tr></tbody></table><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><ul><li>sync.Mutex是一个互斥锁，可以由不同的协程加锁和解锁</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//使用方法</span><span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex<span class="token operator">...</span><span class="token operator">...</span>m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token operator">...</span>m<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="支持并发读写"><a href="#支持并发读写" class="headerlink" title="支持并发读写"></a>支持并发读写</h2><ul><li>byte 类型能够支持任意的数据类型的存储(图片也可以)</li></ul><h2 id="接口型函数"><a href="#接口型函数" class="headerlink" title="接口型函数"></a>接口型函数</h2><ul><li>当某个接口只有<strong>一个</strong>方法时，就可以通过函数来实现这个接口，就是接口型函数</li><li>意义：<ul><li>方便操作吧，就不用额外定义结构体。</li><li>可以将普通函数实现了某个功能后，直接强转为接口型函数，方便直接调用。</li><li>使同一个接口既能处理对象又能处理函数</li></ul></li><li>定义一个函数类型 F，并且实现接口 A 的方法，然后在这个方法中调用自己。这是 Go 语言中将其他函数（参数返回值定义与 F 一致）转换为接口 A 的常用技巧。</li><li>比如：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Getter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> GeterFunc <span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f GetterFunc<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">                            是接收 key <span class="token operator">--</span><span class="token operator">></span> 检查是否被缓存 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 返回缓存值 ⑴                <span class="token operator">|</span>  否                         是                <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 是否应当从远程节点获取 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 与远程节点交互 <span class="token operator">--</span><span class="token operator">></span> 返回缓存值 ⑵                            <span class="token operator">|</span>  否                            <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 调用<span class="token string">`回调函数`</span>，获取值并添加到缓存 <span class="token operator">--</span><span class="token operator">></span> 返回缓存值 ⑶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高内聚、低耦合的含义"><a href="#高内聚、低耦合的含义" class="headerlink" title="高内聚、低耦合的含义"></a>高内聚、低耦合的含义</h2><p>这是软件设计中的两个重要原则，用于提高代码的可维护性、可扩展性和可复用性。</p><h4 id="高内聚（High-Cohesion）"><a href="#高内聚（High-Cohesion）" class="headerlink" title="高内聚（High Cohesion）"></a><strong>高内聚（High Cohesion）</strong></h4><ul><li><strong>定义</strong>：一个模块或类内部的各个部分（如函数、方法）之间的相关性很高，共同完成一个明确的任务。</li><li>优点：<ul><li>代码更易于理解和维护，因为每个模块只关注一个明确的功能。</li><li>减少模块内部的复杂性，降低出错概率。</li></ul></li><li>示例：<ul><li><code>getLocally</code> 只负责从本地数据源加载数据，不关心缓存更新或分布式加载，这就是高内聚的体现。</li></ul></li></ul><h4 id="低耦合（Low-Coupling）"><a href="#低耦合（Low-Coupling）" class="headerlink" title="低耦合（Low Coupling）"></a><strong>低耦合（Low Coupling）</strong></h4><ul><li><strong>定义</strong>：模块或类之间的依赖关系尽可能少，一个模块的变化不会对其他模块产生太大影响。</li><li>优点：<ul><li>提高代码的复用性，模块可以独立使用。</li><li>便于扩展和维护，修改一个模块不会影响其他模块。</li></ul></li><li>示例：<ul><li><code>load</code> 函数只依赖 <code>getLocally</code> 和 <code>populateCache</code>，而不直接依赖具体的缓存实现或数据源实现，这就是低耦合的体现。</li></ul></li></ul><h2 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h2><ul><li><p><code>str := fmt.Sprintf(&quot;%d/%s/%f/%t/....&quot;, n)</code>可以将其他类型的变量转化成格式化的字符串</p></li><li><p><code>r.URL.Path</code>相当于去掉了前面的域名和端口号</p></li><li><p>HTTP请求到来后，<code>Handler</code>会直接调用<code>ServeHTTP</code>方法。</p></li></ul><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p><strong>穿透</strong>：指查询不一定存在的数据，此时从数据源查询不到结果，因此也无法对结果进行缓存，这直接导致此类型的查询请求每次都会落到后端，加大后端的压力；</p><p><strong>击穿</strong>：指对于那些热点数据，在缓存失效的时候，高并发的请求会导致后端请求压力骤升。缓存失效可能是多种因素引起的：</p><ul><li>比如扫描式的遍历</li><li>比如缓存时间到期</li><li>或者请求过大，不断的cache不断的淘汰导致</li></ul><p><strong>缓存雪崩</strong>：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。</p><p><strong>一致性哈希算法</strong>：是一种分布式系统中常用的负载均衡算法，主要用于解决数据分布不均和节点动态变化时的高效数据迁移问题。其核心思想是通过构建一个环形哈希空间，将数据和节点映射到环上，从而实现数据的均匀分布和节点变更时的最小影响。</p><p>实现选择节点的<code>Get()</code>方法时，取余主要是为了保证环，更具体就是当key大于所有keys时，取余保证选的节点下标为0</p><h2 id="分布式节点"><a href="#分布式节点" class="headerlink" title="分布式节点"></a>分布式节点</h2><ul><li>实现（2）</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">                            是接收 key <span class="token operator">--</span><span class="token operator">></span> 检查是否被缓存 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 返回缓存值 ⑴                <span class="token operator">|</span>  否                         是                <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 是否应当从远程节点获取 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 与远程节点交互 <span class="token operator">--</span><span class="token operator">></span> 返回缓存值 ⑵                            <span class="token operator">|</span>  否                            <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 调用<span class="token string">`回调函数`</span>，获取值并添加到缓存 <span class="token operator">--</span><span class="token operator">></span> 返回缓存值 ⑶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>细化（2）</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">使用一致性哈希选择节点        是                                    是    <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 是否是远程节点 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> HTTP 客户端访问远程节点 <span class="token operator">--</span><span class="token operator">></span> 成功？<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> 服务端返回返回值                    <span class="token operator">|</span>  否                                    ↓  否                    <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> 回退到本地节点处理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>url.QueryEscape()</code>是将字符串中的特殊字符转义，确保它们可以安全地作为 URL 查询参数使用。特殊字符如：<strong>空格</strong>、”**&amp;**“等。</p></li><li><p><code>var _ PeerGetter = (*httpGetter)(nil)</code>功能：</p><ul><li>确保 <code>*httpGetter</code> 类型实现了 <code>PeerGetter</code> 接口。如果 <code>httpGetter</code> 没有实现 <code>Get</code> 方法，编译器会报错，提示 <code>*httpGetter</code> 类型没有实现 <code>PeerGetter</code> 接口。</li><li>注：只有指针类的<code>httpGetter</code>才实现了<code>PeerGetter</code>接口。</li></ul></li><li><p><strong>实现 <code>ServeHTTP</code> 方法</strong>：可以让一个类型作为 HTTP 服务器，处理 HTTP 请求。</p></li><li><p>**调用 <code>http.Get</code>**：可以让一个程序作为 HTTP 客户端，发送 HTTP 请求。</p></li><li><p>**<code>HTTPPool</code>**：通过实现 <code>ServeHTTP</code> 方法和调用 <code>http.Get</code>，同时扮演了服务器和客户端的角色，实现了分布式缓存系统的功能。</p></li><li><p><code>log.Fatal(http.ListenAndServe(addr[7:], peers))</code></p><ul><li>如果服务器正常运行，<code>http.ListenAndServe</code> 会一直阻塞，不会返回。因此，<code>log.Fatal</code> 不会被执行，程序也不会被终止。</li><li>只有在服务器发生错误或关闭时，<code>http.ListenAndServe</code> 才会返回，此时 <code>log.Fatal</code> 才会输出日志并终止程序。</li></ul></li></ul><p><code>flag.IntVar</code>、<code>flag.BoolVar</code> 和 <code>flag.Parse</code>这三个的使用可以使用户灵活使用命令行进行对缓存服务器的开启。</p><p><code>/api-&gt;Get-&gt;load-&gt;HTTPPool的PickPeer去找对应的节点</code></p><h2 id="防止缓存击穿"><a href="#防止缓存击穿" class="headerlink" title="防止缓存击穿"></a>防止缓存击穿</h2><p><strong>锁的核心作用</strong></p><ul><li>**<code>sync.Mutex</code>**：保护共享资源m（记录请求状态），确保并发操作的原子性。</li><li>**<code>sync.WaitGroup</code>**：协调多个协程的等待与唤醒，避免重复执行相同请求。</li></ul><h2 id="使用-Protobuf-通信"><a href="#使用-Protobuf-通信" class="headerlink" title="使用 Protobuf 通信"></a>使用 Protobuf 通信</h2><p><a href="https://geektutu.com/post/quick-go-protobuf.html">https://geektutu.com/post/quick-go-protobuf.html</a></p><p>protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。</p>]]></content>
      
      
      <categories>
          
          <category> go项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go语言 </tag>
            
            <tag> go项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（12）</title>
      <link href="/2024/12/13/mei-ri-xue-xi-12/"/>
      <url>/2024/12/13/mei-ri-xue-xi-12/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="9-分割回文串"><a href="#9-分割回文串" class="headerlink" title="9. 分割回文串"></a>9. 分割回文串</h4><p>和组合类似，但是记住是<strong>分割</strong>。重点是</p><ul><li>划分字串判断回文：<code>str = s[start:i+1]</code></li><li>终止条件：<code>start = len(s)</code></li></ul><h4 id="10-复原IP地址"><a href="#10-复原IP地址" class="headerlink" title="10. 复原IP地址"></a>10. 复原IP地址</h4><ul><li>和9很类似，只是注意终止条件多加一个<code>len(path) == 4</code></li></ul><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h5 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h5><ul><li>IP层进行分片传输，效率很低。因为一个IP分片丢了，整个IP报文分片都需要重传。并且IP层本身没有超时重传机制，只能等传输层TCP来负责。就会重传整个TCP报文，效率太低。</li><li>通过协商MSS值后，只会进行TCP切片，形成的包不会大于MTU，就不会进行IP分片。即便重传也只是以MSS单位，不会重传所有分片。</li><li>MSS最长为1500字节</li></ul><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><ul><li>会进行重传SYN，SYN报文的序列号是一样的。并且重传的SYN的次数限制由内核的<code>tcp_syn_retries</code>参数控制，默认为5。最后一次重传在等待一段时间还是没有收到ACK报文就会断开连接。</li><li>每次重传是在上次的两倍后（1s, 2s, 4s, 8s….）</li></ul><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><ul><li>客户端和服务端都会触发超时重传机制。因为客户端没收到ACK，服务端也没收到ACK。并且同样重传次数由参数控制<code>tcp_syn_retries</code>和<code>tcp_synack_retries</code>，默认值都为5。</li><li>并且某一个超时重传次数过了就直接会断开连接。</li></ul><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><ul><li>服务端触发超时重传机制，重发SYN_ACK报文，知道收到ACK或者断开连接。</li></ul><h5 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h5><ul><li>恶意客户端一直发送SYN报文，占满服务器的半连接队列（内核里），导致后续的SYN报文直接被丢弃。</li><li>避免<ul><li>调大netdev_max_backlog</li><li>增大TCP半连接队列</li><li>开启net.ipv4.tcp_syncookies</li><li>减少 SYN+ACK 重传次数</li></ul></li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>使用swagger</li><li>完善角色和权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（10、11）</title>
      <link href="/2024/12/11/mei-ri-xue-xi-10-11/"/>
      <url>/2024/12/11/mei-ri-xue-xi-10-11/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="4-组合总和III"><a href="#4-组合总和III" class="headerlink" title="4. 组合总和III"></a>4. 组合总和III</h4><ul><li>模板解题</li></ul><h4 id="5-电话号码的字母组合"><a href="#5-电话号码的字母组合" class="headerlink" title="5. 电话号码的字母组合"></a>5. 电话号码的字母组合</h4><ul><li>模板解题，注意string-&gt;[]byte</li></ul><h4 id="7-组合总和"><a href="#7-组合总和" class="headerlink" title="7. 组合总和"></a>7. 组合总和</h4><ul><li>保证无重复的数组：需要有<code>start</code>，并且<code>start=i</code></li></ul><h4 id="8-组合总和II"><a href="#8-组合总和II" class="headerlink" title="8. 组合总和II"></a>8. 组合总和II</h4><ul><li>重点是去重（同层的重复去掉）</li></ul><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h4 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h4><h5 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h5><p><strong>区别：</strong></p><ul><li>连接<ul><li>TCP面向连接、传输前要建立连接</li><li>UDP直接传输</li></ul></li><li>服务对象<ul><li>TCP一对一</li><li>UDP一对一、一对多、多对多</li></ul></li><li>可靠性<ul><li>TCP传输可靠数据</li><li>UDP不保证（但是可通过QUIC等协议实现可靠传输）</li></ul></li><li>拥塞控制、流量控制<ul><li>TCP有，保证数据安全</li><li>UDP无，网络再堵，不影响它发送</li></ul></li><li>首部开销<ul><li>TCP首部可变（开销大）</li><li>UDP固定不变（8个字节，开销小）</li></ul></li><li>传输方式<ul><li>流式传输，无边界，可保证顺序和可靠</li><li>包发送，有边界，可能丢包和乱序</li></ul></li><li>分片不同<ul><li>TCP的数据大于MSS，传输层分片</li><li>UDP的数据大于MTU，IP层分片</li></ul></li></ul><p><strong>应用场景</strong>：</p><ul><li>TCP<ul><li>FTP文件传输</li><li>HTPP&#x2F;HTTPS</li></ul></li><li>UDP<ul><li>DNS，SNMP</li><li>视频、音频等多媒体</li><li>广播通信</li></ul></li></ul><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><ul><li>UDP头部固定、无需额外记录</li><li>TCP头部有个选项，该长度可变，导致TCP头部不固定，需要记录。</li></ul><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><ul><li>TCP数据长度&#x3D;IP总长-IP首部长度-TCP首部长度，这三个长度都是已知的，可以直接算出，不需要额外算出来。</li><li>UDP由于方便处理，需要保证首部长度是4的整数倍，补充了包长度。</li></ul><h5 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h5><p>可以</p><p>TCP 和UDP，在内核中是两个完全独立的软件模块。</p><p>TCP和UDP各自端口号是独立的，他们的80端口是不一样的。</p><p>注：后续还有更详细的内容</p><h4 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h4><h5 id="TCP三次握手过程是怎么样的"><a href="#TCP三次握手过程是怎么样的" class="headerlink" title="TCP三次握手过程是怎么样的"></a>TCP三次握手过程是怎么样的</h5><p>SYN–&gt;ACK、SYN–&gt;ACK</p><ul><li>第一次：客户端发送包文，里面的SYN置1，生成随机序列号（假设为A），不带应用层数据，自己状态变为SYN–SENT</li><li>第二次：服务端发送包文，里面的ACK、SYN置1，生成随机序列号（假设为B），包文的确认应答号设为（A+1），不带应用层数据，自己状态变为SYN–RCVD</li><li>第三次：客户端发送报文，ACK置1，确认应答号设为（B+1），可带应用层数据，状态设为ESTABLISHED</li><li>服务端收到包文，状态也设为ESTABLISHED</li></ul><p>注：在第三次握手的时候就可以携带数据，前两次不行。状态都为ESTABLISHED时，就可互相发送数据了。</p><h5 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h5><p><code>etstat -napt</code>命令查看</p><h5 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h5><ol><li><strong>避免历史连接</strong></li></ol><p>可能由于客户端宕机，第一次发送的请求就失效了，但是第一次发送的请求已经到达服务器，服务器就会返回一个对第一个连接的ACK。同时客户端已经发送了新的请求，接收到服务器对原来请求的ACK，发现不是新连接需要的。就会发送RET，这样服务器就知道原来的没用了，就会接收新的。避免了历史连接。</p><ol start="2"><li><strong>同步双方初始序列号</strong></li></ol><p>序列号是可靠传输的关键，两次握手只能保证一方的初始序列号能被对方接受。                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><p>序列号作用：</p><ul><li>接收方除去重复数据</li><li>接收方根据数据包的序列号按序接收</li><li>可以知道发出去的数据包哪些被正确接收</li></ul><ol start="3"><li><strong>避免资源浪费</strong></li></ol><p>只有两次握手会导致建立多的连接，浪费资源。</p><p>综上，三次握手可以避免历史连接，减少不必要的开销以及同步双方初始序列号。</p><p>两次不能实现避免历<del>、减少</del>、同步~</p><p>而对于四次握手，三次握手就是理论最少握手次数，不需要更多通信次数。</p><h5 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h5><ul><li>防止历史报文被下一个相同四元组的连接接收（主要方面）</li><li>为了安全性，防止黑客伪造相同序列号的TCP被接收</li></ul><h5 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h5><p>基于计时器</p><p>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</p><p>M是计时器，随着时间要增加</p><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>swagger</li><li>captcha</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（9）</title>
      <link href="/2024/12/09/mei-ri-xue-xi-9/"/>
      <url>/2024/12/09/mei-ri-xue-xi-9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul><li><p>回溯和递归是相辅相成的</p></li><li><p>纯暴力搜索</p><ul><li>组合问题（组合是无序的）</li><li>切割问题</li><li>子集问题</li><li>排列问题（强调顺序）</li><li>棋盘问题</li></ul></li><li><p>抽象为树形结构（n叉树）   </p></li><li><p>模板</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        存放结果<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        处理节点<span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>        回溯，撤销处理结果    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>剪枝优化：替换for循环里面小于等于的那个数</p></li></ul><h4 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2. 组合问题"></a>2. 组合问题</h4><ul><li>使用模板就可解题，回溯相当于n层for循环，只是在最开始的if判断就是终止条件。</li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>用户管理</li></ul><p><strong>用户列表分页作用</strong></p><ol><li><p>提升用户体验</p></li><li><p>节省资源</p></li><li><p>支持数据检索和管理</p><ul><li>便于查找特定用户：结合分页和搜索功能，用户可以快速定位目标用户，而不需要滚动浏览整个列表。</li><li>便于排序和过滤：分页让用户可以对数据进行动态排序或过滤，而无需等待整个列表重新加载。</li></ul></li><li><p>增强数据的可控性</p><ul><li>分步加载：分页实现了按需加载数据的机制，避免一次性加载所有数据可能带来的错误或系统崩溃。</li><li>支持无限滚动：虽然是分页的另一种形式，基于分页的无限滚动可以提供更现代的交互体验，同时保持分页的性能优势。</li></ul></li></ol><p><strong>实现了</strong>：</p><ul><li>数据操作层</li><li>业务逻辑层</li><li>控制器层</li></ul><p><code>Query</code>：用于获取 URL 查询字符串（<code>?key=value</code>）。</p><p><code>Param</code>：用于获取 UR</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（8）</title>
      <link href="/2024/12/08/mei-ri-xue-xi-8/"/>
      <url>/2024/12/08/mei-ri-xue-xi-8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="32-将有序数组转换为二叉搜索树（平衡二叉树）"><a href="#32-将有序数组转换为二叉搜索树（平衡二叉树）" class="headerlink" title="32. 将有序数组转换为二叉搜索树（平衡二叉树）"></a>32. 将有序数组转换为二叉搜索树（平衡二叉树）</h4><p>要将数组一直划分成两份，就像搜索树左右大小不同一样，也是越往下越是划分左右大小。</p><p>三部曲中：</p><ul><li>判断终止条件为nums为空</li></ul><h4 id="33-把二叉搜索树转换为累加树"><a href="#33-把二叉搜索树转换为累加树" class="headerlink" title="33. 把二叉搜索树转换为累加树"></a>33. 把二叉搜索树转换为累加树</h4><ul><li>使用右中左递归顺序，来依次累加。</li></ul><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><ul><li>看了TCP面试部分，没看多少</li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>Gin 框架中间件与配置模块</li></ul><ol><li>理解 Gin 框架中间件的工作原理，学习如何编写自定义中间件。</li><li>掌握常用中间件的实现，如日志记录、跨域处理、JWT 鉴权等。</li><li>学习如何设计和使用全局配置模块，管理项目的配置信息。</li></ol><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>日志</li><li>跨域</li><li>鉴权（JWT）</li></ul><h3 id="配置模式设计"><a href="#配置模式设计" class="headerlink" title="配置模式设计"></a>配置模式设计</h3><ul><li>config-config.go</li><li>yaml</li></ul><h3 id="练习任务"><a href="#练习任务" class="headerlink" title="练习任务"></a>练习任务</h3><ol><li><strong>日志中间件</strong><ul><li>编写一个日志中间件，记录请求方法、路径、客户端 IP、响应时间等信息。</li></ul></li><li><strong>跨域支持</strong><ul><li>实现一个跨域中间件，允许特定域名的请求。</li></ul></li><li><strong>配置模块</strong><ul><li>创建一个 <code>config.yaml</code>，加载数据库和 Redis 配置信息。</li><li>在主函数中调用配置，并打印配置信息。</li></ul></li><li><strong>综合练习</strong><ul><li>编写一个具有日志、跨域和 JWT 鉴权功能的 Gin 服务。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（7）</title>
      <link href="/2024/12/07/mei-ri-xue-xi-7/"/>
      <url>/2024/12/07/mei-ri-xue-xi-7/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="30-删除二叉搜索树中的节点"><a href="#30-删除二叉搜索树中的节点" class="headerlink" title="30. 删除二叉搜索树中的节点"></a>30. 删除二叉搜索树中的节点</h4><p>要用left &#x3D; ….，right&#x3D;….，并且对要删除的节点分情况：</p><ul><li>左右都为空（叶子节点）<ul><li>返回nil</li></ul></li><li>左不为空，右为空<ul><li>返回左子树</li></ul></li><li>左为空，右不为空<ul><li>返回右子树</li></ul></li><li>左右都不为空（最复杂）<ul><li>将左子树移动到右子树最左边，返回右子树</li></ul></li></ul><h4 id="31-修剪二叉搜索树"><a href="#31-修剪二叉搜索树" class="headerlink" title="31. 修剪二叉搜索树"></a>31. 修剪二叉搜索树</h4><ul><li>最搞笑的一题，莫名其妙就做出来了</li></ul><p>就是仿上一题，将所有不满足的节点都删掉。</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="3-7-HTTP-3-强势来袭"><a href="#3-7-HTTP-3-强势来袭" class="headerlink" title="3.7 HTTP&#x2F;3 强势来袭"></a>3.7 HTTP&#x2F;3 强势来袭</h3><h3 id="3-8-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#3-8-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="3.8 既然有 HTTP 协议，为什么还要有 RPC？"></a>3.8 既然有 HTTP 协议，为什么还要有 RPC？</h3><h3 id="3-9-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#3-9-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="3.9 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>3.9 既然有 HTTP 协议，为什么还要有 WebSocket？</h3><p>这三个直接看小林coding总结部分</p><ul><li>3.7：<a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93</a></li><li>3.8：<a href="https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93</a></li><li>3.9：<a href="https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93</a></li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis主要是进行短期存储，虽然提供了持久化选项（如 RDB 快照和 AOF 日志），但其主要设计目标是高性能的内存操作。常用于缓存、消息队列、会话管理等场景。</p><p><strong>context</strong></p><ul><li><p><code>context</code> 是管理操作生命周期的核心工具。</p></li><li><p>四种 context 创建方式满足不同需求（根、取消、超时、存储值）。</p></li><li><p>常用于控制 goroutine、网络请求、数据库操作的生命周期。</p></li></ul><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p><strong>JWT 介绍</strong><br>JWT 是一种用于安全地传输信息的令牌，由三部分组成：</p><ul><li><strong>Header</strong>：声明令牌类型和加密算法。</li><li><strong>Payload</strong>：包含声明（例如用户信息）。</li><li><strong>Signature</strong>：用密钥签名确保数据的完整性。</li></ul><p><strong>JWT 的工作原理</strong>：</p><ul><li>用户登录后，服务器验证身份并生成 JWT Token。</li><li>客户端在后续请求中携带 Token，服务器验证 Token 以确认用户身份。</li></ul><h3 id="练习任务"><a href="#练习任务" class="headerlink" title="练习任务"></a><strong>练习任务</strong></h3><ol><li><strong>Redis 缓存练习</strong><ul><li>将用户信息存储到 Redis 中，并模拟缓存失效后从数据库重新获取数据。</li></ul></li><li><strong>JWT 登录功能</strong><ul><li>编写一个模拟登录接口，通过用户名生成 JWT Token，并验证 Token 的有效性。</li></ul></li><li><strong>Redis 与 JWT 结合</strong><ul><li>使用 Redis 存储</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（6）</title>
      <link href="/2024/12/04/mei-ri-xue-xi-6/"/>
      <url>/2024/12/04/mei-ri-xue-xi-6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="26-二叉树就的最近公共祖先"><a href="#26-二叉树就的最近公共祖先" class="headerlink" title="26. 二叉树就的最近公共祖先"></a>26. 二叉树就的最近公共祖先</h4><p>只要找到有p、q就往上返回，相当于回溯（从下往上回），然后判断左右子树是不是不为空，不为空就是最近公共祖先。这个过程包括了p或q本身为公共祖先，因为最终返回的结果只有一个。</p><h4 id="27-二叉搜索树的最近公共祖先"><a href="#27-二叉搜索树的最近公共祖先" class="headerlink" title="27. 二叉搜索树的最近公共祖先"></a>27. 二叉搜索树的最近公共祖先</h4><p>找到第一个在p、q集合里面的就行（包括两端点）</p><h4 id="28-二叉搜索树的插入操作"><a href="#28-二叉搜索树的插入操作" class="headerlink" title="28. 二叉搜索树的插入操作"></a>28. 二叉搜索树的插入操作</h4><p>记住递归三部曲，然后往里面套。一直往下走，直到为空，就可以将节点插入。</p><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="1-路由与控制器"><a href="#1-路由与控制器" class="headerlink" title="1. 路由与控制器"></a>1. 路由与控制器</h3><ul><li>路由基础</li><li>控制器封装</li></ul><h3 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2. 中间件"></a>2. 中间件</h3><p>对于中间件的处理：最终的完整响应是所有中间件和目标路由处理器处理完过后的响应。</p><h3 id="3-路由分组"><a href="#3-路由分组" class="headerlink" title="3. 路由分组"></a>3. 路由分组</h3><h3 id="4-练习任务"><a href="#4-练习任务" class="headerlink" title="4. 练习任务"></a>4. 练习任务</h3><ol><li>修改路由：<ul><li>添加 <code>/hello</code> 路由，返回 <code>&#123;&quot;message&quot;: &quot;hello, world!&quot;&#125;</code>。</li></ul></li><li>实现一个时间中间件：<ul><li>在响应中添加当前服务器时间。</li></ul></li><li>尝试实现一个 POST 接口：<ul><li>接收 JSON 数据，返回原数据。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-Vue（新）</title>
      <link href="/2024/12/04/go-vue-ready/"/>
      <url>/2024/12/04/go-vue-ready/</url>
      
        <content type="html"><![CDATA[<h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="1-路由与控制器"><a href="#1-路由与控制器" class="headerlink" title="1. 路由与控制器"></a>1. 路由与控制器</h3><ul><li>路由基础</li><li>控制器封装</li></ul><h3 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2. 中间件"></a>2. 中间件</h3><p>对于中间件的处理：最终的完整响应是所有中间件和目标路由处理器处理完过后的响应。</p><h3 id="3-路由分组"><a href="#3-路由分组" class="headerlink" title="3. 路由分组"></a>3. 路由分组</h3><h3 id="4-练习任务"><a href="#4-练习任务" class="headerlink" title="4. 练习任务"></a>4. 练习任务</h3><ol><li>修改路由：<ul><li>添加 <code>/hello</code> 路由，返回 <code>&#123;&quot;message&quot;: &quot;hello, world!&quot;&#125;</code>。</li></ul></li><li>实现一个时间中间件：<ul><li>在响应中添加当前服务器时间。</li></ul></li><li>尝试实现一个 POST 接口：<ul><li>接收 JSON 数据，返回原数据。</li></ul></li></ol><h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h3 id="gorm操作"><a href="#gorm操作" class="headerlink" title="gorm操作"></a>gorm操作</h3><ul><li><p>增</p></li><li><p>删</p></li><li><p>改</p></li><li><p>查</p></li><li><p>事务处理</p></li></ul><h3 id="练习任务"><a href="#练习任务" class="headerlink" title="练习任务"></a><strong>练习任务</strong></h3><ol><li><strong>创建一个用户模型</strong>，并进行基本的 CRUD 操作。</li><li><strong>为订单表设计一个与用户的一对多关系</strong>，完成用户与订单的相关操作。</li><li><strong>实现数据的事务处理</strong>，模拟一个修改用户与订单的操作，如果失败则回滚。</li></ol><h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis主要是进行短期存储，虽然提供了持久化选项（如 RDB 快照和 AOF 日志），但其主要设计目标是高性能的内存操作。常用于缓存、消息队列、会话管理等场景。</p><p><strong>context</strong></p><ul><li><p><code>context</code> 是管理操作生命周期的核心工具。</p></li><li><p>四种 context 创建方式满足不同需求（根、取消、超时、存储值）。</p></li><li><p>常用于控制 goroutine、网络请求、数据库操作的生命周期。</p></li></ul><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p><strong>JWT 介绍</strong><br>JWT 是一种用于安全地传输信息的令牌，由三部分组成：</p><ul><li><strong>Header</strong>：声明令牌类型和加密算法。</li><li><strong>Payload</strong>：包含声明（例如用户信息）。</li><li><strong>Signature</strong>：用密钥签名确保数据的完整性。</li></ul><p><strong>JWT 的工作原理</strong>：</p><ul><li>用户登录后，服务器验证身份并生成 JWT Token。</li><li>客户端在后续请求中携带 Token，服务器验证 Token 以确认用户身份。</li></ul><h3 id="练习任务-1"><a href="#练习任务-1" class="headerlink" title="练习任务"></a><strong>练习任务</strong></h3><ol><li><strong>Redis 缓存练习</strong><ul><li>将用户信息存储到 Redis 中，并模拟缓存失效后从数据库重新获取数据。</li></ul></li><li><strong>JWT 登录功能</strong><ul><li>编写一个模拟登录接口，通过用户名生成 JWT Token，并验证 Token 的有效性。</li></ul></li><li><strong>Redis 与 JWT 结合</strong><ul><li>使用 Redis 存储已登录用户的 Token，模拟 Token 的过期或强制下线。</li></ul></li></ol><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><ul><li>Gin 框架中间件与配置模块</li></ul><ol><li>理解 Gin 框架中间件的工作原理，学习如何编写自定义中间件。</li><li>掌握常用中间件的实现，如日志记录、跨域处理、JWT 鉴权等。</li><li>学习如何设计和使用全局配置模块，管理项目的配置信息。</li></ol><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>日志</li><li>跨域</li><li>鉴权（JWT）</li></ul><h3 id="配置模式设计"><a href="#配置模式设计" class="headerlink" title="配置模式设计"></a>配置模式设计</h3><ul><li>config-config.go</li><li>yaml</li></ul><h3 id="练习任务-2"><a href="#练习任务-2" class="headerlink" title="练习任务"></a>练习任务</h3><ol><li><strong>日志中间件</strong><ul><li>编写一个日志中间件，记录请求方法、路径、客户端 IP、响应时间等信息。</li></ul></li><li><strong>跨域支持</strong><ul><li>实现一个跨域中间件，允许特定域名的请求。</li></ul></li><li><strong>配置模块</strong><ul><li>创建一个 <code>config.yaml</code>，加载数据库和 Redis 配置信息。</li><li>在主函数中调用配置，并打印配置信息。</li></ul></li><li><strong>综合练习</strong><ul><li>编写一个具有日志、跨域和 JWT 鉴权功能的 Gin 服务。</li></ul></li></ol><h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><ul><li>用户管理</li></ul><h3 id="用户列表分页作用"><a href="#用户列表分页作用" class="headerlink" title="用户列表分页作用"></a>用户列表分页作用</h3><h4 id="1-提升用户体验"><a href="#1-提升用户体验" class="headerlink" title="1. 提升用户体验"></a>1. <strong>提升用户体验</strong></h4><ul><li><strong>减少加载时间</strong>：如果用户列表包含成百上千的用户，一次性加载所有数据会导致页面加载缓慢。分页可以显著减少每次请求的数据量，提高加载速度。</li><li><strong>便于浏览</strong>：分页将用户列表分成多个页面，方便用户逐页查看，避免信息过载。</li></ul><h4 id="2-节省资源"><a href="#2-节省资源" class="headerlink" title="2. 节省资源"></a>2. <strong>节省资源</strong></h4><ul><li><strong>降低服务器负载</strong>：分页可以减少每次从数据库查询和返回的数据量，降低服务器内存和网络资源的占用。</li><li><strong>优化前端性能</strong>：前端渲染大量数据会导致性能下降。分页让前端只需渲染当前页的数据，减轻浏览器负担。</li></ul><h4 id="3-支持数据检索和管理"><a href="#3-支持数据检索和管理" class="headerlink" title="3. 支持数据检索和管理"></a>3. <strong>支持数据检索和管理</strong></h4><ul><li><strong>便于查找特定用户</strong>：结合分页和搜索功能，用户可以快速定位目标用户，而不需要滚动浏览整个列表。</li><li><strong>便于排序和过滤</strong>：分页让用户可以对数据进行动态排序或过滤，而无需等待整个列表重新加载。</li></ul><h4 id="4-增强数据的可控性"><a href="#4-增强数据的可控性" class="headerlink" title="4. 增强数据的可控性"></a>4. <strong>增强数据的可控性</strong></h4><ul><li><strong>分步加载</strong>：分页实现了按需加载数据的机制，避免一次性加载所有数据可能带来的错误或系统崩溃。</li><li><strong>支持无限滚动</strong>：虽然是分页的另一种形式，基于分页的无限滚动可以提供更现代的交互体验，同时保持分页的性能优势。</li></ul><hr><p>实现了：</p><ul><li>数据操作层</li><li>业务逻辑层</li><li>控制器层</li></ul><p><code>Query</code>：用于获取 URL 查询字符串（<code>?key=value</code>）。</p><p><code>Param</code>：用于获取 URL 路径中的动态部分（<code>/path/:param</code>）</p><h2 id="day6、day7"><a href="#day6、day7" class="headerlink" title="day6、day7"></a>day6、day7</h2><ul><li>Swagger：多用几次就会了</li></ul><h3 id="CAPTCHA"><a href="#CAPTCHA" class="headerlink" title="CAPTCHA"></a>CAPTCHA</h3><p> 是 “Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写。它是一种安全机制，用于确定与网站或应用程序交互的是人类还是自动化程序（如机器人）。CAPTCHA 的主要目的是保护在线资源免受滥用，例如防止自动注册、评论垃圾信息、票务抢购等。</p><h2 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h2><ul><li>包管理</li></ul><hr><p><code>util</code>包：</p><ul><li>将那些通用的工具放在里面</li></ul><p><code>dao</code>包：</p><ul><li>与数据库有关的操作</li></ul><p><code>Service</code>包：</p><ul><li>业务逻辑处理，相当于实现功能<ul><li>里面的文件定义了接口</li></ul></li></ul><p><code>Controller</code>包：</p><ul><li>负责处理HTTP的请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> gin </tag>
            
            <tag> gorm </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> swagger </tag>
            
            <tag> jwt </tag>
            
            <tag> base64Captcha </tag>
            
            <tag> yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（5）</title>
      <link href="/2024/12/02/mei-ri-xue-xi-5/"/>
      <url>/2024/12/02/mei-ri-xue-xi-5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="21-合并二叉树"><a href="#21-合并二叉树" class="headerlink" title="21. 合并二叉树"></a>21. 合并二叉树</h4><p>两棵树跟着一起遍历，左对左，右对右。依旧是递归遍历为基础，加上变式。</p><h4 id="22-二叉搜索树的搜索"><a href="#22-二叉搜索树的搜索" class="headerlink" title="22. 二叉搜索树的搜索"></a>22. 二叉搜索树的搜索</h4><p>根据值的大小来选择往左还是往右遍历</p><h4 id="23-验证二叉搜索树"><a href="#23-验证二叉搜索树" class="headerlink" title="23. 验证二叉搜索树"></a>23. 验证二叉搜索树</h4><p>先用中序递归遍历收集值，再判断是否为二叉搜索树（单调递增就是）</p><h4 id="24-二叉搜索树的最小绝对差"><a href="#24-二叉搜索树的最小绝对差" class="headerlink" title="24. 二叉搜索树的最小绝对差"></a>24. 二叉搜索树的最小绝对差</h4><p>一样中序递归收集值，再左右相减比较最小的差值就行</p><h4 id="25-二叉搜索树中的众数"><a href="#25-二叉搜索树中的众数" class="headerlink" title="25. 二叉搜索树中的众数"></a>25. 二叉搜索树中的众数</h4><p>中序递归收集值，再用map存，再选出最多的append到res里面 </p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTP-2牛逼在哪"><a href="#HTTP-2牛逼在哪" class="headerlink" title="HTTP&#x2F;2牛逼在哪"></a>HTTP&#x2F;2牛逼在哪</h3><ul><li><p>兼容HTTP&#x2F;1.1</p></li><li><p>头部压缩：使用HPACK算法：（1）静态字典（2）动态字典（3）Huffman编码（压缩算法）</p><ul><li>静态字典：k-v</li></ul></li><li><p>二进制帧：将一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码（head+data）</p></li><li><p>并发传输：stream流（一条TCP连接传输多个stream，一个stream可以包含多个message（里面是请求或响应），message包含一个或多个Frame（存放的是压缩的头和body）</p></li><li><p>服务器主动推送资源：请求一个html，服务器可以主动发送css等。</p></li></ul><p>注：项目有点学不来</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（4）</title>
      <link href="/2024/12/01/mei-ri-xue-xi-4/"/>
      <url>/2024/12/01/mei-ri-xue-xi-4/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="18-从中序和后序遍历序列构造二叉树"><a href="#18-从中序和后序遍历序列构造二叉树" class="headerlink" title="18. 从中序和后序遍历序列构造二叉树"></a>18. 从中序和后序遍历序列构造二叉树</h4><p>主要是用到后序遍历的那个数组，用来找到根节点。然后通过中序遍历的那个数组找到根节点位置与左右子树他们的范围长度。并且用<code>map</code>存中序数组的位置，供每次遍历的时候找到根节点和左右子树。重点其实就是划分子树长度、应该怎么取端点位置。然后就按照基础的遍历顺序来遍历</p><h4 id="19-最大二叉树"><a href="#19-最大二叉树" class="headerlink" title="19. 最大二叉树"></a>19. 最大二叉树</h4><p>18题会了，19题就会。19比18简单，因为更好划分。</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTPS如何优化"><a href="#HTTPS如何优化" class="headerlink" title="HTTPS如何优化"></a>HTTPS如何优化</h3><p>先分析性能损耗，再来看怎么优化：</p><p>耗能阶段：</p><ul><li>TLS握手过程</li><li>握手后的对称加密包文传输</li></ul><p>多角度：</p><ul><li>硬件优化<ul><li>https是计算密集型，搞好一点的cpu，算得快</li></ul></li><li>软件优化<ul><li>软件升级：相对于协议优化，成本开销大</li><li>协议优化</li></ul></li><li>协议优化<ul><li>就是对密钥交换过程优化：<ul><li>算法优化：RSA换成ECDHE（2RTT-&gt;1RTT）时间减少，安全性增加</li><li>TLS升级：TLS1.2变为TLS1.3，TLS握手只要1RTT。因为1.3在客户端第一次握手时就将公钥交换这些发送给客户端了。</li></ul></li></ul></li><li>证书优化<ul><li>证书传输：用ECDHE证书，相同安全度下，密钥比RSA更短</li><li>证书验证：使用OCSP Stapling作为验证（验证证书是否还有效，可能被吊销）</li></ul></li><li>会话复用<ul><li>Session ID：双方都缓存会话密钥，并用Session ID唯一标识，再次连接时客户端hello消息带上这个Session ID，服务器匹配上就可以只需要发送一个消息返回就建立安全连接了。</li><li>Session Ticket：为了减少服务端的缓存，服务端将会话密钥加密放在客户端这里保存。然后再次建立连接时，客户端发送Ticket，服务器解密并验证有效期，就可建立安全通信。</li><li>上述两种都需要1RTT才可以建立， TLS1.3重连只需要0RTT，使用<strong>Pre-shared Key</strong>方法。客户端会把 Ticket 和 HTTP 请求一同发送给服务端。</li><li>注：会话复用不支持前向安全，且用重放攻击危险</li></ul></li></ul><h2 id="课程作业"><a href="#课程作业" class="headerlink" title="课程作业"></a>课程作业</h2><ul><li>项目申请书</li><li>联邦学习介绍需要的PPT</li><li>网课选择题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> 课程作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（3）</title>
      <link href="/2024/11/29/mei-ri-xue-xi-3/"/>
      <url>/2024/11/29/mei-ri-xue-xi-3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="16-找树左下角的值"><a href="#16-找树左下角的值" class="headerlink" title="16. 找树左下角的值"></a>16. 找树左下角的值</h4><p>先找出最大深度，再左边。可以先dfs，再用队列</p><h4 id="17-路径总和"><a href="#17-路径总和" class="headerlink" title="17. 路径总和"></a>17. 路径总和</h4><p>同15一样，遍历基础上加判断条件</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTPS-RSA握手解析"><a href="#HTTPS-RSA握手解析" class="headerlink" title="HTTPS RSA握手解析"></a>HTTPS RSA握手解析</h3><p><strong>RTT</strong>(往返时延)：发送端发送一个数据包到接收端，接收端返回确认包到发送端的整个时间。</p><p>整个TLS握手过程前面已经总结</p><p>补充以下：</p><ul><li><p>四次握手，需要2个RTT时延</p></li><li><p>密码套件基本形式为：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</p></li><li><p>CA进行签名过程为：对持有者的公钥等信息进行打包，然后对这个包进行hash计算，得到hash值，然后用私钥对这个值进行加密。</p></li><li><p>第三次握手，最后客户端发送的摘要信息，使用的是会话密钥加密。目的是验证加密通信是否可用和前面整个握手信息是否有被篡改。</p></li><li><p>RSA不支持前向保密，私钥一旦泄密，以前的所有TLS密文都被破解。</p></li></ul><p>前向保密：即使密钥被泄露，过去的信息也不会被解密。每次通信生成的都是临时密钥。</p><h3 id="HTTPS-ECDHE-握手解析"><a href="#HTTPS-ECDHE-握手解析" class="headerlink" title="HTTPS ECDHE 握手解析"></a>HTTPS ECDHE 握手解析</h3><p>算法核心思想：离散对数</p><p>ECDHE算法具有前向安全，现在被广泛使用。</p><p>DH-&gt;DHE-&gt;ECDHE</p><p>ECDHE算法实在DHE算法基础上使用了ECC椭圆曲线特性，用更少的计算量计算出公钥和最终的会话密钥。</p><p>TLS第一次握手，客户端：（1）TLS版本号（2）支持的密码套件（3）生成的随机数</p><p>TLS第二次握手，服务器:（1）确认TLS版本号（2）随机数（3）选择密码套件（4）数字证书（5）发送Server Key Exchange 消息</p><ul><li>Server Key Exchange 消息包括：<ul><li>选好了椭圆曲线（基点G也确定）</li><li>服务端椭圆曲线公钥</li></ul></li></ul><p>TLS第三次握手，客户端:（1）发送Client Key Exchange消息（2）发送后续改用对称算法加密通信（3）摘要信息使用对称密钥加密发送</p><ul><li>Client Key Exchange消息包括：<ul><li>客户端椭圆曲线公钥</li></ul></li></ul><p>TLS第四次握手，服务端:（1）发送改用对称算法加密通信（2）摘要信息使用对称密钥加密发送</p><p>注：</p><ol><li><p>会话密钥&#x3D;客户端随机数+服务端随机数+椭圆曲线生成的共享密钥</p></li><li><p>RSA在TLS完成四次握手后才能进行应用数据的传输；而ECDHE算法，客户端可以不等服务器最后一次TLS握手就进行加密HTTP数据传送，节省一个RTT时间。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-Vue通用后台管理</title>
      <link href="/2024/11/28/go-vue/"/>
      <url>/2024/11/28/go-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-Vue通用后台管理"><a href="#Go-Vue通用后台管理" class="headerlink" title="Go-Vue通用后台管理"></a>Go-Vue通用后台管理</h1><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><h3 id="1-在db-go中"><a href="#1-在db-go中" class="headerlink" title="1. 在db.go中"></a>1. 在db.go中</h3><h4 id="1-Db-err-gorm-Open-mysql-Open-url-gorm-Config-）"><a href="#1-Db-err-gorm-Open-mysql-Open-url-gorm-Config-）" class="headerlink" title="1.Db, err &#x3D; gorm.Open(mysql.Open(url), &amp;gorm.Config{}）"></a>1.Db, err &#x3D; gorm.Open(mysql.Open(url), &amp;gorm.Config{}）</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">Db<span class="token punctuation">,</span> err <span class="token operator">=</span> gorm<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>mysql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>gorm<span class="token punctuation">.</span>Config<span class="token punctuation">&#123;</span>Logger<span class="token punctuation">:</span> logger<span class="token punctuation">.</span>Default<span class="token punctuation">.</span><span class="token function">LogMode</span><span class="token punctuation">(</span>logger<span class="token punctuation">.</span>Info<span class="token punctuation">)</span><span class="token punctuation">,</span>DisableForeignKeyConstraintWhenMigrating<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-gorm-Open"><a href="#1-gorm-Open" class="headerlink" title="1. gorm.Open"></a>1. <strong><code>gorm.Open</code></strong></h5><ul><li>GORM 是一个流行的 Golang ORM（对象关系映射）框架，用于简化数据库操作。</li><li><code>gorm.Open</code> 用于初始化数据库连接。</li></ul><h5 id="2-mysql-Open-url"><a href="#2-mysql-Open-url" class="headerlink" title="2. mysql.Open(url)"></a>2. <strong><code>mysql.Open(url)</code></strong></h5><ul><li><code>mysql.Open(url)</code> 指定了数据库的驱动和数据源。</li><li><code>url</code> 是之前构造的 MySQL 数据库连接字符串。</li><li><code>mysql</code> 是 <code>gorm.io/driver/mysql</code> 驱动，用于支持 MySQL 数据库。</li></ul><h5 id="3-gorm-Config"><a href="#3-gorm-Config" class="headerlink" title="3. &amp;gorm.Config{}"></a>3. <strong><code>&amp;gorm.Config&#123;&#125;</code></strong></h5><ul><li>传入一个配置结构体，用于定制 GORM 的行为。</li><li>在这里，配置了两个重要选项：</li><li>**<code>Logger: logger.Default.LogMode(logger.Info)</code>**：<ul><li>配置 GORM 的日志级别。</li><li><code>logger.Default</code> 是默认日志记录器。</li><li><code>LogMode(logger.Info)</code>设置日志模式为  <code>Info</code> 级别，这会输出一些基本的 SQL 查询和执行信息。<ul><li>例如：INSERT、UPDATE、DELETE 语句和时间消耗等。</li></ul></li></ul></li><li>**<code>DisableForeignKeyConstraintWhenMigrating: true</code>**：<ul><li>关闭迁移时的外键约束创建。</li><li>默认情况下，GORM 在迁移（比如 <code>db.AutoMigrate</code>）时，会自动为模型中的外键创建数据库级别的外键约束。</li><li>设置为 <code>true</code> 后，会跳过这一步。</li><li>这种配置通常用于提高迁移速度，或因为某些数据库（如 MySQL）对外键约束的支持可能影响性能或灵活性。</li></ul></li></ul><h5 id="4-Db-和-err"><a href="#4-Db-和-err" class="headerlink" title="4. Db 和 err"></a>4. <strong><code>Db</code> 和 <code>err</code></strong></h5><ul><li><code>Db</code> 是全局变量，用于保存数据库连接实例，通常是一个 <code>*gorm.DB</code> 类型。</li><li><code>err</code> 是可能发生的错误，表示连接或配置是否成功。如果连接失败，<code>err</code> 将不为 <code>nil</code>。</li></ul><h3 id="2-cors-go"><a href="#2-cors-go" class="headerlink" title="2. cors.go"></a>2. cors.go</h3><p> chatgpt说：<code>c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)</code>和<code>c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</code>不可同时存在。</p><h3 id="3-authMiddleware-go"><a href="#3-authMiddleware-go" class="headerlink" title="3. authMiddleware.go"></a>3. authMiddleware.go</h3><p><code>c.Abort()</code>：是用来终止当前请求的处理，并且阻止后续的中间件或处理函数继续执行。这个方法通常用于某些特殊场景，例如当请求没有通过鉴权或验证时，终止请求</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="跨域中间件"><a href="#跨域中间件" class="headerlink" title="跨域中间件"></a>跨域中间件</h3><p>跨域就是允许客户端（浏览器）从一个域向另一个域的服务器发起跨域请求并成功接收响应。</p><p>因为前后端分离部署时，请求接口不同。比如：</p><p>前端运行在 <code>http://localhost:3000</code></p><p>后端运行在 <code>http://localhost:8080</code></p><p>跨域中间件相当于允许客户端在3000这个端口请求8000这个端口的响应</p><h4 id="跨域中间件通过HTTP响应头来实现"><a href="#跨域中间件通过HTTP响应头来实现" class="headerlink" title="跨域中间件通过HTTP响应头来实现"></a>跨域中间件通过HTTP响应头来实现</h4><ul><li><p>允许客户端安全地发起跨域请求。</p></li><li><p>响应浏览器的跨域策略检查。</p></li><li><p>提高开发效率，简化跨域相关配置。</p></li></ul><p>是前后端分离项目不可或缺的一部分</p><p>发送<code>OPPTIONS</code>请求，用于询问服务器是否允许跨域请求。</p><h3 id="鉴权中间件"><a href="#鉴权中间件" class="headerlink" title="鉴权中间件"></a>鉴权中间件</h3><ul><li><p><strong>鉴权中间件</strong> 是用来验证请求是否有有效的身份认证信息的中间件，通常用于保护需要身份认证的资源。</p></li><li><p>它在请求进入业务逻辑处理之前执行，确保只有通过认证的用户才能继续访问。</p></li><li><p>通过使用鉴权中间件，可以实现基于 Token（如 JWT）、Session 或 API Key 的认证方法。</p></li><li><p><strong>JWT</strong> 是现代 Web 应用中常用的鉴权机制，它通过在每个请求中携带 token 来进行身份验证。</p></li></ul><h3 id="config-yaml"><a href="#config-yaml" class="headerlink" title="config.yaml"></a>config.yaml</h3><p><code>config.yaml</code> 文件的主要作用是作为应用程序的配置文件，用于存储和管理应用的各种配置信息。它使得开发、运维人员可以灵活地调整应用程序的行为，而不需要修改源代码或重新编译程序。以下是 <code>config.yaml</code> 文件的作用总结：</p><h4 id="1-配置管理："><a href="#1-配置管理：" class="headerlink" title="1. 配置管理："></a>1. <strong>配置管理</strong>：</h4><ul><li><strong>集中管理配置</strong>：通过 <code>config.yaml</code> 文件，可以集中管理应用程序的配置信息，如数据库连接、服务器端口、API 密钥等。</li><li><strong>灵活调整</strong>：配置文件的修改不需要改变应用程序的代码，只需要修改配置文件即可改变应用行为。</li></ul><h4 id="2-人类可读："><a href="#2-人类可读：" class="headerlink" title="2. 人类可读："></a>2. <strong>人类可读</strong>：</h4><ul><li><strong>易于理解和编辑</strong>：YAML 格式比 JSON 更加简洁和易读，适合开发人员和运维人员编辑。配置项可以直观地表示应用程序的行为，如 <code>server.host</code>、<code>database.password</code> 等。</li></ul><h4 id="3-环境适配："><a href="#3-环境适配：" class="headerlink" title="3. 环境适配："></a>3. <strong>环境适配</strong>：</h4><ul><li><strong>支持不同环境的配置</strong>：<code>config.yaml</code> 可以根据不同的部署环境（如开发、测试、生产等）提供不同的配置文件。例如，开发环境和生产环境可能使用不同的数据库配置或服务端口。</li><li><strong>易于切换</strong>：不同环境的配置文件可以在部署时灵活切换，帮助应用程序适应不同的运行环境。</li></ul><h4 id="4-解耦应用程序与配置："><a href="#4-解耦应用程序与配置：" class="headerlink" title="4. 解耦应用程序与配置："></a>4. <strong>解耦应用程序与配置</strong>：</h4><ul><li><strong>与源代码解耦</strong>：将配置从源代码中分离，使得开发人员无需修改代码或重新编译就可以改变程序的行为。例如，更改数据库连接或日志级别。</li></ul><h4 id="5-提高可维护性："><a href="#5-提高可维护性：" class="headerlink" title="5. 提高可维护性："></a>5. <strong>提高可维护性</strong>：</h4><ul><li><strong>简化管理</strong>：在应用程序的生命周期中，配置文件的修改频率通常远高于源代码的修改频率。通过集中管理配置，可以更容易地调整和维护系统。</li><li><strong>版本控制</strong>：<code>config.yaml</code> 可以纳入版本控制系统（如 Git），使得团队能够共享和管理配置变更。</li></ul><h4 id="6-支持动态配置更新："><a href="#6-支持动态配置更新：" class="headerlink" title="6. 支持动态配置更新："></a>6. <strong>支持动态配置更新</strong>：</h4><ul><li>配置文件可以支持动态加载和更新，某些配置管理工具（如 Consul 或 Etcd）可以通过 <code>config.yaml</code> 实现配置的动态更新，不需要停机或重启应用程序。</li></ul><h4 id="7-提高部署和调试效率："><a href="#7-提高部署和调试效率：" class="headerlink" title="7. 提高部署和调试效率："></a>7. <strong>提高部署和调试效率</strong>：</h4><ul><li>通过直接修改配置文件，开发和运维人员能够快速调整应用程序的参数（如服务端口、日志级别等），提高调试和部署的效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>config.yaml</code> 文件的核心作用是提供一个灵活、可管理、易于编辑的方式来配置应用程序的行为。它通过将配置信息与代码解耦，使得开发人员、运维人员能够在不修改源代码的情况下调整和管理应用程序配置，支持不同的环境和需求。</p>]]></content>
      
      
      <categories>
          
          <category> 后端项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> gin </tag>
            
            <tag> gorm </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（2）</title>
      <link href="/2024/11/28/mei-ri-xue-xi-2/"/>
      <url>/2024/11/28/mei-ri-xue-xi-2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="14-二叉树的所有路径"><a href="#14-二叉树的所有路径" class="headerlink" title="14. 二叉树的所有路径"></a>14. 二叉树的所有路径</h3><p>在go语言中，append相当于新开辟地址，如果里面是b &#x3D; append(b,…)这种，在递归中会回溯，只作用在当前函数，不会影响外部函数，外部原切片地址没有增加。使用*b时就会对原切片进行改变。</p><h3 id="15-左子树之和"><a href="#15-左子树之和" class="headerlink" title="15. 左子树之和"></a>15. 左子树之和</h3><p>递归遍历变式，相当于在递归遍历的基础上加上一些判断条件，这道题就是加入判断</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">root<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTP-1-1如何优化"><a href="#HTTP-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h3><p>三方面考虑：</p><ol><li>尽量避免发送HTTP请求</li><li>需要请求时，尽量少发</li><li>减少服务器HTTP响应</li></ol><h4 id="1-避免发送请求"><a href="#1-避免发送请求" class="headerlink" title="1. 避免发送请求"></a>1. 避免发送请求</h4><p>有一些对于请求重复数据的请求就可以存在本地的缓冲中，直接读取本地的数据就行。</p><p>需要<strong>缓存技术</strong>：</p><p>客户端将第一次请求和响应保存在本地磁盘，请求的URL作为key，响应作为value。并且为了防止响应的数据过期，服务器会发送一个估算的过期时间，过期就重新发起请求。</p><p>并且为了提高协议性能，客户端重新发起请求时在<strong>Etag</strong>头部带上第一次响应头部的摘要，让服务器对比本地资源的摘要。如果不同，返回新资源。如果相同，返回不包含体的304响应，让服务器继续使用缓存数据。</p><h4 id="2-减少HTTP请求次数"><a href="#2-减少HTTP请求次数" class="headerlink" title="2. 减少HTTP请求次数"></a>2. 减少HTTP请求次数</h4><ul><li>减少重定向请求次数</li><li>合并请求</li><li>延迟发送请求</li></ul><h5 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h5><p>重定向：当资源迁移时，资源从url1到url2。客户端不知道情况，就需要先发送请求到url1（302响应码），再发送请求到url2。</p><p>服务端一般不只一台，源服务器上一级为代理服务器。</p><p>客户端-&gt;代理服务器-&gt;原服务器</p><p>将重定向的工作交给代理服务器完成，就可以减少HTTP请求次数，并且代理服务器知晓重定向规则后，可以进一步减少消息传递次数。</p><p>注：可以看小林coding上面的图</p><h5 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h5><p>将资源合并，用一个大的资源请求获取多个小资源请求。比如需要请求多个图片，可以用技术把它们合并成一个图片，只需要一个请求就行了。</p><h5 id="延时发送请求"><a href="#延时发送请求" class="headerlink" title="延时发送请求"></a>延时发送请求</h5><p>按需获取方式，当前不需要的资源，就不提前请求。需要的时候再请求。比如网页资源。</p><h4 id="3-减少HTTP响应数据大小"><a href="#3-减少HTTP响应数据大小" class="headerlink" title="3. 减少HTTP响应数据大小"></a>3. 减少HTTP响应数据大小</h4><p>压缩：</p><ul><li>无损压缩：文本文件、程序可执行文件、源代码</li><li>有损压缩：音频、图片、视频等</li></ul><h2 id="Go-Vue通用后台管理"><a href="#Go-Vue通用后台管理" class="headerlink" title="Go-Vue通用后台管理"></a>Go-Vue通用后台管理</h2><h3 id="跨域中间件"><a href="#跨域中间件" class="headerlink" title="跨域中间件"></a>跨域中间件</h3><p>跨域就是允许客户端（浏览器）从一个域向另一个域的服务器发起跨域请求并成功接收响应。</p><p>因为前后端分离部署时，请求接口不同。比如：</p><p>前端运行在 <code>http://localhost:3000</code></p><p>后端运行在 <code>http://localhost:8080</code></p><p>跨域中间件相当于允许客户端在3000这个端口请求8000这个端口的响应</p><h4 id="跨域中间件通过HTTP响应头来实现"><a href="#跨域中间件通过HTTP响应头来实现" class="headerlink" title="跨域中间件通过HTTP响应头来实现"></a>跨域中间件通过HTTP响应头来实现</h4><ul><li><p>允许客户端安全地发起跨域请求。</p></li><li><p>响应浏览器的跨域策略检查。</p></li><li><p>提高开发效率，简化跨域相关配置。</p></li></ul><p>是前后端分离项目不可或缺的一部分</p><p>发送<code>OPPTIONS</code>请求，用于询问服务器是否允许跨域请求。</p><h3 id="鉴权中间件"><a href="#鉴权中间件" class="headerlink" title="鉴权中间件"></a>鉴权中间件</h3><ul><li><p><strong>鉴权中间件</strong> 是用来验证请求是否有有效的身份认证信息的中间件，通常用于保护需要身份认证的资源。</p></li><li><p>它在请求进入业务逻辑处理之前执行，确保只有通过认证的用户才能继续访问。</p></li><li><p>通过使用鉴权中间件，可以实现基于 Token（如 JWT）、Session 或 API Key 的认证方法。</p></li><li><p><strong>JWT</strong> 是现代 Web 应用中常用的鉴权机制，它通过在每个请求中携带 token 来进行身份验证。</p></li></ul><h3 id="config-yaml"><a href="#config-yaml" class="headerlink" title="config.yaml"></a>config.yaml</h3><p><code>config.yaml</code> 文件的主要作用是作为应用程序的配置文件，用于存储和管理应用的各种配置信息。它使得开发、运维人员可以灵活地调整应用程序的行为，而不需要修改源代码或重新编译程序。以下是 <code>config.yaml</code> 文件的作用总结：</p><h4 id="1-配置管理："><a href="#1-配置管理：" class="headerlink" title="1. 配置管理："></a>1. <strong>配置管理</strong>：</h4><ul><li><strong>集中管理配置</strong>：通过 <code>config.yaml</code> 文件，可以集中管理应用程序的配置信息，如数据库连接、服务器端口、API 密钥等。</li><li><strong>灵活调整</strong>：配置文件的修改不需要改变应用程序的代码，只需要修改配置文件即可改变应用行为。</li></ul><h4 id="2-人类可读："><a href="#2-人类可读：" class="headerlink" title="2. 人类可读："></a>2. <strong>人类可读</strong>：</h4><ul><li><strong>易于理解和编辑</strong>：YAML 格式比 JSON 更加简洁和易读，适合开发人员和运维人员编辑。配置项可以直观地表示应用程序的行为，如 <code>server.host</code>、<code>database.password</code> 等。</li></ul><h4 id="3-环境适配："><a href="#3-环境适配：" class="headerlink" title="3. 环境适配："></a>3. <strong>环境适配</strong>：</h4><ul><li><strong>支持不同环境的配置</strong>：<code>config.yaml</code> 可以根据不同的部署环境（如开发、测试、生产等）提供不同的配置文件。例如，开发环境和生产环境可能使用不同的数据库配置或服务端口。</li><li><strong>易于切换</strong>：不同环境的配置文件可以在部署时灵活切换，帮助应用程序适应不同的运行环境。</li></ul><h4 id="4-解耦应用程序与配置："><a href="#4-解耦应用程序与配置：" class="headerlink" title="4. 解耦应用程序与配置："></a>4. <strong>解耦应用程序与配置</strong>：</h4><ul><li><strong>与源代码解耦</strong>：将配置从源代码中分离，使得开发人员无需修改代码或重新编译就可以改变程序的行为。例如，更改数据库连接或日志级别。</li></ul><h4 id="5-提高可维护性："><a href="#5-提高可维护性：" class="headerlink" title="5. 提高可维护性："></a>5. <strong>提高可维护性</strong>：</h4><ul><li><strong>简化管理</strong>：在应用程序的生命周期中，配置文件的修改频率通常远高于源代码的修改频率。通过集中管理配置，可以更容易地调整和维护系统。</li><li><strong>版本控制</strong>：<code>config.yaml</code> 可以纳入版本控制系统（如 Git），使得团队能够共享和管理配置变更。</li></ul><h4 id="6-支持动态配置更新："><a href="#6-支持动态配置更新：" class="headerlink" title="6. 支持动态配置更新："></a>6. <strong>支持动态配置更新</strong>：</h4><ul><li>配置文件可以支持动态加载和更新，某些配置管理工具（如 Consul 或 Etcd）可以通过 <code>config.yaml</code> 实现配置的动态更新，不需要停机或重启应用程序。</li></ul><h4 id="7-提高部署和调试效率："><a href="#7-提高部署和调试效率：" class="headerlink" title="7. 提高部署和调试效率："></a>7. <strong>提高部署和调试效率</strong>：</h4><ul><li>通过直接修改配置文件，开发和运维人员能够快速调整应用程序的参数（如服务端口、日志级别等），提高调试和部署的效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>config.yaml</code> 文件的核心作用是提供一个灵活、可管理、易于编辑的方式来配置应用程序的行为。它通过将配置信息与代码解耦，使得开发人员、运维人员能够在不修改源代码的情况下调整和管理应用程序配置，支持不同的环境和需求。</p><h3 id="cors-go"><a href="#cors-go" class="headerlink" title="cors.go"></a>cors.go</h3><p> chatgpt说：<code>c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)</code>和<code>c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</code>不可同时存在。</p><h3 id="authMiddleware-go"><a href="#authMiddleware-go" class="headerlink" title="authMiddleware.go"></a>authMiddleware.go</h3><p><code>c.Abort()</code>：是用来终止当前请求的处理，并且阻止后续的中间件或处理函数继续执行。这个方法通常用于某些特殊场景，例如当请求没有通过鉴权或验证时，终止请求</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文方面</title>
      <link href="/2024/11/27/lun-wen-zhi-shi/"/>
      <url>/2024/11/27/lun-wen-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="论文知识"><a href="#论文知识" class="headerlink" title="论文知识"></a>论文知识</h1><h2 id="后门检测与消除"><a href="#后门检测与消除" class="headerlink" title="后门检测与消除"></a>后门检测与消除</h2><p><strong>后门检测</strong>是指在计算机系统、软件或网络中，检测是否存在被恶意植入的后门程序或漏洞的过程。</p><p><strong>后门消除</strong>是指采取措施来移除或修复被检测到的后门程序或漏洞，以确保系统的安全性。</p><h2 id="IID"><a href="#IID" class="headerlink" title="IID"></a><strong>IID</strong></h2><ul><li><strong>独立同分布（IID）</strong>表示数据样本是相互独立的，并且它们来自同一个概率分布。</li><li>在这种情况下，数据集中的每个样本都是随机采样的，且采样过程之间没有相互依赖性。例如，在图像分类任务中，每类图像样本的分布是均匀的，所有参与方的数据都能代表整体数据分布。</li><li>在联邦学习中，如果所有参与方的数据都是IID的，那么每个参与方的数据集都可以被看作是全局数据集的一个小规模但有代表性的样本。</li></ul><h2 id="Non-IID"><a href="#Non-IID" class="headerlink" title="Non-IID"></a><strong>Non-IID</strong></h2><ul><li><strong>非独立同分布（Non-IID）</strong>表示数据样本之间存在某种依赖关系或数据分布不均匀。</li><li>在这种情况下，不同参与方的数据集可能有不同的特征或分布。例如，在手写数字识别任务中，一个参与方的数据可能主要包含“0”和“1”，而另一个参与方的数据可能主要包含“8”和“9”。</li><li>Non-IID情况在联邦学习中非常常见，因为各个参与方的数据通常反映的是特定用户的行为或环境数据，数据分布自然会有所不同。</li></ul><h2 id="IID和Non-IID在联邦学习中的影响"><a href="#IID和Non-IID在联邦学习中的影响" class="headerlink" title="IID和Non-IID在联邦学习中的影响"></a><strong>IID和Non-IID在联邦学习中的影响</strong></h2><ul><li><strong>IID</strong>：有助于全局模型快速收敛，因为每个参与方的数据都能很好地代表整体数据分布。</li><li><strong>Non-IID</strong>：会导致模型训练的挑战，因为不同参与方的数据分布差异较大，模型在聚合时可能会难以找到一个统一的全局最优解。这种情况下，模型的性能可能会下降，并且训练过程可能变得不稳定。</li></ul><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><ul><li><strong>标签翻转（Label-flipping attack）</strong>：攻击者通过修改训练数据标签来误导模型训练。</li><li><strong>高斯攻击（Gaussian attack）</strong>：使用高斯分布扰动模型参数，使得模型表现异常。</li><li><strong>LIE攻击（LIE attack）</strong>：通过精确的扰动策略在不易察觉的范围内对模型施加破坏。</li><li><strong>缩放攻击（Scaling attack）</strong>：恶意调整客户端更新的缩放系数，影响全局模型。</li><li><strong>女巫攻击（Sybil attack）</strong>：通过创建多个虚假客户端来操控联邦学习过程。</li></ul><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降是一种优化算法，用于最小化机器学习模型的损失函数。它通过迭代调整模型参数（如权重），逐步接近损失函数的最小值。算法的核心思想是沿着损失函数的负梯度方向更新参数，使损失值逐渐降低。</p><h2 id="对抗模型（Adversarial-Model）"><a href="#对抗模型（Adversarial-Model）" class="headerlink" title="对抗模型（Adversarial Model）"></a>对抗模型（Adversarial Model）</h2><p>对抗模型（Adversarial Model）通常是指一种用于生成对抗性示例或进行对抗性攻击的机器学习模型。这些模型旨在找到或生成可以欺骗机器学习模型的输入，从而导致模型输出错误的结果。对抗模型在对抗性机器学习和生成对抗网络（GANs）中有重要的应用。</p><h3 id="1-对抗性示例（Adversarial-Examples）"><a href="#1-对抗性示例（Adversarial-Examples）" class="headerlink" title="1. 对抗性示例（Adversarial Examples）"></a>1. 对抗性示例（Adversarial Examples）</h3><p>对抗性示例是通过对输入数据进行细微的、有针对性的修改而生成的，它们可以误导模型做出错误的分类或预测。对抗性攻击利用这种示例来测试模型的鲁棒性和安全性。对抗模型用于生成这些示例，目的是找出使模型误判的输入。</p><h3 id="2-生成对抗网络（GAN）"><a href="#2-生成对抗网络（GAN）" class="headerlink" title="2. 生成对抗网络（GAN）"></a>2. 生成对抗网络（GAN）</h3><p>生成对抗网络是一种由两部分组成的深度学习模型：生成器（Generator）和判别器（Discriminator）。</p><ul><li><strong>生成器</strong>：试图生成逼真的数据，目的是欺骗判别器，使其无法分辨生成的数据和真实数据。</li><li><strong>判别器</strong>：用于区分生成的数据和真实数据。判别器的目标是提高辨别的准确性。</li></ul><p>在训练过程中，生成器和判别器相互对抗，不断改进，使生成器生成的数据越来越真实，而判别器的判断能力也越来越强。这种对抗训练提高了生成数据的质量，是GANs的核心思想。</p><p>对抗模型在提升机器学习模型的鲁棒性、改进数据生成技术和安全性测试等方面有广泛的应用。</p><h2 id="差分隐私（Differential-Privacy-DP）"><a href="#差分隐私（Differential-Privacy-DP）" class="headerlink" title="差分隐私（Differential Privacy, DP）"></a>差分隐私（Differential Privacy, DP）</h2><p>差分隐私是一种数据隐私保护技术，用于在数据分析或机器学习过程中保护个体数据的隐私。其核心思想是在数据分析的结果中引入随机噪声，以防止攻击者通过查询结果推断出单个数据记录的信息。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>差分隐私的基本定义是，如果对两个仅有一个记录不同的相邻数据集进行分析，其输出结果的分布应该非常相似。这意味着，即使数据集中添加或移除某个个体的数据记录，分析的结果仍然保持几乎不变，从而使得攻击者无法确定某个个体是否存在于数据集中。</p><h2 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a><strong>泛化能力</strong></h2><p>指的是机器学习模型在训练数据之外的<strong>新数据</strong>上表现良好的能力。</p><p><strong>Shamir秘密分享（Shamir’s Secret Sharing, SSS）</strong> 是一种加密技术，用于将一个秘密（如加密密钥）分成多个部分（称为“分享”），使得只有达到一定数量的分享（即阈值）时，才能够恢复原始的秘密。Shamir秘密分享方案基于多项式插值理论，广泛用于分布式系统、加密密钥管理和安全多方计算中，以保证数据的安全性和可靠性。</p><h2 id="Shamir秘密分享的基本原理"><a href="#Shamir秘密分享的基本原理" class="headerlink" title="Shamir秘密分享的基本原理"></a>Shamir秘密分享的基本原理</h2><p>Shamir秘密分享的关键在于利用多项式函数来生成和恢复分享。它具有以下特点：</p><ol><li><strong>秘密分割</strong>：将秘密表示为一个多项式函数的常数项，通过多项式的其他点来生成各个分享。</li><li><strong>阈值恢复</strong>：通过设定一个阈值 k，只有收集到至少 k个分享，才能通过多项式插值来重建原始秘密。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>假设要将一个秘密 s 分成 n 份，并设置阈值 k（即至少需要 k 个分享才能恢复秘密）。Shamir秘密分享的步骤如下：</p><ol><li><p><strong>生成多项式</strong>：</p><ul><li>$$<ul><li>随机生成一个最高次项为 k−1的多项式<br>f(x) &#x3D; a_0 + a_1 x + a_2 x^2 + \dots + a_{k-1}其中常数项a_0 &#x3D; s为秘密。</li><li>系数a_1, a_2, \dots, a_{k-1} 随机选取。<br>$$</li></ul></li></ul></li><li><p><strong>生成分享</strong>：</p><ul><li>$$<br>将 x 代入多项式f(x) 中，生成 n 个点 (x_1, f(x_1)), (x_2, f(x_2)), \dots, (x_n, f(x_n))，这些点就是分享。<br>$$</li></ul></li><li><p><strong>秘密恢复</strong>：</p><ul><li>收集至少 k 个分享后，通过<strong>拉格朗日插值</strong>法可以重构出多项式 f(x)f(x)f(x)，进而得到常数项 a_0，即秘密 s。</li><li>拉格朗日插值使用 k 个点即可精确确定一个 k−1 次多项式，因此在不满足阈值 k 的情况下，无法恢复秘密。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个秘密 s&#x3D;1234，希望将其分成 5 份（即 n&#x3D;5），并设定阈值为 3（即 k&#x3D;3）。</p><ol><li><p><strong>生成多项式</strong>：选择一个随机的二次多项式 f(x)&#x3D;1234+5x+3x2。</p></li><li><p><strong>生成分享</strong>：计算<br>$$<br>f(1), f(2), \dots, f(5)<br>$$<br>得到5个分享，如<br>$$<br>(1, 1242), (2, 1254), \dots, (5, 1314)<br>$$</p></li><li><p><strong>恢复秘密</strong>：任意三个分享点通过拉格朗日插值可以还原多项式 f(x)，进而得到常数项 1234，即秘密。</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>安全性</strong>：攻击者无法通过少量分享恢复秘密，保证了数据的安全。</li><li><strong>可靠性</strong>：即使部分分享丢失，只要达到阈值，秘密依然可以恢复。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>密钥管理</strong>：将加密密钥分成多份，由多个参与方持有，防止单点泄露。</li><li><strong>分布式系统</strong>：在分布式环境中保护数据的安全，如区块链中的密钥共享。</li><li><strong>安全多方计算（MPC）</strong>：用于在多方计算中保护隐私，使每方无法单独恢复计算数据。</li></ul><p>Shamir秘密分享是实现分布式数据安全的重要技术，尤其在隐私保护和分布式加密应用中广泛使用。</p><p><strong>加法秘密分享（Additive Secret Sharing）</strong> 是一种简单但有效的秘密共享方案，将一个秘密分成多个部分（称为“分享”），使得只有将所有分享相加才能恢复出原始秘密。加法秘密分享广泛用于多方计算和分布式系统中，以保证参与方在不泄露自己数据的情况下协同计算。</p><h2 id="加法秘密分享的基本原理"><a href="#加法秘密分享的基本原理" class="headerlink" title="加法秘密分享的基本原理"></a>加法秘密分享的基本原理</h2><p>假设有一个秘密 s，我们希望将其分成 n 份，以保证只有所有分享都被收集到时，才能恢复出秘密。加法秘密分享的基本步骤如下：</p><ol><li><p><strong>生成分享</strong>：</p><p>$$<br>随机生成n−1个分享，这些分享可以是任意数值，通常从有限域中随机选取。<br>$$</p><ul><li>第 n 个分享通过计算使得所有分享的和等于秘密 s。</li></ul><p>具体来说，假设要将秘密 s 分成 n 份：<br>$$<br>s_1, s_2, \dots, s_{n-1}<br>$$<br>是前 n−1个随机生成的分享，第 n个分享 s_n计算为：</p><p>$$<br>s_n &#x3D; s - (s_1 + s_2 + \dots + s_{n-1})<br>$$<br>这样，所有分享的和满足：</p><p>$$<br>s_ns&#x3D;s_1+s_2+⋯+s_n<br>$$</p></li><li><p><strong>恢复秘密</strong>：</p><ul><li>收集到所有的 n 个分享后，将其相加即可恢复原始秘密 s：</li></ul><p>$$<br>s_1 + s_2 + \dots + s_ns&#x3D;s1+s2+⋯+sn<br>$$</p><p>在此过程中，单独的分享没有泄露关于秘密 sss 的信息，因为每个分享都是随机的。</p></li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个秘密 s&#x3D;123，并希望将其分成 3 份，即 n&#x3D;3：</p><ol><li>随机生成前两个分享：假设<br>$$<br>s_1 &#x3D; 50，s_2 &#x3D; 30<br>$$<br>。</li><li>计算第三个分享<br>$$<br>s_3 &#x3D; 123 - (50 + 30) &#x3D; 43<br>$$</li></ol><p>  这样，我们得到了三个分享<br>$$<br>s_1 &#x3D; 50、s_2 &#x3D; 30、s_3 &#x3D; 43<br>$$<br>  只有当所有分享相加时才能恢复原始秘密：</p><p>$$<br>s&#x3D;50+30+43&#x3D;123<br>$$</p><h3 id="加法秘密分享的优点"><a href="#加法秘密分享的优点" class="headerlink" title="加法秘密分享的优点"></a>加法秘密分享的优点</h3><ul><li><strong>简单高效</strong>：加法秘密分享的生成和恢复操作非常简单，只涉及加法运算，适合有限计算资源的场景。</li><li><strong>无信息泄露</strong>：单个分享没有任何关于秘密的信息，只有所有分享组合在一起才能恢复秘密。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>安全多方计算（MPC）</strong>：在多方计算中使用加法秘密分享，使各方持有的分享共同计算结果而不泄露原始输入。</li><li><strong>分布式加密和密钥管理</strong>：将密钥分成多份存储在不同地方，保证只有全部分享才能恢复密钥。</li><li><strong>隐私保护机器学习</strong>：在机器学习的联邦学习中使用加法秘密分享分割模型参数或梯度信息，使各客户端保持数据隐私。</li></ol><p>加法秘密分享是一种简单但有效的数据分割技术，尤其适用于需要保护数据隐私的分布式计算和协作环境。</p><p><strong>安全多方计算（Secure Multi-Party Computation, MPC）</strong> 是一种密码学技术，使得多个参与方可以在<strong>不泄露各自私有数据</strong>的情况下，<strong>共同计算</strong>一个函数的结果。MPC确保每个参与方的输入在整个计算过程中都是私密的，其他参与方无法直接访问这些数据。计算完成后，所有参与方仅能得到最终的计算结果，而不会获知其他人的输入内容。</p><h2 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h2><h3 id="安全多方计算的基本原理"><a href="#安全多方计算的基本原理" class="headerlink" title="安全多方计算的基本原理"></a>安全多方计算的基本原理</h3><p>安全多方计算的核心思想是将每个参与方的私有输入<strong>加密或分割成多个部分</strong>（称为“分享”），这些分享在多个参与方之间传递，并用于计算。整个计算过程使用这些分享进行而不直接访问原始数据，从而保证数据隐私。</p><p>例如，假设有两个参与方希望计算彼此输入的总和，但不希望泄露各自的输入。安全多方计算可以让双方安全地计算出总和，而无需彼此交换原始数据。</p><h3 id="常用的MPC协议"><a href="#常用的MPC协议" class="headerlink" title="常用的MPC协议"></a>常用的MPC协议</h3><p>MPC协议有多种实现方式，常见的协议包括：</p><ol><li><strong>加法秘密分享</strong>：将每个参与方的输入分割成若干个随机分享，这些分享在多方之间传递，用于计算各自的子结果，最终合并得到完整结果。</li><li><strong>Shamir秘密共享</strong>：将数据分成多个份数，通过多项式插值的方法实现秘密共享。只需要满足一定的门限数量（如至少 t 份）就可以重构秘密。</li><li><strong>同态加密（Homomorphic Encryption）</strong>：使用同态加密技术，允许在密文状态下直接执行计算，计算完成后才解密，保证计算过程对各方不可见。</li><li><strong>混淆电路（Garbled Circuits）</strong>：将计算过程设计为布尔电路，使用加密方式混淆电路的内部信息，只有输出结果对参与方可见。</li></ol><h3 id="安全多方计算的工作流程"><a href="#安全多方计算的工作流程" class="headerlink" title="安全多方计算的工作流程"></a>安全多方计算的工作流程</h3><p>假设有两方（A和B）希望计算各自的输入数据之和，而不想暴露数据。MPC的流程可能如下：</p><ol><li><strong>数据分享</strong>：A和B将各自的输入分割成若干随机分享，并与对方交换这些分享。</li><li><strong>协同计算</strong>：A和B利用接收到的分享在本地计算各自的子结果。</li><li><strong>结果合并</strong>：将子结果组合后得到最终的结果（即A和B的输入之和），而不需要暴露彼此的原始输入。</li></ol><h3 id="优势与缺点"><a href="#优势与缺点" class="headerlink" title="优势与缺点"></a>优势与缺点</h3><ul><li><strong>优点</strong>：<ul><li><strong>隐私保护</strong>：各方输入数据保持私密，仅计算结果可见。</li><li><strong>去中心化</strong>：不需要信任的第三方，全体参与者共同完成计算。</li><li><strong>数据安全</strong>：即使有参与方恶意行为，也难以获取其他人的数据。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>计算复杂度高</strong>：MPC涉及复杂的加密和解密操作，计算效率较低。</li><li><strong>通信开销大</strong>：多次交换分享和中间结果，带来较高的通信成本。</li></ul></li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>隐私保护机器学习</strong>：在联邦学习和加密模型训练中，MPC可以用于安全地聚合各方的模型参数或梯度。</li><li><strong>金融数据分析</strong>：多方之间联合计算各自的金融数据指标，如信用评分、交易数据分析等，确保数据隐私。</li><li><strong>医疗数据分析</strong>：多家医疗机构可以在不交换患者数据的情况下进行联合分析，如疾病预测、药物试验数据统计等。</li><li><strong>电子投票系统</strong>：利用MPC确保投票的私密性，同时实现投票结果的透明统计。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全多方计算在数据隐私和多方协作场景中起到了关键作用，能够在保障数据安全和隐私的前提下完成联合计算，适用于金融、医疗、人工智能等对数据隐私要求严格的领域。</p><h2 id="对抗性攻击"><a href="#对抗性攻击" class="headerlink" title="对抗性攻击"></a>对抗性攻击</h2><h3 id="搭便车攻击"><a href="#搭便车攻击" class="headerlink" title="搭便车攻击"></a>搭便车攻击</h3><p>在计算环境中只训练少量的数据，以极少的资源消耗从全局模型中获取更大的利益</p><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><p>数据表示（Data Representation），在机器学习和深度学习中，是指将原始数据转换为一种结构化的形式，使其能够更好地被模型理解和利用。在模型训练中，数据表示通常以特征向量、嵌入（embedding）或更高级的特征形式出现，帮助模型从数据中提取出有用的信息，同时降低数据的维度或复杂性。</p><h2 id="向量内积、L2-范数、均值"><a href="#向量内积、L2-范数、均值" class="headerlink" title="向量内积、L2 范数、均值"></a>向量内积、L2 范数、均值</h2><p>在联邦学习（Federated Learning, FL）中，<strong>向量内积（Inner Product）</strong>、<strong>L2 范数（L2 Norm）</strong> 和 <strong>均值（Mean Value）</strong> 是模型聚合、鲁棒性分析和数据分布管理中的重要数学工具。它们通常用于以下场景：</p><hr><h3 id="1-向量内积（Inner-Product）"><a href="#1-向量内积（Inner-Product）" class="headerlink" title="1. 向量内积（Inner Product）"></a>1. <strong>向量内积（Inner Product）</strong></h3><p>向量内积主要用于评估两个向量之间的相似性，并在以下方面具有应用：</p><h4 id="1-1-计算相似性"><a href="#1-1-计算相似性" class="headerlink" title="1.1 计算相似性"></a><strong>1.1 计算相似性</strong></h4><ul><li><p>在鲁棒聚合规则（AGR）中，服务器通过计算客户端上传的模型更新（向量）与基准模型的内积，来评估两者的相似性或偏离程度。</p></li><li><p>相似性计算的指标包括：</p><ul><li><p><strong>余弦相似性（Cosine Similarity）</strong>：<br>$$<br>cos(a,b)&#x3D;⟨a,b⟩∥a∥∥b∥\text{cos}(a, b) &#x3D; \frac{\langle a, b \rangle}{|a| |b|}cos(a,b)&#x3D;∥a∥∥b∥⟨a,b⟩<br>$$</p></li><li><p><strong>欧几里得距离（Euclidean Distance）</strong>：<br>$$<br>∥a−b∥&#x3D;∥a∥2+∥b∥2−2⟨a,b⟩|a - b| &#x3D; \sqrt{|a|^2 + |b|^2 - 2 \langle a, b \rangle}∥a−b∥&#x3D;∥a∥2+∥b∥2−2⟨a,b⟩<br>$$</p></li></ul></li></ul><h4 id="1-2-过滤异常更新"><a href="#1-2-过滤异常更新" class="headerlink" title="1.2 过滤异常更新"></a><strong>1.2 过滤异常更新</strong></h4><ul><li>在防御恶意攻击（如中毒攻击、标注翻转攻击）时，服务器利用内积计算过滤掉偏离全局模型的异常更新，从而保护模型性能和完整性。</li></ul><h4 id="1-3-权重更新与聚合"><a href="#1-3-权重更新与聚合" class="headerlink" title="1.3 权重更新与聚合"></a><strong>1.3 权重更新与聚合</strong></h4><ul><li>内积计算可以用于动态调整客户端权重，将更高相似性的客户端更新赋予更大的权重，增强聚合的鲁棒性。</li></ul><hr><h3 id="2-L2-范数（L2-Norm）"><a href="#2-L2-范数（L2-Norm）" class="headerlink" title="2. L2 范数（L2 Norm）"></a>2. <strong>L2 范数（L2 Norm）</strong></h3><p>L2 范数衡量向量的长度，在以下场景中尤为关键：</p><h4 id="2-1-验证更新规范化"><a href="#2-1-验证更新规范化" class="headerlink" title="2.1 验证更新规范化"></a><strong>2.1 验证更新规范化</strong></h4><ul><li>在许多聚合规则中，要求客户端上传的模型更新具有统一的规范化形式（例如单位长度）。</li><li>通过 L2 范数校验，服务器可以过滤掉未规范化或恶意操纵的模型更新。</li></ul><h4 id="2-2-判定恶意更新"><a href="#2-2-判定恶意更新" class="headerlink" title="2.2 判定恶意更新"></a><strong>2.2 判定恶意更新</strong></h4><ul><li>某些攻击（如缩放攻击）可能通过放大或缩小模型更新的幅度来影响全局模型。服务器通过 L2 范数检测这些异常值，并将其排除在聚合过程中。</li></ul><h4 id="2-3-动态聚合"><a href="#2-3-动态聚合" class="headerlink" title="2.3 动态聚合"></a><strong>2.3 动态聚合</strong></h4><ul><li>服务器可以利用 L2 范数对客户端更新进行动态裁剪（clipping），防止过大的更新对全局模型造成负面影响。</li></ul><hr><h3 id="3-均值（Mean-Value）"><a href="#3-均值（Mean-Value）" class="headerlink" title="3. 均值（Mean Value）"></a>3. <strong>均值（Mean Value）</strong></h3><p>均值在聚合过程和鲁棒性分析中扮演了重要角色：</p><h4 id="3-1-模型更新的简单平均"><a href="#3-1-模型更新的简单平均" class="headerlink" title="3.1 模型更新的简单平均"></a><strong>3.1 模型更新的简单平均</strong></h4><ul><li>最经典的联邦学习算法 FedAvg 中，服务器计算所有客户端模型更新的简单平均：<br>$$<br>w(t+1)&#x3D;1N∑i&#x3D;1Nwi(t)w^{(t+1)} &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N w_i^{(t)}w(t+1)&#x3D;N1i&#x3D;1∑Nwi(t)<br>$$<br> 这种操作本质上是对模型参数的均值计算。</li></ul><h4 id="3-2-过滤异常更新"><a href="#3-2-过滤异常更新" class="headerlink" title="3.2 过滤异常更新"></a><strong>3.2 过滤异常更新</strong></h4><ul><li>在某些鲁棒 AGR（如 Trimmed Mean 和 Median）中，服务器对客户端上传的参数进行裁剪后，计算均值以减少异常值的影响。</li></ul><h4 id="3-3-数据分布估计"><a href="#3-3-数据分布估计" class="headerlink" title="3.3 数据分布估计"></a><strong>3.3 数据分布估计</strong></h4><ul><li>均值也用于分析客户端数据分布，帮助服务器了解数据是否均匀分布以及客户端是否存在非独立同分布（Non-IID）问题，从而调整聚合策略。</li></ul><hr><h3 id="文献中的具体应用"><a href="#文献中的具体应用" class="headerlink" title="文献中的具体应用"></a><strong>文献中的具体应用</strong></h3><p>在文献《AegisFL》中，这三个操作被用作设计和实现灵活聚合规则（AGR）的基础组件：</p><ol><li><strong>灵活性</strong>：通过计算内积、L2 范数和均值，AegisFL 能够支持多种聚合规则，如余弦相似性、欧几里得距离、皮尔逊相关系数等。</li><li><strong>鲁棒性</strong>：这些操作帮助服务器在加密态下评估客户端更新的质量，从而过滤恶意更新。</li><li><strong>高效性</strong>：利用特殊编码技术，这些计算能够在同态加密下以单次多项式运算完成，显著提高效率。</li></ol><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>向量内积</strong>：用于相似性度量和异常检测。</li><li><strong>L2 范数</strong>：用于更新规范化和攻击防御。</li><li><strong>均值</strong>：用于全局模型更新和数据分布分析。</li></ul><p>它们共同构成了联邦学习中鲁棒聚合和隐私保护的数学基础。</p><h1 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h1><h2 id="1-兼顾鲁棒性和隐私性的联邦学习研究"><a href="#1-兼顾鲁棒性和隐私性的联邦学习研究" class="headerlink" title="1.兼顾鲁棒性和隐私性的联邦学习研究"></a>1.兼顾鲁棒性和隐私性的联邦学习研究</h2><p>​鲁棒性与隐私性是联邦学习系统在实际应用中需要考虑的两个维度指标,两者缺一不可。然而鲁棒性提升与隐私性增强之间存在矛盾,例如很多隐私保护手段试图尽量减少不同用户梯度信息的差异,而这常常会阻碍一些鲁棒性提升方法对异常数据的识别。因此,如何处理这个矛盾是联邦学习在大规模应用之前面临的重要问题。</p><h2 id="2-权衡隐私保护的效率和模型的精度"><a href="#2-权衡隐私保护的效率和模型的精度" class="headerlink" title="2.权衡隐私保护的效率和模型的精度"></a>2.权衡隐私保护的效率和模型的精度</h2><h2 id="隐私威胁"><a href="#隐私威胁" class="headerlink" title="隐私威胁"></a>隐私威胁</h2><h3 id="1-恶意参与方获取隐私"><a href="#1-恶意参与方获取隐私" class="headerlink" title="1. 恶意参与方获取隐私"></a>1. 恶意参与方获取隐私</h3><h4 id="1-1-隐私推断攻击"><a href="#1-1-隐私推断攻击" class="headerlink" title="1.1 隐私推断攻击"></a>1.1 隐私推断攻击</h4><h4 id="1-2-提取重构攻击"><a href="#1-2-提取重构攻击" class="headerlink" title="1.2 提取重构攻击"></a>1.2 提取重构攻击</h4><h4 id="1-3-窃取反演攻击"><a href="#1-3-窃取反演攻击" class="headerlink" title="1.3 窃取反演攻击"></a>1.3 窃取反演攻击</h4><h4 id="1-4-参与方GAN攻击"><a href="#1-4-参与方GAN攻击" class="headerlink" title="1.4 参与方GAN攻击"></a>1.4 参与方GAN攻击</h4><h3 id="2-恶意中央服务器泄露"><a href="#2-恶意中央服务器泄露" class="headerlink" title="2. 恶意中央服务器泄露"></a>2. 恶意中央服务器泄露</h3><h4 id="2-1-服务器泄露隐私"><a href="#2-1-服务器泄露隐私" class="headerlink" title="2.1 服务器泄露隐私"></a>2.1 服务器泄露隐私</h4><h4 id="2-2-服务器GAN攻击"><a href="#2-2-服务器GAN攻击" class="headerlink" title="2.2 服务器GAN攻击"></a>2.2 服务器GAN攻击</h4><h3 id="3-恶意多方合谋获取隐私"><a href="#3-恶意多方合谋获取隐私" class="headerlink" title="3. 恶意多方合谋获取隐私"></a>3. 恶意多方合谋获取隐私</h3><h4 id="3-1-多参与方恶意合谋"><a href="#3-1-多参与方恶意合谋" class="headerlink" title="3.1 多参与方恶意合谋"></a>3.1 多参与方恶意合谋</h4><h4 id="3-2-参与方和中央服务器的恶意合谋"><a href="#3-2-参与方和中央服务器的恶意合谋" class="headerlink" title="3.2 参与方和中央服务器的恶意合谋"></a>3.2 参与方和中央服务器的恶意合谋</h4><h2 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h2><h3 id="1-差分隐私"><a href="#1-差分隐私" class="headerlink" title="1. 差分隐私"></a>1. 差分隐私</h3><h3 id="2-同态加密"><a href="#2-同态加密" class="headerlink" title="2. 同态加密"></a>2. 同态加密</h3><h3 id="3-安全多方计算"><a href="#3-安全多方计算" class="headerlink" title="3. 安全多方计算"></a>3. 安全多方计算</h3><h3 id="4-对抗性训练"><a href="#4-对抗性训练" class="headerlink" title="4. 对抗性训练"></a>4. 对抗性训练</h3><h3 id="5-模型压缩"><a href="#5-模型压缩" class="headerlink" title="5. 模型压缩"></a>5. 模型压缩</h3><h1 id="国内外期刊会议"><a href="#国内外期刊会议" class="headerlink" title="国内外期刊会议"></a>国内外期刊会议</h1><h2 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h2><ol><li><p>‌**[IEEE Transactions on Knowledge and Data Engineering (TKDE)](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=IEEE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=IEEE</a> Transactions on Knowledge and Data Engineering (TKDE)&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：该期刊涵盖计算机科学、人工智能、电气工程等领域的知识和数据工程，影响因子为8.9，审稿速度较快，平均4个月，录用难度较大‌1。</p></li><li><p>‌**<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Neurocomputing&rsv_pq=bfc3e01700ddd81f&oq=%E5%9B%BD%E5%86%85%E5%A4%96%E8%AE%A4%E5%8F%AF%E5%BA%A6%E9%AB%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E6%9C%9F%E5%88%8A%E4%BC%9A%E8%AE%AE&rsv_t=3e05TA2Dx/55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&tn=baiduhome_pg&ie=utf-8">Neurocomputing</a>**‌：主要发表神经计算领域的文章，影响因子为5.5，审稿速度较快，接收后5天内即可发表‌1。</p></li><li><p>‌**[Expert Systems with Applications](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Expert">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=Expert</a> Systems with Applications&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：专注于专家系统和智能系统的设计、开发、测试等，影响因子为7.5，审稿速度较快‌1。</p></li><li><p>‌**[IEEE Access](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=IEEE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=IEEE</a> Access&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：涵盖计算机科学与工程等多个学科，影响因子为3.4，审稿周期较短，录用率较高‌2。</p></li><li><p>‌**[Pattern Recognition Letters](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Pattern">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=Pattern</a> Recognition Letters&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：专注于模式识别领域，影响因子为3.9，适合计算机视觉和AI领域的学者‌2。</p></li><li><p>‌**[Journal of Artificial Intelligence Research](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Journal">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=Journal</a> of Artificial Intelligence Research&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：涵盖AI领域的广泛内容，影响因子为4.5，录用率较高‌2。</p></li><li><p>‌**[International Journal of Computer Vision](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=International">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=International</a> Journal of Computer Vision&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：计算机视觉领域的顶级期刊，影响因子为11.6，录用率较低但影响力高‌2。</p></li><li><p>‌**[ACM Transactions on Graphics](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=ACM">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=ACM</a> Transactions on Graphics&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：图形学和视觉计算领域的顶级期刊，影响因子为7.8，录用率较低但质量高‌2。</p></li><li><p>Data Science and Engineering</p><p>主编：Bin Cui,Timos<br>Sellis主办单位：中国计算机学会(CCF)ISSN：2364-1185创刊时间：2015年05月出版周期：季刊</p></li><li><p>CCF Transactions on Pervasive Computing and Interaction</p><p>主编：Zhiwen Yu,Anind Dey主办单位：中国计算机学会(CCF)ISSN：2524-521X出版周期：季刊</p></li><li><p>CCF Transactions on High Performance Computing</p><p>主编：Depei Qian,Dhabaleswar K. Panda主办单位：中国计算机学会(CCF)ISSN：2524-4930出版周期：季刊</p></li><li><p>Journal of Computer Science and Technology</p><p>主编：Zhi-Wei Xu主办单位：中国科学院计算技术研究所ISSN：1000-9000CN：11-2296&#x2F;TP出版周期：双月刊</p></li><li><p>计算机技术与发展</p><p>主编：陈锐主办单位：中国计算机学会微机专业委员会;陕西省计算机学会</p></li><li><p>数据与计算发展前沿</p><p>主编：钱德沛主管单位：中国科学院主办单位：中国科学院计算机网络信息中心;中国科技出版传媒股份有限公司</p></li><li><p>计算机工程</p><p>主编：江波主管单位：中国电子科技集团公司主办单位：华东计算技术研究所;上海市计算机学会ISSN：1000-33428CN：31-1289&#x2F;TP创刊时间：1975年出版周期：月刊</p></li><li><p>计算机应用研究</p><p>主编：刘营主管单位：四川省科技厅主办单位：四川省计算机研究院ISSN：1001-3695CN：51-1196&#x2F;TP创刊时间：1984年出版周期：月刊</p></li></ol><h2 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h2><ol><li>‌**[第三届IEEE云计算、大数据应用与软件工程国际学术会议 (CBASE 2024)](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E7%AC%AC%E4%B8%89%E5%B1%8AIEEE%E4%BA%91%E8%AE%A1%E7%AE%97%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=第三届IEEE云计算、大数据应用与软件工程国际学术会议</a> (CBASE 2024)&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：会议时间为2024年10月18-20日，地点在中国杭州。征稿主题包括云计算、物联网、AI、大数据的应用、数据分析与挖掘、机器学习等‌3。</li><li>‌**[第五届人工智能与计算工程国际学术会议 (ICAICE 2024)](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E7%AC%AC%E4%BA%94%E5%B1%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%B7%A5%E7%A8%8B%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=第五届人工智能与计算工程国际学术会议</a> (ICAICE 2024)&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：会议时间为2024年11月8-10日，地点在中国芜湖。征稿主题包括人工智能应用与技术、机器学习、计算机视觉等‌3。</li><li>‌**<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE&rsv_pq=bfc3e01700ddd81f&oq=%E5%9B%BD%E5%86%85%E5%A4%96%E8%AE%A4%E5%8F%AF%E5%BA%A6%E9%AB%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E6%9C%9F%E5%88%8A%E4%BC%9A%E8%AE%AE&rsv_t=3e05TA2Dx/55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&tn=baiduhome_pg&ie=utf-8">第二届数学与机器学习国际学术会议</a>**‌：虽然未提供具体时间信息，但该会议由南京大学主办，征稿主题涉及数学与机器学习领域‌3。</li></ol><p>这些期刊和会议在计算机领域具有较高的认可度和影响力，适合不同研究方向的学者投稿和参加。</p><p><a href="https://github.com/wei-d-zhang/ASAFL">https://github.com/wei-d-zhang/ASAFL</a> </p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 联邦学习 </tag>
            
            <tag> 会议期刊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/11/27/suan-fa/"/>
      <url>/2024/11/27/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="树的迭代遍历"><a href="#树的迭代遍历" class="headerlink" title="树的迭代遍历"></a>树的迭代遍历</h3><h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    ans <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> ans<span class="token punctuation">&#125;</span>st <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token keyword">for</span> st<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">:=</span> st<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">Back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    ans <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> ans<span class="token punctuation">&#125;</span>st <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token keyword">for</span> st<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">:=</span> st<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">Back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span>    <span class="token keyword">return</span> ans<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">reverse</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    l<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">for</span> l <span class="token operator">&lt;</span> r <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    ans <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ans    <span class="token punctuation">&#125;</span>    st <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    cur <span class="token operator">:=</span> root    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> st<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">Back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>Val<span class="token punctuation">)</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Right        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>”空间换时间“</p><h4 id="1-穷举法（dfs暴力）"><a href="#1-穷举法（dfs暴力）" class="headerlink" title="1.穷举法（dfs暴力）"></a>1.穷举法（dfs暴力）</h4><p>类似                                                                                                                                    ·· </p><h4 id="2-记忆化搜索（递归）"><a href="#2-记忆化搜索（递归）" class="headerlink" title="2.记忆化搜索（递归）"></a>2.记忆化搜索（递归）</h4><p>记忆化搜索 &#x3D; 暴力dfs+记录答案</p><h4 id="3-迭代形式（递推dp）"><a href="#3-迭代形式（递推dp）" class="headerlink" title="3.迭代形式（递推dp）"></a>3.迭代形式（递推dp）</h4><p>递推 &#x3D; dfs向下递归的公式</p><p>递推数组的初始值 &#x3D; 递归的边界</p><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><h5 id="1-暴力搜索"><a href="#1-暴力搜索" class="headerlink" title="1.暴力搜索"></a>1.暴力搜索</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：暴力搜索 */</span><span class="token keyword">func</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> c <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若超过背包容量，则只能选择不放入背包</span>    <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算不放入和放入物品 i 的最大价值</span>    no <span class="token operator">:=</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    yes <span class="token operator">:=</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment">// 返回两种方案中价值更大的那一个</span>    <span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2.记忆化搜索"></a>2.记忆化搜索</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：记忆化搜索 */</span><span class="token keyword">func</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> mem <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> c <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若已有记录，则直接返回</span>    <span class="token keyword">if</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若超过背包容量，则只能选择不放入背包</span>    <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算不放入和放入物品 i 的最大价值</span>    no <span class="token operator">:=</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    yes <span class="token operator">:=</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment">// 返回两种方案中价值更大的那一个</span>    mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：动态规划 */</span><span class="token keyword">func</span> <span class="token function">knapsackDP</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过背包容量，则不选物品 i</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-空间优化"><a href="#4-空间优化" class="headerlink" title="4.空间优化"></a>4.空间优化</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：空间优化后的动态规划 */</span><span class="token keyword">func</span> <span class="token function">knapsackDPComp</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 倒序遍历</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> c<span class="token operator">--</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h5><h5 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">unboundedKnapsackDP</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过背包容量，则不选物品 i</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">unboundedKnapsackDPComp</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过背包容量，则不选物品 i</span>                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多重背包</strong></p><h4 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h4><h5 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChangeDP</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>    max <span class="token operator">:=</span> amt <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移：首行首列</span>    <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> max    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移：其余行和列</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过目标金额，则不选硬币 i</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选硬币 i 这两种方案的较小值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amt<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amt<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="优化空间-1"><a href="#优化空间-1" class="headerlink" title="优化空间"></a>优化空间</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChangeDPComp</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>    max <span class="token operator">:=</span> amt <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 正序遍历</span>        <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过目标金额，则不选硬币 i</span>                dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选硬币 i 这两种方案的较小值</span>                dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>a<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>amt<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amt<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="零钱兑换问题-II"><a href="#零钱兑换问题-II" class="headerlink" title="零钱兑换问题 II"></a>零钱兑换问题 II</h4><h5 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChangeIIDP</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt <span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> amt <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amt<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="优化空间-2"><a href="#优化空间-2" class="headerlink" title="优化空间"></a>优化空间</h5><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><strong>leetcode：</strong></p><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><p><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><h2 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>不用哈希表的算法</p><p>用<strong>双指针法</strong>：</p><p>首先对数组进行排序，方便后续指针操作 </p><p>a + b + c &#x3D; 0 （大小顺序从左向右依次增大）</p><p>i指向a，l指向b，r指向c</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">如果一开始 a <span class="token operator">></span> <span class="token number">0</span>，则可以退出了i去重：判断nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">></span> <span class="token number">0</span>，r<span class="token operator">--</span><span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token keyword">else</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">==</span> <span class="token number">0</span> 时，先收集数组<span class="token punctuation">,</span>然后对bc进行去重<span class="token keyword">for</span> r <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> l<span class="token operator">++</span><span class="token keyword">for</span> r <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> r<span class="token operator">--</span>l<span class="token operator">++</span>r<span class="token operator">--</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>同上</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词"></a>反转字符串里的单词</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">例如：  输入：s <span class="token operator">=</span> <span class="token string">"the sky is blue"</span>输出：<span class="token string">"blue is sky the"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>运用两次反转：第一次整体反转，第二次对每个单词进行反转。</li><li>删除多余空格，每个单词之间只保留一个，用双指针法（快慢指针进行处理 既：覆盖）</li></ol><h4 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h4><h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>前缀：不包含尾字母的字串</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">aabaaf的前缀<span class="token punctuation">:</span>aaaaabaabaaabaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后缀：不包含首字母的字串</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">aabaaf的后缀<span class="token punctuation">:</span>fafaafbaafabaaf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长相等前后缀长度（即模式串的前缀表）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token number">0</span>aa<span class="token number">1</span>aab<span class="token number">0</span>aaba<span class="token number">1</span>aabaa<span class="token number">2</span>aabaaf<span class="token number">0</span>前缀表为：<span class="token number">010120</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般用next数组存前缀表</p><p>注： 代码待定</p><h4 id="重复字串"><a href="#重复字串" class="headerlink" title="重复字串"></a>重复字串</h4><p>注：需要学习KMP算法</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="2-用栈实现队列"><a href="#2-用栈实现队列" class="headerlink" title="2. 用栈实现队列"></a>2. 用栈实现队列</h4><p>两个栈实现正确顺序，注意的是In栈将全部数据传入Out栈后，当Out栈的数据没pop完，就可以直接对O栈进行处理。push正常传入In栈就行了，等Out栈里面没有了再将In栈里面的全部传入Out栈，并且pop完In栈里面的。</p><h4 id="3-用队列实现栈"><a href="#3-用队列实现栈" class="headerlink" title="3. 用队列实现栈"></a>3. 用队列实现栈</h4><p>两个队列，一个来放，另一个复制除了最后一个元素的所有元素，然后再将另一个复制回原来的队列，再将复制队列置空。</p><h4 id="7-滑动窗口最大值"><a href="#7-滑动窗口最大值" class="headerlink" title="7. 滑动窗口最大值"></a>7. 滑动窗口最大值</h4><p>双端队列（从左到右依次减小的单调性）</p><p>队列存的是索引，方便判断头队列是否出队。</p><ol><li>入队：保证单调性，只有比最左边小的才入队，比最左边大的要把最左边的剔除出去，直到比最左边小或者队列为空。</li><li>出队：当（头队列的索引-当前的i） &gt;&#x3D; k了，就要出队，因为已经超过窗口了</li><li>收集：只有i &gt;&#x3D; k-1时才收集，此时才满足一个窗口。</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="递归三部曲"><a href="#递归三部曲" class="headerlink" title="递归三部曲"></a>递归三部曲</h4><ol><li>确定函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><h4 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h4><ul><li><p>前序：<strong>中</strong>左右</p></li><li><p>中序：左<strong>中</strong>右</p></li><li><p>后序：左<strong>右</strong>中</p></li></ul><h4 id="5-层序遍历"><a href="#5-层序遍历" class="headerlink" title="5. 层序遍历"></a>5. 层序遍历</h4><h5 id="102-层序遍历I"><a href="#102-层序遍历I" class="headerlink" title="102. 层序遍历I"></a>102. 层序遍历I</h5><p>使用队列，循环判断为队列长度是否大于0，使用切片来作为队列。有两种处理方式：</p><ol><li>每一个新创建一个队列，然后将弹出的树的左右子树加入队列</li><li>将弹出树的左右子树加入原来队列，再进行切片操作[len(原长):]</li></ol><p>注意：一开始要判断root是否为nil</p><h5 id="107-层序遍历II"><a href="#107-层序遍历II" class="headerlink" title="107. 层序遍历II"></a>107. 层序遍历II</h5><p>同上，只是最后的数组进行反转。（go二维数组反转和一维一样的操作）</p><h5 id="199-右视图"><a href="#199-右视图" class="headerlink" title="199. 右视图"></a>199. 右视图</h5><p>判断层序遍历是否达到该层最后一个，是就加入res</p><h4 id="8-对称二叉树"><a href="#8-对称二叉树" class="headerlink" title="8. 对称二叉树"></a>8. 对称二叉树</h4><p>左右子树反转完全相等就是对称，左边顺序为中左右，右边顺序为中右左。</p><h4 id="12-平衡二叉树"><a href="#12-平衡二叉树" class="headerlink" title="12. 平衡二叉树"></a>12. 平衡二叉树</h4><p>递归三部曲：</p><ol><li>确定参数和返回值</li><li>确定终止条件</li><li>确定单层递归逻辑</li></ol><p>1.参数为节点，返回值为以该节点为根节点的树的高度（不是平衡二叉树返回-1）</p><p>2.空节点就终止</p><p>3.左子树高度，右子树高度，相差是否&lt;&#x3D;1</p><h4 id="14-二叉树的所有路径"><a href="#14-二叉树的所有路径" class="headerlink" title="14. 二叉树的所有路径"></a>14. 二叉树的所有路径</h4><p>在go语言中，append相当于新开辟地址，如果里面是b &#x3D; append(b,…)这种，在递归中会回溯，只作用在当前函数，不会影响外部函数，外部原切片地址没有增加。使用*b时就会对原切片进行改变。</p><h4 id="15-左子树之和"><a href="#15-左子树之和" class="headerlink" title="15. 左子树之和"></a>15. 左子树之和</h4><p>递归遍历变式，相当于在递归遍历的基础上加上一些判断条件，这道题就是加入判断</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">root<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="16-找树左下角的值"><a href="#16-找树左下角的值" class="headerlink" title="16. 找树左下角的值"></a>16. 找树左下角的值</h4><p>先找出最大深度，再左边。可以先dfs，再用队列</p><h4 id="17-路径总和"><a href="#17-路径总和" class="headerlink" title="17. 路径总和"></a>17. 路径总和</h4><p>同15一样，遍历基础上加判断条件</p><h4 id="18-从中序和后序遍历序列构造二叉树"><a href="#18-从中序和后序遍历序列构造二叉树" class="headerlink" title="18. 从中序和后序遍历序列构造二叉树"></a>18. 从中序和后序遍历序列构造二叉树</h4><p>主要是用到后序遍历的那个数组，用来找到根节点。然后通过中序遍历的那个数组找到根节点位置与左右子树他们的范围长度。并且用<code>map</code>存中序数组的位置，供每次遍历的时候找到根节点和左右子树。重点其实就是划分子树长度、应该怎么取端点位置。然后就按照基础的遍历顺序来遍历</p><h4 id="19-最大二叉树"><a href="#19-最大二叉树" class="headerlink" title="19. 最大二叉树"></a>19. 最大二叉树</h4><p>18题会了，19题就会。19比18简单，因为更好划分。</p><h4 id="21-合并二叉树"><a href="#21-合并二叉树" class="headerlink" title="21. 合并二叉树"></a>21. 合并二叉树</h4><p>两棵树跟着一起遍历，左对左，右对右。依旧是递归遍历为基础，加上变式。</p><h4 id="22-二叉搜索树的搜索"><a href="#22-二叉搜索树的搜索" class="headerlink" title="22. 二叉搜索树的搜索"></a>22. 二叉搜索树的搜索</h4><p>根据值的大小来选择往左还是往右遍历</p><h4 id="23-验证二叉搜索树"><a href="#23-验证二叉搜索树" class="headerlink" title="23. 验证二叉搜索树"></a>23. 验证二叉搜索树</h4><p>先用中序递归遍历收集值，再判断是否为二叉搜索树（单调递增就是）</p><h4 id="24-二叉搜索树的最小绝对差"><a href="#24-二叉搜索树的最小绝对差" class="headerlink" title="24. 二叉搜索树的最小绝对差"></a>24. 二叉搜索树的最小绝对差</h4><p>一样中序递归收集值，再左右相减比较最小的差值就行</p><h4 id="25-二叉搜索树中的众数"><a href="#25-二叉搜索树中的众数" class="headerlink" title="25. 二叉搜索树中的众数"></a>25. 二叉搜索树中的众数</h4><p>中序递归收集值，再用map存，再选出最多的append到res里面 </p><h4 id="26-二叉树就的最近公共祖先"><a href="#26-二叉树就的最近公共祖先" class="headerlink" title="26. 二叉树就的最近公共祖先"></a>26. 二叉树就的最近公共祖先</h4><p>只要找到有p、q就往上返回，相当于回溯（从下往上回），然后判断左右子树是不是不为空，不为空就是最近公共祖先。这个过程包括了p或q本身为公共祖先，因为最终返回的结果只有一个。</p><h4 id="28-二叉搜索树的最近公共祖先"><a href="#28-二叉搜索树的最近公共祖先" class="headerlink" title="28. 二叉搜索树的最近公共祖先"></a>28. 二叉搜索树的最近公共祖先</h4><p>找到第一个在p、q集合里面的就行（包括两端点）</p><h4 id="29-二叉搜索树的插入操作"><a href="#29-二叉搜索树的插入操作" class="headerlink" title="29. 二叉搜索树的插入操作"></a>29. 二叉搜索树的插入操作</h4><p>记住递归三部曲，然后往里面套。一直往下走，直到为空，就可以将节点插入。</p><h4 id="30-删除二叉搜索树中的节点"><a href="#30-删除二叉搜索树中的节点" class="headerlink" title="30. 删除二叉搜索树中的节点"></a>30. 删除二叉搜索树中的节点</h4><p>要用left &#x3D; ….，right&#x3D;….，并且对要删除的节点分情况：</p><ul><li>左右都为空（叶子节点）<ul><li>返回nil</li></ul></li><li>左不为空，右为空<ul><li>返回左子树</li></ul></li><li>左为空，右不为空<ul><li>返回右子树</li></ul></li><li>左右都不为空（最复杂）<ul><li>将左子树移动到右子树最左边，返回右子树</li></ul></li></ul><h4 id="31-修剪二叉搜索树"><a href="#31-修剪二叉搜索树" class="headerlink" title="31. 修剪二叉搜索树"></a>31. 修剪二叉搜索树</h4><ul><li>最搞笑的一题，莫名其妙就做出来了</li></ul><p>就是仿上一题，将所有不满足的节点都删掉。</p><h4 id="32-将有序数组转换为二叉搜索树（平衡二叉树）"><a href="#32-将有序数组转换为二叉搜索树（平衡二叉树）" class="headerlink" title="32. 将有序数组转换为二叉搜索树（平衡二叉树）"></a>32. 将有序数组转换为二叉搜索树（平衡二叉树）</h4><p>要将数组一直划分成两份，就像搜索树左右大小不同一样，也是越往下越是划分左右大小。</p><p>三部曲中：</p><ul><li>判断终止条件为nums为空</li></ul><h4 id="33-把二叉搜索树转换为累加树"><a href="#33-把二叉搜索树转换为累加树" class="headerlink" title="33. 把二叉搜索树转换为累加树"></a>33. 把二叉搜索树转换为累加树</h4><ul><li>使用右中左递归顺序，来依次累加。</li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul><li><p>回溯和递归是相辅相成的</p></li><li><p>纯暴力搜索</p><ul><li>组合问题（组合是无序的）</li><li>切割问题</li><li>子集问题</li><li>排列问题（强调顺序）</li><li>棋盘问题</li></ul></li><li><p>抽象为树形结构（n叉树）   </p></li><li><p>模板</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        存放结果<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        处理节点<span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>        回溯，撤销处理结果    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>剪枝优化：替换for循环里面小于等于的那个数</p></li></ul><h4 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2. 组合问题"></a>2. 组合问题</h4><ul><li>使用模板就可解题，回溯相当于n层for循环，只是在最开始的if判断就是终止条件。</li></ul><h4 id="4-组合总和III"><a href="#4-组合总和III" class="headerlink" title="4. 组合总和III"></a>4. 组合总和III</h4><ul><li>模板解题</li></ul><h4 id="5-电话号码的字母组合"><a href="#5-电话号码的字母组合" class="headerlink" title="5. 电话号码的字母组合"></a>5. 电话号码的字母组合</h4><ul><li>模板解题，注意string-&gt;[]byte</li></ul><h4 id="7-组合总和"><a href="#7-组合总和" class="headerlink" title="7. 组合总和"></a>7. 组合总和</h4><ul><li>保证无重复的数组：需要有<code>start</code>，并且<code>start=i</code></li></ul><h4 id="8-组合总和II"><a href="#8-组合总和II" class="headerlink" title="8. 组合总和II"></a>8. 组合总和II</h4><ul><li>重点是去重（同层的重复去掉）</li></ul><h4 id="9-分割回文串"><a href="#9-分割回文串" class="headerlink" title="9. 分割回文串"></a>9. 分割回文串</h4><p>和组合类似，但是记住是<strong>分割</strong>。重点是</p><ul><li>划分字串判断回文：<code>str = s[start:i+1]</code></li><li>终止条件：<code>start = len(s)</code></li></ul><h4 id="10-复原IP地址"><a href="#10-复原IP地址" class="headerlink" title="10. 复原IP地址"></a>10. 复原IP地址</h4><ul><li>和9很类似，只是注意终止条件多加一个<code>len(path) == 4</code></li></ul><h4 id="11-子集问题"><a href="#11-子集问题" class="headerlink" title="11. 子集问题"></a>11. 子集问题</h4><ul><li>注意：<code>  res := [][]int&#123;&#123;&#125;&#125;</code>才是添加一个空的</li></ul><h4 id="13-子集II"><a href="#13-子集II" class="headerlink" title="13. 子集II"></a>13. 子集II</h4><ul><li>和组合总和II一样的套路</li></ul><h4 id="14-递增子序列"><a href="#14-递增子序列" class="headerlink" title="14. 递增子序列"></a>14. 递增子序列</h4><p>重点是去重：因为不能排序，使用<code>  used := make(map[int]bool)</code>来判断是否使用了</p><h4 id="15-全排列"><a href="#15-全排列" class="headerlink" title="15. 全排列"></a>15. 全排列</h4><p>用一个数组来判断是否已经取了元素used[i]</p><h4 id="16-全排列"><a href="#16-全排列" class="headerlink" title="16. 全排列"></a>16. 全排列</h4><ul><li>在15的基础上加上每一层的去重。</li></ul><h4 id="21-N皇后"><a href="#21-N皇后" class="headerlink" title="21. N皇后"></a>21. N皇后</h4><ul><li>先创一个空的棋盘，再判断某一行。</li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li>局部最优推全局最优</li><li>要么很难要么很简单</li><li>贪心没套路</li></ul><h4 id="2-分发饼干"><a href="#2-分发饼干" class="headerlink" title="2. 分发饼干"></a>2. 分发饼干</h4><ul><li>排序再匹配</li></ul><h4 id="3-摆动序列"><a href="#3-摆动序列" class="headerlink" title="3. 摆动序列"></a>3. 摆动序列</h4><p>最好是画图来判断，注意还有平坡状态。因为可以删，所以至少都有一个数字。</p><h4 id="4-最大子序和"><a href="#4-最大子序和" class="headerlink" title="4. 最大子序和"></a>4. 最大子序和</h4><p>只要连续和小于0就抛弃重新开始，同时会存max来判断大小。</p><h4 id="6-买卖股票的最佳时机II"><a href="#6-买卖股票的最佳时机II" class="headerlink" title="6. 买卖股票的最佳时机II"></a>6. 买卖股票的最佳时机II</h4><p>只收集每天正利润就行</p><h4 id="7-跳跃游戏"><a href="#7-跳跃游戏" class="headerlink" title="7. 跳跃游戏"></a>7. 跳跃游戏</h4><p>不关注具体跳几步，从头找覆盖范围，只要能覆盖就证明能到</p><h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><p>动规基础</p><ul><li>斐波那契数列</li><li>爬楼梯</li></ul></li><li><p>背包问题</p></li><li><p>打家劫舍</p></li><li><p>股票问题</p></li><li><p>子序列问题</p></li></ul><hr><ol><li>dp数组以及下标的含义</li><li>递推公式</li><li>dp数组如何初始化</li><li>遍历顺序</li><li>打印dp数组</li></ol><h4 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2. 斐波那契数列"></a>2. 斐波那契数列</h4><h4 id="3-爬楼梯"><a href="#3-爬楼梯" class="headerlink" title="3. 爬楼梯"></a>3. 爬楼梯</h4><h4 id="4-使用最小花费爬楼梯"><a href="#4-使用最小花费爬楼梯" class="headerlink" title="4. 使用最小花费爬楼梯"></a>4. 使用最小花费爬楼梯</h4><h4 id="6-不同路径"><a href="#6-不同路径" class="headerlink" title="6. 不同路径"></a>6. 不同路径</h4><h4 id="7-不同路径II"><a href="#7-不同路径II" class="headerlink" title="7. 不同路径II"></a>7. 不同路径II</h4><ul><li>上面都是二刷</li></ul><h4 id="8-整数拆分"><a href="#8-整数拆分" class="headerlink" title="8. 整数拆分"></a>8. 整数拆分</h4><ul><li>定义dp[i]，含义为i拆分的最大值</li><li>拆分数字，可以分为拆分成两个和多个：<ul><li>两个时：<code>i*j</code></li><li>多个时：<code>j*dp[i-j]</code></li><li>公式为：<code>dp[i] = max(max(j*(i-j), j*dp[i-j]), dp[i])</code></li></ul></li><li>初始化时，<code>dp[0] = 0, dp[1] = 0, dp[2] = 1</code></li></ul><h4 id="9-不同的二叉搜索树"><a href="#9-不同的二叉搜索树" class="headerlink" title="9. 不同的二叉搜索树"></a>9. 不同的二叉搜索树</h4><ul><li>观察1个节点时有一种，2个节点时有两种</li><li>三个节点时：<ul><li>头节点为1时，左子树0个节点，右子树两个节点</li><li>头节点为2时，左子树一个节点，右子树一个节点</li><li>头节点为3时，左子树两个节点，右子树一个节点</li><li>可以模拟为<code>dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0] </code></li></ul></li><li>所以定义dp[i]，含义为i个节点的二叉搜索树的种树</li><li>在i个节点中，当j作为头节点时<ul><li>左子树为j-1个节点，右子树为i-j个节点</li><li><code>dp[i] += dp[j-1]*dp[i-j]</code></li></ul></li><li>初始化为dp[0] &#x3D; 1, dp[1] &#x3D; 1, dp[2] &#x3D; 2<ul><li>其实只用初始化dp[0]就行</li></ul></li></ul><h4 id="13-分割等和子集"><a href="#13-分割等和子集" class="headerlink" title="13. 分割等和子集"></a>13. 分割等和子集</h4><ul><li><p>相当于从背包里面选择出的物品重量为<code>sum/2</code>，且最大价值为<code>sum/2</code>。因为价值和重量都是<code>nums[i]</code>,选择出重量为<code>sum/2</code>时，价值最大只能为<code>sum/2</code></p></li><li><p>定义dp[i]，i重量的最大价值为dp[i]</p></li><li><p>公式：<code>dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</code></p></li><li><p>初始化为dp[0] &#x3D; 0</p></li><li><p>循环：<code>for i := 0; i &lt; len(nums); i++ &#123;</code></p><p>​    <code>for j := target; j &gt;= nums[i]; j-- &#123;</code></p><p>​<code> &#125;</code></p><p>​<code>   &#125;</code></p></li><li><p>打印 <code>dp[target] == target</code></p></li></ul><h4 id="14-最后一块石头重量II"><a href="#14-最后一块石头重量II" class="headerlink" title="14. 最后一块石头重量II"></a>14. 最后一块石头重量II</h4><ul><li>把石头分成重量差不多的两堆，相减的结果就是最小重量</li><li>和分割等和子集类似，也是求<code>dp[sum/2]</code>，只是打印的是时候是<code>sum-2*dp[target]</code></li></ul><h4 id="16-目标和"><a href="#16-目标和" class="headerlink" title="16. 目标和"></a>16. 目标和</h4><ul><li>目标和相当于求<strong>组合问题</strong>，他的重点在于<strong>是加不是max</strong>，<code>dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</code></li><li>组合问题就是加</li></ul><h4 id="17-一和零"><a href="#17-一和零" class="headerlink" title="17. 一和零"></a>17. 一和零</h4><ul><li>先考虑三维数组，代码随想录B站上面讲解的是滚动二维数组</li><li><code>dp[i][j][k]</code>，i代表前i个数，j、k分别表示0和1的个数</li><li>其余就同二维数组一样了</li></ul><h4 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h4><p>纯完全背包：物品和背包的遍历顺序可以颠倒</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token builtin">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token builtin">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> bagWeight<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>01背包：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// weight数组的大小 就是物品个数</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> bagweight<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="19-零钱兑换ll"><a href="#19-零钱兑换ll" class="headerlink" title="19. 零钱兑换ll"></a>19. 零钱兑换ll</h4><ul><li><p>这也是一个组合类问题，记住是<strong>＋</strong></p></li><li><p>注意<code>dp[0][0]=1</code></p></li><li><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p></li></ul><h4 id="总结：dp-0-0-的初始化规则"><a href="#总结：dp-0-0-的初始化规则" class="headerlink" title="总结：dp[0][0] 的初始化规则"></a><strong>总结：<code>dp[0][0]</code> 的初始化规则</strong></h4><table><thead><tr><th><strong>场景</strong></th><th><strong>初始值</strong></th><th><strong>适用问题</strong></th></tr></thead><tbody><tr><td>允许不选任何元素</td><td><code>1</code></td><td>组合问题、子集划分问题</td></tr><tr><td>必须选至少一个元素</td><td><code>0</code></td><td>完全背包（物品必须选）、最长公共子序列（LCS）</td></tr><tr><td>根据问题边界条件调整</td><td>灵活调整</td><td>网格路径、最大子集等</td></tr></tbody></table><h4 id="21-组合问题IV"><a href="#21-组合问题IV" class="headerlink" title="21. 组合问题IV"></a>21. 组合问题IV</h4><ul><li><p>难！</p></li><li><p>把这道题换成爬楼梯模型</p><ul><li><pre><code class="go">    for j := 0; j &lt;= target; j++ &#123; // 背包（楼梯总台阶）        for i := 1; i &lt;= n; i++ &#123; // 第i阶            if j &gt;= nums[i-1] &#123;                dp[j] += dp[j-nums[i-1]]            &#125;         &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">  + 假如&#96;dp[j]&#x3D;10&#96;，意思就是爬到10楼可以怎么爬，可以是从一楼直接到十楼，二楼直接到十楼，三楼直接到十楼……  + 所以就是&#96;dp[10] &#x3D;dp[10] + dp[9] + dp[8] + dp[7] ……&#96;  + 并且&#96;dp[i]&#96;为爬到i楼的所有方法，所以就相当于排序了#### 22. 爬楼梯（进阶版）+ 和上一道题一样的#### 23. 零钱兑换+ 除了&#96;dp[0][0]&#x3D;0&#96;,其他初始化全部为无穷大&#96;dp[i][j]&#x3D;amout+1&#96;#### 24. 完全平方数和23一个类型#### 26. 单词拆分+ 排序就想到爬楼梯（有序）+ 可以把他转化为排成字符串S有多少种方法，如果&#96;dp[i] &gt; 0&#96;，则证明能够拼成+ &#96;dp[i] &#x3D; 1&#96;+ 重点：&#96;&#96;&#96;goif len(wordDict[j]) &lt;&#x3D; i &amp;&amp; s[i-len(wordDict[j]):i] &#x3D;&#x3D; wordDict[j] &#123;                dp[i] +&#x3D; dp[i-len(wordDict[j])]            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul></li></ul><h4 id="29-打家劫舍I"><a href="#29-打家劫舍I" class="headerlink" title="29. 打家劫舍I"></a>29. 打家劫舍I</h4><ul><li><code>dp[i]</code>含义为考虑i以内（包括i）的房屋，最多可以偷窃的金额</li><li><code>dp[i]=max(dp[i-1], dp[i-2]+nums[i])</code></li></ul><h4 id="30-打家劫舍II"><a href="#30-打家劫舍II" class="headerlink" title="30. 打家劫舍II"></a>30. 打家劫舍II</h4><ul><li>第一家和最后一家只能选一个</li><li>所以分开求只选第一家的集合以及只选最后一家的集合</li><li>然后取最大值</li></ul><h4 id="31-打家劫舍III"><a href="#31-打家劫舍III" class="headerlink" title="31. 打家劫舍III"></a>31. 打家劫舍III</h4><ul><li><p>树形DP，重要的是遍历</p></li><li><pre><code class="go">func dfs(node *TreeNode) (int, int) &#123;    if node == nil &#123;        return 0, 0    &#125;    lrob, lno_rob := dfs(node.Left)    rrob, rno_rob := dfs(node.Right)    rob := lno_rob + rno_rob + node.Val    no_rob := max(lrob, lno_rob) + max(rrob, rno_rob)    return rob, no_rob&#125;<pre class="line-numbers language-none"><code class="language-none">  #### 32. 买卖股票的最佳时机+ &#96;dp[i][0]&#96;表示第i天持有股票所得最多现金+ &#96;dp[i][1]&#96;表示第i天不持有股票所得最多现金#### 34. 买卖股票的最佳时机II+ 和上个的区别是&#96;dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1]-prices[i-1]) &#96;#### 35. 买卖股票的最佳时机III+ 定义如下：+ &#96;&#96;&#96;go  dp[i][0]不操作  dp[i][1]第一次持有  dp[i][2]第一次卖出  dp[i][3]第二次持有  dp[i][4]第二次卖出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p>公式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="36-买卖股票的最佳时机IV"><a href="#36-买卖股票的最佳时机IV" class="headerlink" title="36. 买卖股票的最佳时机IV"></a>36. 买卖股票的最佳时机IV</h4><ul><li>和上面大致相同</li><li>只是需要找一个循环来进行公式</li></ul><h4 id="37-买卖股票的最佳时机含冷冻期"><a href="#37-买卖股票的最佳时机含冷冻期" class="headerlink" title="37. 买卖股票的最佳时机含冷冻期"></a>37. 买卖股票的最佳时机含冷冻期</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 不操作</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//持有</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//卖出</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//冷冻</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="39-买卖股票的最佳时机含手续费"><a href="#39-买卖股票的最佳时机含手续费" class="headerlink" title="39.  买卖股票的最佳时机含手续费"></a>39.  买卖股票的最佳时机含手续费</h4><ul><li><p>和买卖股票的最佳时机I和II一样，都是两个状态</p></li><li><p><code>dp[i][0]</code>表示第i天持有股票所得最多现金</p></li><li><p><code>dp[i][1]</code>表示第i天不持有股票所得最多现金</p></li></ul><h4 id="41-最长上升子序列"><a href="#41-最长上升子序列" class="headerlink" title="41. 最长上升子序列"></a>41. 最长上升子序列</h4><ul><li><code>dp[i]</code>以i为结尾的最长连续递增序列长度为<code>dp[i]</code></li></ul><h4 id="42-最长连续递增序列"><a href="#42-最长连续递增序列" class="headerlink" title="42. 最长连续递增序列"></a>42. 最长连续递增序列</h4><ul><li><code>dp[i]</code>以i为结尾的最长连续递增序列长度为<code>dp[i]</code></li></ul><h4 id="43-最长重复子数组"><a href="#43-最长重复子数组" class="headerlink" title="43. 最长重复子数组"></a>43. 最长重复子数组</h4><ul><li><code>dp[i][j]定义：以i结尾的nums1和以j结尾的nums2的最长子数组</code></li></ul><h4 id="44-最长公共子序列"><a href="#44-最长公共子序列" class="headerlink" title="44. 最长公共子序列"></a>44. 最长公共子序列</h4><ul><li><p><code>dp[i][j]定义：以i结尾的nums1和以j结尾的nums2的最公共子序列</code></p></li><li><p>公式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> text1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>   p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>   dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>return[i][j]</code></p></li></ul><h4 id="45-不相交的线"><a href="#45-不相交的线" class="headerlink" title="45. 不相交的线"></a>45. 不相交的线</h4><ul><li>就是找相同子序列</li></ul><h4 id="46-最大子序列和-最大子数组和"><a href="#46-最大子序列和-最大子数组和" class="headerlink" title="46. 最大子序列和(最大子数组和)"></a>46. 最大子序列和(最大子数组和)</h4><ul><li><code>    dp[i] = max(dp[i-1]+nums[i-1], nums[i-1])</code>   </li><li><code>return res</code></li></ul><h4 id="47-判断子序列"><a href="#47-判断子序列" class="headerlink" title="47. 判断子序列"></a>47. 判断子序列</h4><ul><li><code>dp[i][j]</code>表示以i结尾的字符串s，以j结尾的字符串t的最长公共子序列长度</li></ul><h4 id="48-不同的子序列"><a href="#48-不同的子序列" class="headerlink" title="48. 不同的子序列"></a>48. 不同的子序列</h4><ul><li><p>为编辑距离做准备</p></li><li><p><code>dp[i][j]</code>表示以<code>i</code>为结尾的<code>s</code>子序列中出现以<code>j</code>为结尾的<code>t</code>的个数为<code>dp[i][j]</code></p></li><li><pre><code class="go"> if s[i-1] == t[j-1] &#123;   dp[i][j] = dp[i-1][j-1]+dp[i-1][j]   &#125; else &#123;   dp[i][j] = dp[i-1][j]   &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">  #### 49. 两个字符串的删除操作+ 为编辑距离做准备+ &#96;dp[i][j]&#96;表示以&#96;i&#96;为结尾的&#96;word1&#96;和以&#96;j&#96;结尾的&#96;word2&#96;为相同所需要的最小操作次数+ &#96;&#96;&#96;go  if word1[i-1] &#x3D;&#x3D; word2[j-1] &#123;      dp[i][j] &#x3D; dp[i-1][j-1]  &#125; else &#123;      dp[i][j] &#x3D; min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+2)  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p><code>return dp[m][n]</code></p></li></ul><h4 id="50-编辑距离"><a href="#50-编辑距离" class="headerlink" title="50. 编辑距离"></a>50. 编辑距离</h4><ul><li><code>dp[i][j]</code>表示以<code>i</code>为结尾的<code>word1</code>和以<code>j</code>结尾的<code>word2</code>为相同所需要的最小操作次数</li><li></li></ul><h4 id="52-回文子串"><a href="#52-回文子串" class="headerlink" title="52. 回文子串"></a>52. 回文子串</h4><ul><li><p><code>dp[i][j]</code>表示[i,j]子串是否是回文子串</p></li><li><pre><code class="go">for i := n; i &gt;= 1; i-- &#123;    for j := i; j &lt;= n; j++ &#123;        if s[i-1] == s[j-1] &#123;            if j-i &lt;= 1 &#123;                dp[i][j] = true                res++            &#125; else &#123;                if dp[i+1][j-1] == true &#123;                    dp[i][j] = true                    res++                &#125;            &#125;        &#125;    &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">#### 53. 最长回文子序列+ &#96;dp[i][j]&#96;表示&#96;[i, j]&#96;的回文子序列长度+ &#96;&#96;&#96;go  for i :&#x3D; n; i &gt;&#x3D; 1; i-- &#123;      for j :&#x3D; i+1; j &lt;&#x3D; n; j++ &#123;          if s[i-1] &#x3D;&#x3D; s[j-1] &#123;              dp[i][j] &#x3D; dp[i+1][j-1] + 2          &#125; else &#123;              dp[i][j] &#x3D; max(dp[i+1][j], dp[i][j-1])          &#125;      &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p><code>dp[i][i] = 1 </code></p></li></ul><h2 id="Hot100"><a href="#Hot100" class="headerlink" title="Hot100"></a>Hot100</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><ul><li>注意<code>if i, ok :=  m[v]; ok &#123;&#125;</code></li></ul><h3 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2. 字母异位词分组"></a>2. 字母异位词分组</h3><ul><li><p>字符串想要排序需要转化为切片再排序</p><ul><li><pre><code class="go"> // 将字符串转换为字符切片    runes := []rune(s)    // 对字符切片进行排序    sort.Slice(runes, func(i, j int) bool &#123;        return runes[i] &lt; runes[j]   // 升序    &#125;)    // 将排序后的字符切片转换回字符串    return string(runes)<pre class="line-numbers language-none"><code class="language-none">+ 字符串数组可以直接用&#96;sort.Strings()&#96;（升序）### 3. 最长连续序列✔### 4. 移动零✔### 5. 盛最多的水+ 双指针法&#96;(i,j)&#96;+ 直接考虑数组，比如&#96;[1, 8, 6, 2, 5, 4, 8, 3, 7]&#96;更加直观+ 最大容量为：&#96;min(height[i],height[j])*(j-i)&#96;,初始&#96;i&#x3D;0，j&#x3D;len(height)-1&#96;每次移动较小的指针所指的指，保证移动过程为中高度至少在上升。### 6. 三数之和用**双指针法**：首先对数组进行排序，方便后续指针操作 a + b + c &#x3D; 0 （大小顺序从左向右依次增大）i指向a，l指向b，r指向c&#96;&#96;&#96;go如果一开始 a &gt; 0，则可以退出了i去重：判断nums[i] &#x3D;&#x3D; nums[i-1]if a + b + c &gt; 0，r--else if a + b + c &lt; 0, l++else a + b + c &#x3D;&#x3D; 0 时，先收集数组,然后对bc进行去重for r &gt; l &amp;&amp; nums[l] &#x3D;&#x3D; nums[l+1] l++for r &gt; l &amp;&amp; nums[r] &#x3D;&#x3D; nums[r-1] r--l++r--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul></li></ul><h3 id="7-接雨水"><a href="#7-接雨水" class="headerlink" title="7. 接雨水"></a>7. 接雨水</h3><ul><li>将每一格看成一个筒，用最长前后缀数组来表示筒两边的高度</li><li>每一格可以收集的就是<code>min(pre[i], suf[i])-height[i]</code></li></ul><h3 id="8-无重复首字符的最长字串"><a href="#8-无重复首字符的最长字串" class="headerlink" title="8. 无重复首字符的最长字串"></a>8. 无重复首字符的最长字串</h3><ul><li>滑动窗口，当有重复元素出现时，重点是让左边的指针一直移动到没有重复的元素为止。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>    m<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span>    <span class="token keyword">for</span> m<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>        m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span>        j<span class="token operator">++</span>    <span class="token punctuation">&#125;</span>    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-找到字符串所有字母异位词"><a href="#9-找到字符串所有字母异位词" class="headerlink" title="9. 找到字符串所有字母异位词"></a>9. 找到字符串所有字母异位词</h3><ul><li>用滑动窗口</li><li>用一个数组来记录字符串p各个元素的个数；另一个数组来记录窗口中各个元素的个数。同时设置一个变量<code>left</code>来记录滑动窗口最左边值。</li><li>如果两个数组相等则记录<code>left</code>值，不相等窗口左移（窗口中最左边的值减1）</li></ul><h3 id="10-和为K的数组"><a href="#10-和为K的数组" class="headerlink" title="10. 和为K的数组"></a>10. 和为K的数组</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// subarraySum 函数用于统计数组中和为 k 的子数组的个数</span><span class="token keyword">func</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token comment">// 初始化前缀和计数，前缀和为 0 的情况出现 1 次</span>prefixSumCount <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>prefixSumCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token comment">// 当前的前缀和</span>prefixSum <span class="token operator">:=</span> <span class="token number">0</span><span class="token comment">// 满足条件的子数组个数</span>count <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">&#123;</span><span class="token comment">// 计算当前的前缀和</span>prefixSum <span class="token operator">+=</span> num<span class="token comment">// 检查是否存在前缀和为 prefixSum - k 的情况</span><span class="token keyword">if</span> val<span class="token punctuation">,</span> ok <span class="token operator">:=</span> prefixSumCount<span class="token punctuation">[</span>prefixSum<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>count <span class="token operator">+=</span> val<span class="token punctuation">&#125;</span><span class="token comment">// 更新当前前缀和的计数</span>prefixSumCount<span class="token punctuation">[</span>prefixSum<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> count<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-滑动窗口最大值"><a href="#11-滑动窗口最大值" class="headerlink" title="11. 滑动窗口最大值"></a>11. 滑动窗口最大值</h3><ul><li>用一个队头到队尾单调递减的队列来实现</li></ul><h3 id="22-相交链表"><a href="#22-相交链表" class="headerlink" title="22. 相交链表"></a>22. 相交链表</h3><ul><li>两个链表同时走，当为<code>nil</code>时，走向另一个链表的对头，然后将会直到找到相同的节点或者同时为nil</li></ul><h3 id="23-反转链表"><a href="#23-反转链表" class="headerlink" title="23. 反转链表"></a>23. 反转链表</h3><ul><li>设计一个<code>var pre *ListNode</code></li></ul><h3 id="24-回文链表"><a href="#24-回文链表" class="headerlink" title="24. 回文链表"></a>24. 回文链表</h3><ul><li>使用寻找中点的方法<ul><li><code>fast,  slow</code>指针</li></ul></li><li>然后将后半段进行反转</li><li>最后进行对比</li></ul><h3 id="25-环形链表I"><a href="#25-环形链表I" class="headerlink" title="25. 环形链表I"></a>25. 环形链表I</h3><p>z&#96;</p><h3 id="26-环形链表II"><a href="#26-环形链表II" class="headerlink" title="26. 环形链表II"></a>26. 环形链表II</h3><h3 id="27-合并两个有序链表"><a href="#27-合并两个有序链表" class="headerlink" title="27. 合并两个有序链表"></a>27. 合并两个有序链表</h3><h3 id="28-合并两个有序链表"><a href="#28-合并两个有序链表" class="headerlink" title="28. 合并两个有序链表"></a>28. 合并两个有序链表</h3><h3 id="29-两数相加"><a href="#29-两数相加" class="headerlink" title="29. 两数相加"></a>29. 两数相加</h3><h3 id="30-删除链表的倒数第N个节点"><a href="#30-删除链表的倒数第N个节点" class="headerlink" title="30. 删除链表的倒数第N个节点"></a>30. 删除链表的倒数第N个节点</h3><h3 id="31-两两交换链表中的节点"><a href="#31-两两交换链表中的节点" class="headerlink" title="31. 两两交换链表中的节点"></a>31. 两两交换链表中的节点</h3><h3 id="32-K个一组反转链表"><a href="#32-K个一组反转链表" class="headerlink" title="32. K个一组反转链表"></a>32. K个一组反转链表</h3><h3 id="34-二叉树的中序遍历"><a href="#34-二叉树的中序遍历" class="headerlink" title="34. 二叉树的中序遍历"></a>34. 二叉树的中序遍历</h3><h4 id="递归三部曲-1"><a href="#递归三部曲-1" class="headerlink" title="递归三部曲"></a>递归三部曲</h4><ol><li>确定函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><h3 id="35-翻转二叉树"><a href="#35-翻转二叉树" class="headerlink" title="35.翻转二叉树"></a>35.翻转二叉树</h3><h3 id="36-对称二叉树"><a href="#36-对称二叉树" class="headerlink" title="36. 对称二叉树"></a>36. 对称二叉树</h3><h3 id="37-对称二叉树"><a href="#37-对称二叉树" class="headerlink" title="37. 对称二叉树"></a>37. 对称二叉树</h3><h3 id="38-二叉树的直径"><a href="#38-二叉树的直径" class="headerlink" title="38. 二叉树的直径"></a>38. 二叉树的直径</h3><p>​</p><h3 id="39-二叉树的层序遍历"><a href="#39-二叉树的层序遍历" class="headerlink" title="39. 二叉树的层序遍历"></a>39. 二叉树的层序遍历</h3><h3 id="40-将有序数组转换为二叉搜索树"><a href="#40-将有序数组转换为二叉搜索树" class="headerlink" title="40. 将有序数组转换为二叉搜索树"></a>40. 将有序数组转换为二叉搜索树</h3><h3 id="41-验证二叉搜索树"><a href="#41-验证二叉搜索树" class="headerlink" title="41. 验证二叉搜索树"></a>41. 验证二叉搜索树</h3><h3 id="42-二叉搜索树中第-K-小的元素"><a href="#42-二叉搜索树中第-K-小的元素" class="headerlink" title="42. 二叉搜索树中第 K 小的元素"></a>42. 二叉搜索树中第 K 小的元素</h3><h3 id="43-二叉树的右视图"><a href="#43-二叉树的右视图" class="headerlink" title="43. 二叉树的右视图"></a>43. 二叉树的右视图</h3><h3 id="44-二叉树展开为链表"><a href="#44-二叉树展开为链表" class="headerlink" title="44. 二叉树展开为链表"></a>44. 二叉树展开为链表</h3><h3 id="45-从前序与中序遍历序列构造二叉树"><a href="#45-从前序与中序遍历序列构造二叉树" class="headerlink" title="45. 从前序与中序遍历序列构造二叉树"></a>45. 从前序与中序遍历序列构造二叉树</h3><h3 id="46-路径总和-III"><a href="#46-路径总和-III" class="headerlink" title="46. 路径总和 III"></a>46. 路径总和 III</h3><h3 id="47-二叉树的最近公共祖先"><a href="#47-二叉树的最近公共祖先" class="headerlink" title="47. 二叉树的最近公共祖先"></a>47. 二叉树的最近公共祖先</h3><ul><li>回溯方法</li><li>要用后序遍历（cong</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/11/27/ji-suan-ji-wang-luo/"/>
      <url>/2024/11/27/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="输入网址后，到页面显示发生了什么"><a href="#输入网址后，到页面显示发生了什么" class="headerlink" title="输入网址后，到页面显示发生了什么"></a>输入网址后，到页面显示发生了什么</h3><p>（1）浏览器进行<strong>解析URL</strong>，<strong>生成</strong>发送给Web服务器的<strong>HTTP请求信息</strong></p><p>（2）查找<strong>服务器域名</strong>对应IP地址，进行DNS域名解析（浏览器缓存-&gt;操作系统缓存-&gt;hosts文件-&gt;本地DNS服务器；本地会从高问到底：根DNS-&gt;顶级域DNS-&gt;权威DNS）</p><p>（3）HTTP传输工作交给协议栈</p><p>（4）在传输层：建立TCP连接，封装TCP头部，生成TCP报文</p><p>（5）在网络层：添加IP头部，里面包括源IP和目标IP，生成IP数据报</p><p>（6）在数据链路层：添加MAC头部，里面包括源MAC地址和目标MAC地址，生成MAC帧</p><p>（7）网络包是一串二进制数字信息，需要在网卡上将数字信号转化为电信号，通过网线进行发送</p><p>（8）数据到达交换机，将电信号转化为数字信号进行包末尾的<code>FCS</code>校验，并通过查找MAC地址表转发到相应端口</p><p>（9）到达路由器，将电信号转化为数字信号进行包末尾的<code>FCS</code>校验，去掉MAC帧，通过目标IP查询路由表，确定下一跳地址；然后重新封装MAC头部，发送数据，直到达到服务器所在网络</p><p>（10）到达目标服务器，进行逐层的解封装，做出响应。</p><p>（11）客户端接收到相应后，解析到只剩HTTP响应报文，交给浏览器进行渲染，页面就显示出来了</p><h2 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h2><h3 id="HTTP常见面试题"><a href="#HTTP常见面试题" class="headerlink" title="HTTP常见面试题"></a>HTTP常见面试题</h3><h4 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h4><h5 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h5><p>HTTP是超文本传输协议</p><p>具体而言：HTTP是一个在计算机世界里专门在<strong>两点</strong>之间<strong>传输</strong>文字、图片、音频、视频等<strong>超文本</strong>数据的<strong>约定和规范</strong>。</p><h5 id="HTTP常见的状态码"><a href="#HTTP常见的状态码" class="headerlink" title="HTTP常见的状态码"></a>HTTP常见的状态码</h5><p><code>1xx</code>：提示信息，属于处理协议的中间状态</p><p><code>2xx</code>：表示服务器成功处理客户端请求</p><ul><li>200：表示一切正常</li><li>204：和200基本一致，响应头没有body数据</li><li>206：表示相应的数据不是全部，只是一部分（分块下载、断点续传）</li></ul><p><code>3xx</code>：表示请求资源发生变动，需要重定向到新的URL</p><ul><li>301：永久重定向</li><li>302：临时重定向</li><li>304：资源未改变，只是重定向到新的缓存文件</li></ul><p><code>4xx</code>：客户端报文有误，服务器无法处理</p><ul><li>400：客户端报文有误，但只是一个笼统的错误</li><li>403：服务器禁止访问资源，客户端请求没出错</li><li>404：资源在客户端没有或者没找到</li></ul><p><code>5xx</code>：服务器处理时内部发生错误</p><ul><li>500：笼统的错误</li><li>501：客户端请求的功能还不支持</li><li>502：服务器作为网关或者代理时发生的错误码，自身工作正常，访问后端服务器发生错误</li><li>503：服务器忙，暂时无法响应客户端</li></ul><h4 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h4><p>通过SSL&#x2F;TLS协议建立，也就是TLS握手阶段</p><p><strong>TLS四次通信</strong></p><p>第一次：客户端发送:（1）支持的TLS版本（2）生成的随机数（3）支持的加密算法。</p><p>第二次：服务端发送:（1）确认TLS版本（不持支关闭加密通信）（2）生成的随机数（3）确认支持的加密算法（4）数字证书</p><p>第三次：客户端发送:（1）将更改通信加密方式（2）发送一个随机数（3）握手结束通知，发送之前内容总结，供校验</p><p>第四次：服务端发送:（1)确认更改（2）握手结束通知，发送总结，供校验</p><p>在第二次的时候会进行服务器的数字证书验证：</p><p>计算证书内容hash值，使用CA提供的公钥（通常浏览器和操作系统集成了CA公钥）对CA的签名进行解密，对比hash值是否相同，相同即证明可信赖。</p><p>其中-通过这三个随机数生成了最终的<strong>会话密钥</strong>（对称加密）</p><p>证书验证过程通常存在<strong>证书信任链问题</strong>：</p><p>如根证书-&gt;中间证书-&gt;百度证书三级</p><p>一般用根证书的公钥去验证中间证书是否可信，再通过中间证书的公钥验证百度证书是否可信。</p><h4 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h4><p>TLS实现包括<strong>握手协议</strong>和<strong>记录协议</strong>两个两层</p><p>握手就是四次通信过程，记录协议就是保护数据并对完整性和来源进行验证（加密就在这里实现）</p><p>记录协议过程：</p><p>（1）消息切片、压缩</p><p>（2）每个片段加上消息认证码（MAC值，hash算法生成）保证完整性和可靠性。</p><p>（3）加密每一个片段</p><p>（4）加密数据加上数据类型、版本号、压缩后的长度作为报头形成报文</p><h4 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h4><h5 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能</h5><p>（1）使用长连接</p><p>（2）支持管道网络传输（请求发出去不必等返回就可再发送请求）</p><h5 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h5><p>HTTP&#x2F;2是基于https</p><p>（1）压缩头部：用索引号代替重复字段</p><p>（2）二进制格式：head和body都变成二进制（帧frame）</p><p>（3）并发传输：同一个tcp连接传多个stream（多个头＋体），即并行交错进行请求和响应，避免响应的队头阻塞</p><p>（4）服务器推送：服务器主动发送信息给客户端</p><h5 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h5><p>将TCP协议变成UDP协议，并且使用基于UDP的QUIC协议</p><p>QUIC特点</p><ul><li>无队头堵塞（stream丢包，只堵塞这个流，不像HTTP&#x2F;2堵塞TCP整个队头）</li><li>更快的连接方式（HTTP&#x2F;2先TCP握手，再TLS握手；HTTP&#x2F;3，QUIC握手里面包括了TLS内容）</li><li>连接迁移（从数据连接切换到WIFI连接因为IP改变，所以TCP连接重新建立，耗时；HTTP&#x2F;3通过<strong>连接ID</strong>绑定通信的两个端点，只要保留原上下文（连接ID，TLS密钥等），就可以继续复用原连接。）</li></ul><p>QUIC是UDP上：伪TCP+TLS+HTTP&#x2F;2的多路复用协议</p><p>注：<strong>SSL&#x2F;TLS1.2</strong>需要4次握手，<strong>SSL&#x2F;TLS1.3</strong>只需要3次握手</p><h3 id="HTTP-1-1如何优化"><a href="#HTTP-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h3><p>三方面考虑：</p><ol><li>尽量避免发送HTTP请求</li><li>需要请求时，尽量少发</li><li>减少服务器HTTP响应</li></ol><h4 id="1-避免发送请求"><a href="#1-避免发送请求" class="headerlink" title="1. 避免发送请求"></a>1. 避免发送请求</h4><p>有一些对于请求重复数据的请求就可以存在本地的缓冲中，直接读取本地的数据就行。</p><p>需要<strong>缓存技术</strong>：</p><p>客户端将第一次请求和响应保存在本地磁盘，请求的URL作为key，响应作为value。并且为了防止响应的数据过期，服务器会发送一个估算的过期时间，过期就重新发起请求。</p><p>并且为了提高协议性能，客户端重新发起请求时在<strong>Etag</strong>头部带上第一次响应头部的摘要，让服务器对比本地资源的摘要。如果不同，返回新资源。如果相同，返回不包含体的304响应，让服务器继续使用缓存数据。</p><h4 id="2-减少HTTP请求次数"><a href="#2-减少HTTP请求次数" class="headerlink" title="2. 减少HTTP请求次数"></a>2. 减少HTTP请求次数</h4><ul><li>减少重定向请求次数</li><li>合并请求</li><li>延迟发送请求</li></ul><h5 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h5><p>重定向：当资源迁移时，资源从url1到url2。客户端不知道情况，就需要先发送请求到url1（302响应码），再发送请求到url2。</p><p>服务端一般不只一台，源服务器上一级为代理服务器。</p><p>客户端-&gt;代理服务器-&gt;原服务器</p><p>将重定向的工作交给代理服务器完成，就可以减少HTTP请求次数，并且代理服务器知晓重定向规则后，可以进一步减少消息传递次数。</p><p>注：可以看小林coding上面的图</p><h5 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h5><p>将资源合并，用一个大的资源请求获取多个小资源请求。比如需要请求多个图片，可以用技术把它们合并成一个图片，只需要一个请求就行了。</p><h5 id="延时发送请求"><a href="#延时发送请求" class="headerlink" title="延时发送请求"></a>延时发送请求</h5><p>按需获取方式，当前不需要的资源，就不提前请求。需要的时候再请求。比如网页资源。</p><h4 id="3-减少HTTP响应数据大小"><a href="#3-减少HTTP响应数据大小" class="headerlink" title="3. 减少HTTP响应数据大小"></a>3. 减少HTTP响应数据大小</h4><p>压缩：</p><ul><li>无损压缩：文本文件、程序可执行文件、源代码</li><li>有损压缩：音频、图片、视频等</li></ul><h3 id="HTTPS-RSA握手解析"><a href="#HTTPS-RSA握手解析" class="headerlink" title="HTTPS RSA握手解析"></a>HTTPS RSA握手解析</h3><p><strong>RTT</strong>(往返时延)：发送端发送一个数据包到接收端，接收端返回确认包到发送端的整个时间。</p><p>整个TLS握手过程前面已经总结</p><p>补充以下：</p><ul><li><p>四次握手，需要2个RTT时延</p></li><li><p>密码套件基本形式为：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</p></li><li><p>CA进行签名过程为：对持有者的公钥等信息进行打包，然后对这个包进行hash计算，得到hash值，然后用私钥对这个值进行加密。</p></li><li><p>第三次握手，最后客户端发送的摘要信息，使用的是会话密钥加密。目的是验证加密通信是否可用和前面整个握手信息是否有被篡改。</p></li><li><p>RSA不支持前向保密，私钥一旦泄密，以前的所有TLS密文都被破解。</p></li></ul><p>前向保密：即使密钥被泄露，过去的信息也不会被解密。每次通信生成的都是临时密钥。</p><h3 id="HTTPS-ECDHE-握手解析"><a href="#HTTPS-ECDHE-握手解析" class="headerlink" title="HTTPS ECDHE 握手解析"></a>HTTPS ECDHE 握手解析</h3><p>算法核心思想：离散对数</p><p>ECDHE算法具有前向安全，现在被广泛使用。</p><p>DH-&gt;DHE-&gt;ECDHE</p><p>ECDHE算法实在DHE算法基础上使用了ECC椭圆曲线特性，用更少的计算量计算出公钥和最终的会话密钥。</p><p>TLS第一次握手，客户端：（1）TLS版本号（2）支持的密码套件（3）生成的随机数</p><p>TLS第二次握手，服务器:（1）确认TLS版本号（2）随机数（3）选择密码套件（4）数字证书（5）发送Server Key Exchange 消息</p><ul><li>Server Key Exchange 消息包括：<ul><li>选好了椭圆曲线（基点G也确定）</li><li>服务端椭圆曲线公钥</li></ul></li></ul><p>TLS第三次握手，客户端:（1）发送Client Key Exchange消息（2）发送后续改用对称算法加密通信（3）摘要信息使用对称密钥加密发送</p><ul><li>Client Key Exchange消息包括：<ul><li>客户端椭圆曲线公钥</li></ul></li></ul><p>TLS第四次握手，服务端:（1）发送改用对称算法加密通信（2）摘要信息使用对称密钥加密发送</p><p>注：</p><ol><li><p>会话密钥&#x3D;客户端随机数+服务端随机数+椭圆曲线生成的共享密钥</p></li><li><p>RSA在TLS完成四次握手后才能进行应用数据的传输；而ECDHE算法，客户端可以不等服务器最后一次TLS握手就进行加密HTTP数据传送，节省一个RTT时间。</p></li></ol><h3 id="HTTPS如何优化"><a href="#HTTPS如何优化" class="headerlink" title="HTTPS如何优化"></a>HTTPS如何优化</h3><p>先分析性能损耗，再来看怎么优化：</p><p>耗能阶段：</p><ul><li>TLS握手过程</li><li>握手后的对称加密包文传输</li></ul><p>多角度：</p><ul><li>硬件优化<ul><li>https是计算密集型，搞好一点的cpu，算得快</li></ul></li><li>软件优化<ul><li>软件升级：相对于协议优化，成本开销大</li><li>协议优化</li></ul></li><li>协议优化<ul><li>就是对密钥交换过程优化：<ul><li>算法优化：RSA换成ECDHE（2RTT-&gt;1RTT）时间减少，安全性增加</li><li>TLS升级：TLS1.2变为TLS1.3，TLS握手只要1RTT。因为1.3在客户端第一次握手时就将公钥交换这些发送给客户端了。</li></ul></li></ul></li><li>证书优化<ul><li>证书传输：用ECDHE证书，相同安全度下，密钥比RSA更短</li><li>证书验证：使用OCSP Stapling作为验证（验证证书是否还有效，可能被吊销）</li></ul></li><li>会话复用<ul><li>Session ID：双方都缓存会话密钥，并用Session ID唯一标识，再次连接时客户端hello消息带上这个Session ID，服务器匹配上就可以只需要发送一个消息返回就建立安全连接了。</li><li>Session Ticket：为了减少服务端的缓存，服务端将会话密钥加密放在客户端这里保存。然后再次建立连接时，客户端发送Ticket，服务器解密并验证有效期，就可建立安全通信。</li><li>上述两种都需要1RTT才可以建立， TLS1.3重连只需要0RTT，使用<strong>Pre-shared Key</strong>方法。客户端会把 Ticket 和 HTTP 请求一同发送给服务端。</li><li>注：会话复用不支持前向安全，且用重放攻击危险</li></ul></li></ul><h3 id="HTTP-2牛逼在哪"><a href="#HTTP-2牛逼在哪" class="headerlink" title="HTTP&#x2F;2牛逼在哪"></a>HTTP&#x2F;2牛逼在哪</h3><ul><li><p>兼容HTTP&#x2F;1.1</p></li><li><p>头部压缩：使用HPACK算法：（1）静态字典（2）动态字典（3）Huffman编码（压缩算法）</p><ul><li>静态字典：k-v</li></ul></li><li><p>二进制帧：将一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码（head+data）</p></li><li><p>并发传输：stream流（一条TCP连接传输多个stream，一个stream可以包含多个message（里面是请求或响应），message包含一个或多个Frame（存放的是压缩的头和body）</p></li><li><p>服务器主动推送资源：请求一个html，服务器可以主动发送css等。</p></li></ul><h3 id="3-7-HTTP-3-强势来袭"><a href="#3-7-HTTP-3-强势来袭" class="headerlink" title="3.7 HTTP&#x2F;3 强势来袭"></a>3.7 HTTP&#x2F;3 强势来袭</h3><h3 id="3-8-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#3-8-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="3.8 既然有 HTTP 协议，为什么还要有 RPC？"></a>3.8 既然有 HTTP 协议，为什么还要有 RPC？</h3><h3 id="3-9-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#3-9-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="3.9 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>3.9 既然有 HTTP 协议，为什么还要有 WebSocket？</h3><p>这三个直接看小林coding总结部分</p><ul><li>3.7：<a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93</a></li><li>3.8：<a href="https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93</a></li><li>3.9：<a href="https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93</a></li></ul><h2 id="TCP篇"><a href="#TCP篇" class="headerlink" title="TCP篇"></a>TCP篇</h2><h3 id="4-1-TCP三次握手与四次挥手面试题"><a href="#4-1-TCP三次握手与四次挥手面试题" class="headerlink" title="4.1 TCP三次握手与四次挥手面试题"></a>4.1 TCP三次握手与四次挥手面试题</h3><h4 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h4><h5 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h5><p><strong>TCP</strong>：（传输控制协议）是⼀种⾯向连接的、可靠的、基于字节流的传输层通信协议。</p><p><strong>UDP</strong>：（⽤户数据报协议）为应⽤程序提供了⼀种⽆需建⽴连接就可以发送封装的IP数据包的⽅</p><p>法。</p><p><strong>区别：</strong></p><ul><li>连接<ul><li>TCP面向连接、传输前要建立连接</li><li>UDP直接传输</li></ul></li><li>服务对象<ul><li>TCP一对一</li><li>UDP一对一、一对多、多对多</li></ul></li><li>可靠性<ul><li>TCP传输可靠数据</li><li>UDP不保证（但是可通过QUIC等协议实现可靠传输）</li></ul></li><li>拥塞控制、流量控制<ul><li>TCP有，保证数据安全</li><li>UDP无，网络再堵，不影响它发送</li></ul></li><li>首部开销<ul><li>TCP首部可变（开销大）</li><li>UDP固定不变（8个字节，开销小）</li></ul></li><li>传输方式<ul><li>流式传输，无边界，可保证顺序和可靠</li><li>包发送，有边界，可能丢包和乱序</li></ul></li><li>分片不同<ul><li>TCP的数据大于MSS，传输层分片</li><li>UDP的数据大于MTU，IP层分片</li></ul></li></ul><p><strong>应用场景</strong>：</p><ul><li>TCP：通信数据可靠<ul><li>FTP文件传输</li><li>HTTP&#x2F;HTTPS</li></ul></li><li>UDP：通信速度高<ul><li>DNS，SNMP</li><li>视频、音频等多媒体</li><li>广播通信</li></ul></li></ul><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><ul><li>UDP头部固定、无需额外记录</li><li>TCP头部有个选项，该长度可变，导致TCP头部不固定，需要记录。</li></ul><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><ul><li>TCP数据长度&#x3D;IP总长-IP首部长度-TCP首部长度，这三个长度都是已知的，可以直接算出，不需要额外算出来。</li><li>UDP由于方便处理，需要保证首部长度是4的整数倍，补充了包长度。</li></ul><h5 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h5><p>可以</p><p>TCP 和UDP，在内核中是两个完全独立的软件模块。</p><p>TCP和UDP各自端口号是独立的，他们的80端口是不一样的。</p><p>注：后续还有更详细的内容</p><h4 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h4><h5 id="TCP三次握手过程是怎么样的"><a href="#TCP三次握手过程是怎么样的" class="headerlink" title="TCP三次握手过程是怎么样的"></a>TCP三次握手过程是怎么样的</h5><p>SYN–&gt;ACK、SYN–&gt;ACK</p><ul><li>第一次：客户端发送报文，里面的SYN置1，生成随机序列号（假设为A），不带应用层数据，自己状态变为SYN_SENT</li><li>第二次：服务端发送报文，里面的ACK、SYN置1，生成随机序列号（假设为B），报文的确认应答号设为（A+1），不带应用层数据，自己状态变为SYN_RCVD</li><li>第三次：客户端发送报文，ACK置1，确认应答号设为（B+1），可带应用层数据，状态设为ESTABLISHED</li><li>服务端收到包文，状态也设为ESTABLISHED</li></ul><p>注：在第三次握手的时候就可以携带数据，前两次不行。状态都为ESTABLISHED时，就可互相发送数据了。</p><h5 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h5><p><code>etstat -napt</code>命令查看</p><h5 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h5><ol><li><strong>避免历史连接</strong></li></ol><p>可能由于客户端宕机，第一次发送的请求就失效了，但是第一次发送的请求已经到达服务器，服务器就会返回一个对第一个连接的ACK。同时客户端已经发送了新的请求，接收到服务器对原来请求的ACK，发现不是新连接需要的。就会发送RET，这样服务器就知道原来的没用了，就会接收新的。避免了历史连接。</p><p>+ </p><ol start="2"><li><strong>同步双方初始序列号</strong></li></ol><p>序列号是可靠传输的关键，两次握手只能保证一方的初始序列号能被对方接受。                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><p>序列号作用：</p><ul><li>接收方除去重复数据</li><li>接收方根据数据包的序列号按序接收</li><li>可以知道发出去的数据包哪些被正确接收</li></ul><ol start="3"><li><strong>避免资源浪费</strong></li></ol><p>只有两次握手会导致建立多的连接，浪费资源。</p><p>综上，三次握手可以避免历史连接，减少不必要的开销以及同步双方初始序列号。</p><p>两次不能实现避免历<del>、减少</del>、同步~</p><p>而对于四次握手，三次握手就是理论最少握手次数，不需要更多通信次数。</p><h5 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h5><ul><li>防止历史报文被下一个相同四元组的连接接收（主要方面）</li><li>为了安全性，防止黑客伪造相同序列号的TCP被接收</li></ul><h5 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h5><p>基于计时器</p><p>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</p><p>M是计时器，随着时间要增加</p><h5 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h5><ul><li>IP层进行分片传输，效率很低。因为一个IP分片丢了，整个IP报文分片都需要重传。并且IP层本身没有超时重传机制，只能等传输层TCP来负责。就会重传整个TCP报文，效率太低。</li><li>通过协商MSS值后，只会进行TCP切片，形成的包不会大于MTU，就不会进行IP分片。即便重传也只是以MSS单位，不会重传所有分片。</li><li>MSS最长为1500字节</li></ul><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><ul><li>会进行重传SYN，SYN报文的序列号是一样的。并且重传的SYN的次数限制由内核的<code>tcp_syn_retries</code>参数控制，默认为5。最后一次重传在等待一段时间还是没有收到ACK报文就会断开连接。</li><li>每次重传是在上次的两倍后（1s, 2s, 4s, 8s….）</li></ul><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><ul><li>客户端和服务端都会触发超时重传机制。因为客户端没收到ACK，服务端也没收到ACK。并且同样重传次数由参数控制<code>tcp_syn_retries</code>和<code>tcp_synack_retries</code>，默认值都为5。</li><li>并且某一个超时重传次数过了就直接会断开连接。</li></ul><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><ul><li>服务端触发超时重传机制，重发SYN_ACK报文，知道收到ACK或者断开连接。</li></ul><h5 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h5><ul><li>恶意客户端一直发送SYN报文，占满服务器的半连接队列（内核里），导致后续的SYN报文直接被丢弃。</li><li>避免<ul><li>调大netdev_max_backlog</li><li>增大TCP半连接队列</li><li>开启net.ipv4.tcp_syncookies</li><li>减少 SYN+ACK 重传次数</li></ul></li></ul><h4 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h4><h5 id="TCP四次挥手过程是怎么一样的？"><a href="#TCP四次挥手过程是怎么一样的？" class="headerlink" title="TCP四次挥手过程是怎么一样的？"></a>TCP四次挥手过程是怎么一样的？</h5><ol><li><p>客户端发送FIN，进入<code>FIN_WAIT_1</code>状态</p></li><li><p>服务端收到FIN后，发送ACK，进入<code>CLOSE_WAIT</code>状态（客户端收到进入<code>FIN_WAIT_2</code>状态）</p></li><li><p>服务端处理完数据发送FIN,进入<code>LAST_ACK</code>状态</p></li><li><p>客户端发送ACK，进入<code>TIME_WAIT</code>状态</p></li></ol><ul><li>服务器收到ACK后进入<code>CLOSE</code>状态</li><li>客户端经过<code>2MSL</code>一段时间后，自动进入<code>CLOSE</code>状态</li></ul><h5 id="为什么需要四次握手"><a href="#为什么需要四次握手" class="headerlink" title="为什么需要四次握手"></a>为什么需要四次握手</h5><ul><li>因为服务端在发送ACK后一般还有数据需要处理，所以会等数据处理完再发送FIN，导致不是三次而是四次。</li><li>但是特定情况下，可以是三次</li><li>三次挥手：接收到FIN后没有其他数据要处理，并且<strong>TCP延迟确认机制</strong>开启了的，第二次和第三次挥手就会合并传输。<ul><li>TCP延迟确认机制：主要目的是减少网络中ACK报文的数量，从而提高网络效率。其核心思想是：当接收方收到数据时，是等待一段时间（通常是200ms），看看是否有数据要发送给对端。如果有数据要发送，ACK可以和数据一起发送，从而减少单独的ACK报文。</li></ul></li></ul><h5 id="第一次丢失，会发生什么？"><a href="#第一次丢失，会发生什么？" class="headerlink" title="第一次丢失，会发生什么？"></a>第一次丢失，会发生什么？</h5><ul><li>客户端触发超时重传机制，次数过了还是没响应直接关闭连接。（从<code>FIN_WAIT_1</code>–&gt;<code>CLOSE</code>）</li></ul><h5 id="第二次挥手丢失，会发生什么？"><a href="#第二次挥手丢失，会发生什么？" class="headerlink" title="第二次挥手丢失，会发生什么？"></a>第二次挥手丢失，会发生什么？</h5><ul><li>ACK没有重传机制，相当于客户端还是没收到ACK。客户端同第一次丢失状态一样。</li><li>服务端收到了FIN，所以处于<code>CLOSE_WAIT</code>状态</li></ul><h5 id="第三次挥手丢失，发生什么？"><a href="#第三次挥手丢失，发生什么？" class="headerlink" title="第三次挥手丢失，发生什么？"></a>第三次挥手丢失，发生什么？</h5><ul><li>客户端收到第二次挥手的ACK后，会处于<code>FIN_WAIT_2</code>状态。这个状态默认持续时间为60秒，超时就会直接关闭连接。</li><li>服务端发送了FIN没有响应就会触发超时重传机制，超过次数还是没有响应会直接断开连接。</li></ul><h5 id="第四次挥手丢失，发生什么？"><a href="#第四次挥手丢失，发生什么？" class="headerlink" title="第四次挥手丢失，发生什么？"></a>第四次挥手丢失，发生什么？</h5><ul><li>客户端此时状态为<code>TIME_WAIT</code>，并且开启2MSL定时器。正常情况等待2MSL过后就关闭连接，但是因为服务端的超时重传会发送FIN，导致定时器会重置，直到成功或者次数用完，关闭连接。</li><li>服务端处于<code>LAST_ACK</code>状态。触发超时重传机制，还是没收到ACK就直接关闭连接。</li></ul><h5 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h5><p>MSL：报文最大生存时间</p><p>TTL：IP数据包可以经过最大路由数，每经过一个就减1，为0时直接被丢弃，并且发送ICMP报文给源主机。</p><p>MSL的时间是大于TTL消耗完的时间。2MLS实际上就是至少允许报文丢失一次。</p><h5 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME_WAIT状态？"></a>为什么需要TIME_WAIT状态？</h5><p>主动发起关闭的一方，才有<code>TIME-WAIT</code>状态</p><ul><li>防止历史连接中的数据，被后面相同的四元组连接错误的接收<ul><li>2MSL足够让两个方向的数据包都丢弃，使原来连接的数据都自然消失，再出现的数据都是在新连接上建立的。</li></ul></li><li>保证被动关闭连接的一方，能被正确的关闭<ul><li>如果没有<code>TIME-WAIT</code>状态，客户端发完ACK后直接进入<code>CLOSE</code>状态。如果服务端没收到ACK，重发FIN，客户端会返回RET报文。服务端会认为是一个错误。为了防止这种情况发生，就有了这个状态。</li></ul></li></ul><h5 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h5><ul><li>占用系统资源</li><li>占用端口资源</li></ul><p>服务端：只占用系统资源，因为服务端只监听一个端口。且一个TCP连接由四元组唯一确定。</p><p>客户端：如果占满了所有端口资源，就无法跟[目标IP+目标端口]一样的服务器发起连接了。</p><h5 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h5><ul><li>net.ipv4.tcp_tw_reuse 和 tcp_timestamps</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER</li></ul><p>具体细节：<a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-time-wait">https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-time-wait</a></p><h5 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h5><ul><li>HTTP没有使用长连接<ul><li>无论是客户端还是服务端在header中有<code>Connection:close</code>，就无法使用长连接，都会由服务端在完成响应后主动关闭连接。</li></ul></li><li>HTTP长连接超时<ul><li>一般为了避免浪费资源，会设置一个长连接的超时时间。如果客户端完成一个HTTP请求后，在这个时间内都没发起新的请求，客户端就会关闭连接。</li></ul></li><li>HTTP长连接的请求数量达到上限<ul><li>一般web服务端一条长连接会设置最大HTTP请求数量，达到最大值，就会主动断开连接。</li></ul></li></ul><h5 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h5><ul><li><code>CLOSE_WAIT</code>状态只有被动关闭方才有，并且如果没调用close函数关闭连接，就无法发送FIN报文，无法从<code>CLOSE_WAIT</code>—&gt;<code>LAST_ACK</code>状态</li></ul><hr><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B">https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B</a></p><h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><ul><li>TCP有一个保活机制。过了一段时间没有活动就会发送探测报文，发了几次还是没响应就会认为TCP连接已经死亡，并且系统内核将信息发送给应用层程序。</li><li>需要在socket接口设置<code>SO_KEEPALIVE</code>保活机制才生效</li><li>但是保活机制时间过长，可以在应用层自己设置一个心跳机制，超时就释放连接。</li></ul><h5 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h5><ul><li>因为TCP信息由内核维护，所以崩了过后内核会回收所有该进程TCP连接，发送FIN报文，完成四次挥手。</li></ul><h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><h5 id="针对-TCP-应该如何-Socket-编程？"><a href="#针对-TCP-应该如何-Socket-编程？" class="headerlink" title="针对 TCP 应该如何 Socket 编程？"></a>针对 TCP 应该如何 Socket 编程？</h5><ul><li>初始化时，得到文件描述符</li><li>服务端<code>accept</code>返回用于传输得<code>socket</code>的文件描述符</li><li>监听的socket和连接的socket是两个</li></ul><h5 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h5><ul><li>Linux内核维护两个队列<ul><li>半连接队列（SYN队列）</li><li>全连接队列（Accept队列）</li></ul></li><li>早期backlog是半连接队列大小，现在通常是全连接队列长度。</li></ul><h5 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h5><ul><li>发生在第三次握手后，因为此时服务端成功建立连接</li></ul><h5 id="客户端调用-close-了，连接是断开的流程是什么？"><a href="#客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么？"></a>客户端调用 close 了，连接是断开的流程是什么？</h5><ul><li>客户端：发送FIN（变为FIN_WAIT_1）—&gt;收到ACK（变为FIN_WAIT_2）—&gt;收到FIN（发送ACK、变为TIME_WAIT）—&gt;等待2MSL变为CLOSE</li><li>服务端：收到FIN（发送ACK、变为CLOSE_WAIT）—&gt;读到EOF后，调用close，发送FIN（变为LAST_ACK）—&gt;收到ACK（变为CLOSE）</li></ul><h5 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h5><ul><li>可以的</li></ul><h5 id="没有-listen，能建立-TCP-连接吗"><a href="#没有-listen，能建立-TCP-连接吗" class="headerlink" title="没有 listen，能建立 TCP 连接吗"></a>没有 listen，能建立 TCP 连接吗</h5><ul><li>可以的</li></ul><h3 id="4-2-TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#4-2-TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="4.2 TCP 重传、滑动窗口、流量控制、拥塞控制"></a>4.2 TCP 重传、滑动窗口、流量控制、拥塞控制</h3><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>超时重传时间（RTO）略大于报文往返时间（RTT）</p><p>RTT和RTO是一个动态变化的值</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><ul><li>不以时间为驱动，以数据驱动重传</li><li>存在重传一个还是重传所有的问题，引出了SACK方法</li></ul><h5 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h5><ul><li>选择性确认</li></ul><h5 id="D-SACK方法"><a href="#D-SACK方法" class="headerlink" title="D-SACK方法"></a>D-SACK方法</h5><ul><li>使用SACK告诉发送方哪些数据被重复接收了</li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><h5 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h5><ul><li>为了防止丢包，TCP不允许同时减少缓存又收缩窗口。采用先收缩，过段时间再减少窗口</li></ul><h5 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h5><p>会造成的潜在死锁现象：当接收方的窗口再次打开，发送报文通知时，如果丢包，就会时双方一直陷入等待状态。</p><p>解决方法：设置一个定时，当窗口为0后开始计时，超时了就进行报文探测。</p><h5 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h5><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞窗口是发送方控制的</p><p>加入拥塞窗口概念后，发送窗口值&#x3D;min(拥塞窗口，接收窗口)</p><p>拥塞控制主要是四种算法：</p><ul><li>慢启动：cwnd指数增长</li><li>拥塞避免：cwnd线性增长</li><li>拥塞发送</li><li>快速恢复</li></ul><h3 id="4-3-TCP实战抓包分析"><a href="#4-3-TCP实战抓包分析" class="headerlink" title="4.3 TCP实战抓包分析"></a>4.3 TCP实战抓包分析</h3><h3 id="4-4-TCP半连接和全连接队列"><a href="#4-4-TCP半连接和全连接队列" class="headerlink" title="4.4 TCP半连接和全连接队列"></a>4.4 TCP半连接和全连接队列</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计网面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（1）</title>
      <link href="/2024/11/27/mei-ri-xue-xi-1/"/>
      <url>/2024/11/27/mei-ri-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="8-对称二叉树"><a href="#8-对称二叉树" class="headerlink" title="8. 对称二叉树"></a>8. 对称二叉树</h3><p>左右子树反转完全相等就是对称，左边顺序为中左右，右边顺序为中右左。</p><h3 id="12-平衡二叉树"><a href="#12-平衡二叉树" class="headerlink" title="12. 平衡二叉树"></a>12. 平衡二叉树</h3><p>递归三部曲：</p><ol><li>确定参数和返回值</li><li>确定终止条件</li><li>确定单层递归逻辑</li></ol><p>1.参数为节点，返回值为以该节点为根节点的树的高度（不是平衡二叉树返回-1）</p><p>2.空节点就终止</p><p>3.左子树高度，右子树高度，相差是否&lt;&#x3D;1</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p>将TCP协议变成UDP协议，并且使用基于UDP的QUIC协议</p><p>QUIC特点</p><ul><li>无队头堵塞（stream丢包，只堵塞这个流，不像HTTP&#x2F;2堵塞TCP整个队头）</li><li>更快的连接方式（HTTP&#x2F;2先TCP握手，再TLS握手；HTTP&#x2F;3，QUIC握手里面包括了TLS内容）</li><li>连接迁移（从数据连接切换到WIFI连接因为IP改变，所以TCP连接重新建立，耗时；HTTP&#x2F;3通过<strong>连接ID</strong>绑定通信端点，只要保留原上下文（连接ID，TLS密钥等），就可以继续原链接。）</li></ul><p>QUIC是UDP上：伪TCP+TLS+HTTP&#x2F;2的多路复用协议</p><p>注：<strong>SSL&#x2F;TLS1.2</strong>需要4次握手，<strong>SSL&#x2F;TLS1.3</strong>只需要3次握手</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
