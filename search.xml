<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>每日学习（12）</title>
      <link href="/2024/12/13/mei-ri-xue-xi-12/"/>
      <url>/2024/12/13/mei-ri-xue-xi-12/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="9-分割回文串"><a href="#9-分割回文串" class="headerlink" title="9. 分割回文串"></a>9. 分割回文串</h4><p>和组合类似，但是记住是<strong>分割</strong>。重点是</p><ul><li>划分字串判断回文：<code>str = s[start:i+1]</code></li><li>终止条件：<code>start = len(s)</code></li></ul><h4 id="10-复原IP地址"><a href="#10-复原IP地址" class="headerlink" title="10. 复原IP地址"></a>10. 复原IP地址</h4><ul><li>和9很类似，只是注意终止条件多加一个<code>len(path) == 4</code></li></ul><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h5 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h5><ul><li>IP层进行分片传输，效率很低。因为一个IP分片丢了，整个IP报文分片都需要重传。并且IP层本身没有超时重传机制，只能等传输层TCP来负责。就会重传整个TCP报文，效率太低。</li><li>通过协商MSS值后，只会进行TCP切片，形成的包不会大于MTU，就不会进行IP分片。即便重传也只是以MSS单位，不会重传所有分片。</li><li>MSS最长为1500字节</li></ul><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><ul><li>会进行重传SYN，SYN报文的序列号是一样的。并且重传的SYN的次数限制由内核的<code>tcp_syn_retries</code>参数控制，默认为5。最后一次重传在等待一段时间还是没有收到ACK报文就会断开连接。</li><li>每次重传是在上次的两倍后（1s, 2s, 4s, 8s….）</li></ul><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><ul><li>客户端和服务端都会触发超时重传机制。因为客户端没收到ACK，服务端也没收到ACK。并且同样重传次数由参数控制<code>tcp_syn_retries</code>和<code>tcp_synack_retries</code>，默认值都为5。</li><li>并且某一个超时重传次数过了就直接会断开连接。</li></ul><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><ul><li>服务端触发超时重传机制，重发SYN_ACK报文，知道收到ACK或者断开连接。</li></ul><h5 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h5><ul><li>恶意客户端一直发送SYN报文，占满服务器的半连接队列（内核里），导致后续的SYN报文直接被丢弃。</li><li>避免<ul><li>调大netdev_max_backlog</li><li>增大TCP半连接队列</li><li>开启net.ipv4.tcp_syncookies</li><li>减少 SYN+ACK 重传次数</li></ul></li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>使用swagger</li><li>完善角色和权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（10、11）</title>
      <link href="/2024/12/11/mei-ri-xue-xi-10-11/"/>
      <url>/2024/12/11/mei-ri-xue-xi-10-11/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="4-组合总和III"><a href="#4-组合总和III" class="headerlink" title="4. 组合总和III"></a>4. 组合总和III</h4><ul><li>模板解题</li></ul><h4 id="5-电话号码的字母组合"><a href="#5-电话号码的字母组合" class="headerlink" title="5. 电话号码的字母组合"></a>5. 电话号码的字母组合</h4><ul><li>模板解题，注意string-&gt;[]byte</li></ul><h4 id="7-组合总和"><a href="#7-组合总和" class="headerlink" title="7. 组合总和"></a>7. 组合总和</h4><ul><li>保证无重复的数组：需要有<code>start</code>，并且<code>start=i</code></li></ul><h4 id="8-组合总和II"><a href="#8-组合总和II" class="headerlink" title="8. 组合总和II"></a>8. 组合总和II</h4><ul><li>重点是去重（同层的重复去掉）</li></ul><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h4 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h4><h5 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h5><p><strong>区别：</strong></p><ul><li>连接<ul><li>TCP面向连接、传输前要建立连接</li><li>UDP直接传输</li></ul></li><li>服务对象<ul><li>TCP一对一</li><li>UDP一对一、一对多、多对多</li></ul></li><li>可靠性<ul><li>TCP传输可靠数据</li><li>UDP不保证（但是可通过QUIC等协议实现可靠传输）</li></ul></li><li>拥塞控制、流量控制<ul><li>TCP有，保证数据安全</li><li>UDP无，网络再堵，不影响它发送</li></ul></li><li>首部开销<ul><li>TCP首部可变（开销大）</li><li>UDP固定不变（8个字节，开销小）</li></ul></li><li>传输方式<ul><li>流式传输，无边界，可保证顺序和可靠</li><li>包发送，有边界，可能丢包和乱序</li></ul></li><li>分片不同<ul><li>TCP的数据大于MSS，传输层分片</li><li>UDP的数据大于MTU，IP层分片</li></ul></li></ul><p><strong>应用场景</strong>：</p><ul><li>TCP<ul><li>FTP文件传输</li><li>HTPP&#x2F;HTTPS</li></ul></li><li>UDP<ul><li>DNS，SNMP</li><li>视频、音频等多媒体</li><li>广播通信</li></ul></li></ul><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><ul><li>UDP头部固定、无需额外记录</li><li>TCP头部有个选项，该长度可变，导致TCP头部不固定，需要记录。</li></ul><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><ul><li>TCP数据长度&#x3D;IP总长-IP首部长度-TCP首部长度，这三个长度都是已知的，可以直接算出，不需要额外算出来。</li><li>UDP由于方便处理，需要保证首部长度是4的整数倍，补充了包长度。</li></ul><h5 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h5><p>可以</p><p>TCP 和UDP，在内核中是两个完全独立的软件模块。</p><p>TCP和UDP各自端口号是独立的，他们的80端口是不一样的。</p><p>注：后续还有更详细的内容</p><h4 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h4><h5 id="TCP三次握手过程是怎么样的"><a href="#TCP三次握手过程是怎么样的" class="headerlink" title="TCP三次握手过程是怎么样的"></a>TCP三次握手过程是怎么样的</h5><p>SYN–&gt;ACK、SYN–&gt;ACK</p><ul><li>第一次：客户端发送包文，里面的SYN置1，生成随机序列号（假设为A），不带应用层数据，自己状态变为SYN–SENT</li><li>第二次：服务端发送包文，里面的ACK、SYN置1，生成随机序列号（假设为B），包文的确认应答号设为（A+1），不带应用层数据，自己状态变为SYN–RCVD</li><li>第三次：客户端发送报文，ACK置1，确认应答号设为（B+1），可带应用层数据，状态设为ESTABLISHED</li><li>服务端收到包文，状态也设为ESTABLISHED</li></ul><p>注：在第三次握手的时候就可以携带数据，前两次不行。状态都为ESTABLISHED时，就可互相发送数据了。</p><h5 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h5><p><code>etstat -napt</code>命令查看</p><h5 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h5><ol><li><strong>避免历史连接</strong></li></ol><p>可能由于客户端宕机，第一次发送的请求就失效了，但是第一次发送的请求已经到达服务器，服务器就会返回一个对第一个连接的ACK。同时客户端已经发送了新的请求，接收到服务器对原来请求的ACK，发现不是新连接需要的。就会发送RET，这样服务器就知道原来的没用了，就会接收新的。避免了历史连接。</p><ol start="2"><li><strong>同步双方初始序列号</strong></li></ol><p>序列号是可靠传输的关键，两次握手只能保证一方的初始序列号能被对方接受。                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><p>序列号作用：</p><ul><li>接收方除去重复数据</li><li>接收方根据数据包的序列号按序接收</li><li>可以知道发出去的数据包哪些被正确接收</li></ul><ol start="3"><li><strong>避免资源浪费</strong></li></ol><p>只有两次握手会导致建立多的连接，浪费资源。</p><p>综上，三次握手可以避免历史连接，减少不必要的开销以及同步双方初始序列号。</p><p>两次不能实现避免历<del>、减少</del>、同步~</p><p>而对于四次握手，三次握手就是理论最少握手次数，不需要更多通信次数。</p><h5 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h5><ul><li>防止历史报文被下一个相同四元组的连接接收（主要方面）</li><li>为了安全性，防止黑客伪造相同序列号的TCP被接收</li></ul><h5 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h5><p>基于计时器</p><p>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</p><p>M是计时器，随着时间要增加</p><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>swagger</li><li>captcha</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（9）</title>
      <link href="/2024/12/09/mei-ri-xue-xi-9/"/>
      <url>/2024/12/09/mei-ri-xue-xi-9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul><li><p>回溯和递归是相辅相成的</p></li><li><p>纯暴力搜索</p><ul><li>组合问题（组合是无序的）</li><li>切割问题</li><li>子集问题</li><li>排列问题（强调顺序）</li><li>棋盘问题</li></ul></li><li><p>抽象为树形结构（n叉树）   </p></li><li><p>模板</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        存放结果<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        处理节点<span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>        回溯，撤销处理结果    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>剪枝优化：替换for循环里面小于等于的那个数</p></li></ul><h4 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2. 组合问题"></a>2. 组合问题</h4><ul><li>使用模板就可解题，回溯相当于n层for循环，只是在最开始的if判断就是终止条件。</li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>用户管理</li></ul><p><strong>用户列表分页作用</strong></p><ol><li><p>提升用户体验</p></li><li><p>节省资源</p></li><li><p>支持数据检索和管理</p><ul><li>便于查找特定用户：结合分页和搜索功能，用户可以快速定位目标用户，而不需要滚动浏览整个列表。</li><li>便于排序和过滤：分页让用户可以对数据进行动态排序或过滤，而无需等待整个列表重新加载。</li></ul></li><li><p>增强数据的可控性</p><ul><li>分步加载：分页实现了按需加载数据的机制，避免一次性加载所有数据可能带来的错误或系统崩溃。</li><li>支持无限滚动：虽然是分页的另一种形式，基于分页的无限滚动可以提供更现代的交互体验，同时保持分页的性能优势。</li></ul></li></ol><p><strong>实现了</strong>：</p><ul><li>数据操作层</li><li>业务逻辑层</li><li>控制器层</li></ul><p><code>Query</code>：用于获取 URL 查询字符串（<code>?key=value</code>）。</p><p><code>Param</code>：用于获取 UR</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（8）</title>
      <link href="/2024/12/08/mei-ri-xue-xi-8/"/>
      <url>/2024/12/08/mei-ri-xue-xi-8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="32-将有序数组转换为二叉搜索树（平衡二叉树）"><a href="#32-将有序数组转换为二叉搜索树（平衡二叉树）" class="headerlink" title="32. 将有序数组转换为二叉搜索树（平衡二叉树）"></a>32. 将有序数组转换为二叉搜索树（平衡二叉树）</h4><p>要将数组一直划分成两份，就像搜索树左右大小不同一样，也是越往下越是划分左右大小。</p><p>三部曲中：</p><ul><li>判断终止条件为nums为空</li></ul><h4 id="33-把二叉搜索树转换为累加树"><a href="#33-把二叉搜索树转换为累加树" class="headerlink" title="33. 把二叉搜索树转换为累加树"></a>33. 把二叉搜索树转换为累加树</h4><ul><li>使用右中左递归顺序，来依次累加。</li></ul><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><ul><li>看了TCP面试部分，没看多少</li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><ul><li>Gin 框架中间件与配置模块</li></ul><ol><li>理解 Gin 框架中间件的工作原理，学习如何编写自定义中间件。</li><li>掌握常用中间件的实现，如日志记录、跨域处理、JWT 鉴权等。</li><li>学习如何设计和使用全局配置模块，管理项目的配置信息。</li></ol><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>日志</li><li>跨域</li><li>鉴权（JWT）</li></ul><h3 id="配置模式设计"><a href="#配置模式设计" class="headerlink" title="配置模式设计"></a>配置模式设计</h3><ul><li>config-config.go</li><li>yaml</li></ul><h3 id="练习任务"><a href="#练习任务" class="headerlink" title="练习任务"></a>练习任务</h3><ol><li><strong>日志中间件</strong><ul><li>编写一个日志中间件，记录请求方法、路径、客户端 IP、响应时间等信息。</li></ul></li><li><strong>跨域支持</strong><ul><li>实现一个跨域中间件，允许特定域名的请求。</li></ul></li><li><strong>配置模块</strong><ul><li>创建一个 <code>config.yaml</code>，加载数据库和 Redis 配置信息。</li><li>在主函数中调用配置，并打印配置信息。</li></ul></li><li><strong>综合练习</strong><ul><li>编写一个具有日志、跨域和 JWT 鉴权功能的 Gin 服务。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（7）</title>
      <link href="/2024/12/07/mei-ri-xue-xi-7/"/>
      <url>/2024/12/07/mei-ri-xue-xi-7/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="30-删除二叉搜索树中的节点"><a href="#30-删除二叉搜索树中的节点" class="headerlink" title="30. 删除二叉搜索树中的节点"></a>30. 删除二叉搜索树中的节点</h4><p>要用left &#x3D; ….，right&#x3D;….，并且对要删除的节点分情况：</p><ul><li>左右都为空（叶子节点）<ul><li>返回nil</li></ul></li><li>左不为空，右为空<ul><li>返回左子树</li></ul></li><li>左为空，右不为空<ul><li>返回右子树</li></ul></li><li>左右都不为空（最复杂）<ul><li>将左子树移动到右子树最左边，返回右子树</li></ul></li></ul><h4 id="31-修剪二叉搜索树"><a href="#31-修剪二叉搜索树" class="headerlink" title="31. 修剪二叉搜索树"></a>31. 修剪二叉搜索树</h4><ul><li>最搞笑的一题，莫名其妙就做出来了</li></ul><p>就是仿上一题，将所有不满足的节点都删掉。</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="3-7-HTTP-3-强势来袭"><a href="#3-7-HTTP-3-强势来袭" class="headerlink" title="3.7 HTTP&#x2F;3 强势来袭"></a>3.7 HTTP&#x2F;3 强势来袭</h3><h3 id="3-8-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#3-8-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="3.8 既然有 HTTP 协议，为什么还要有 RPC？"></a>3.8 既然有 HTTP 协议，为什么还要有 RPC？</h3><h3 id="3-9-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#3-9-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="3.9 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>3.9 既然有 HTTP 协议，为什么还要有 WebSocket？</h3><p>这三个直接看小林coding总结部分</p><ul><li>3.7：<a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93</a></li><li>3.8：<a href="https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93</a></li><li>3.9：<a href="https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93</a></li></ul><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis主要是进行短期存储，虽然提供了持久化选项（如 RDB 快照和 AOF 日志），但其主要设计目标是高性能的内存操作。常用于缓存、消息队列、会话管理等场景。</p><p><strong>context</strong></p><ul><li><p><code>context</code> 是管理操作生命周期的核心工具。</p></li><li><p>四种 context 创建方式满足不同需求（根、取消、超时、存储值）。</p></li><li><p>常用于控制 goroutine、网络请求、数据库操作的生命周期。</p></li></ul><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p><strong>JWT 介绍</strong><br>JWT 是一种用于安全地传输信息的令牌，由三部分组成：</p><ul><li><strong>Header</strong>：声明令牌类型和加密算法。</li><li><strong>Payload</strong>：包含声明（例如用户信息）。</li><li><strong>Signature</strong>：用密钥签名确保数据的完整性。</li></ul><p><strong>JWT 的工作原理</strong>：</p><ul><li>用户登录后，服务器验证身份并生成 JWT Token。</li><li>客户端在后续请求中携带 Token，服务器验证 Token 以确认用户身份。</li></ul><h3 id="练习任务"><a href="#练习任务" class="headerlink" title="练习任务"></a><strong>练习任务</strong></h3><ol><li><strong>Redis 缓存练习</strong><ul><li>将用户信息存储到 Redis 中，并模拟缓存失效后从数据库重新获取数据。</li></ul></li><li><strong>JWT 登录功能</strong><ul><li>编写一个模拟登录接口，通过用户名生成 JWT Token，并验证 Token 的有效性。</li></ul></li><li><strong>Redis 与 JWT 结合</strong><ul><li>使用 Redis 存储</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（6）</title>
      <link href="/2024/12/04/mei-ri-xue-xi-6/"/>
      <url>/2024/12/04/mei-ri-xue-xi-6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="26-二叉树就的最近公共祖先"><a href="#26-二叉树就的最近公共祖先" class="headerlink" title="26. 二叉树就的最近公共祖先"></a>26. 二叉树就的最近公共祖先</h4><p>只要找到有p、q就往上返回，相当于回溯（从下往上回），然后判断左右子树是不是不为空，不为空就是最近公共祖先。这个过程包括了p或q本身为公共祖先，因为最终返回的结果只有一个。</p><h4 id="27-二叉搜索树的最近公共祖先"><a href="#27-二叉搜索树的最近公共祖先" class="headerlink" title="27. 二叉搜索树的最近公共祖先"></a>27. 二叉搜索树的最近公共祖先</h4><p>找到第一个在p、q集合里面的就行（包括两端点）</p><h4 id="28-二叉搜索树的插入操作"><a href="#28-二叉搜索树的插入操作" class="headerlink" title="28. 二叉搜索树的插入操作"></a>28. 二叉搜索树的插入操作</h4><p>记住递归三部曲，然后往里面套。一直往下走，直到为空，就可以将节点插入。</p><h2 id="go-vue（新）"><a href="#go-vue（新）" class="headerlink" title="go-vue（新）"></a>go-vue（新）</h2><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="1-路由与控制器"><a href="#1-路由与控制器" class="headerlink" title="1. 路由与控制器"></a>1. 路由与控制器</h3><ul><li>路由基础</li><li>控制器封装</li></ul><h3 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2. 中间件"></a>2. 中间件</h3><p>对于中间件的处理：最终的完整响应是所有中间件和目标路由处理器处理完过后的响应。</p><h3 id="3-路由分组"><a href="#3-路由分组" class="headerlink" title="3. 路由分组"></a>3. 路由分组</h3><h3 id="4-练习任务"><a href="#4-练习任务" class="headerlink" title="4. 练习任务"></a>4. 练习任务</h3><ol><li>修改路由：<ul><li>添加 <code>/hello</code> 路由，返回 <code>&#123;&quot;message&quot;: &quot;hello, world!&quot;&#125;</code>。</li></ul></li><li>实现一个时间中间件：<ul><li>在响应中添加当前服务器时间。</li></ul></li><li>尝试实现一个 POST 接口：<ul><li>接收 JSON 数据，返回原数据。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> go-vue（新） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-Vue（新）</title>
      <link href="/2024/12/04/go-vue-ready/"/>
      <url>/2024/12/04/go-vue-ready/</url>
      
        <content type="html"><![CDATA[<h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="1-路由与控制器"><a href="#1-路由与控制器" class="headerlink" title="1. 路由与控制器"></a>1. 路由与控制器</h3><ul><li>路由基础</li><li>控制器封装</li></ul><h3 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2. 中间件"></a>2. 中间件</h3><p>对于中间件的处理：最终的完整响应是所有中间件和目标路由处理器处理完过后的响应。</p><h3 id="3-路由分组"><a href="#3-路由分组" class="headerlink" title="3. 路由分组"></a>3. 路由分组</h3><h3 id="4-练习任务"><a href="#4-练习任务" class="headerlink" title="4. 练习任务"></a>4. 练习任务</h3><ol><li>修改路由：<ul><li>添加 <code>/hello</code> 路由，返回 <code>&#123;&quot;message&quot;: &quot;hello, world!&quot;&#125;</code>。</li></ul></li><li>实现一个时间中间件：<ul><li>在响应中添加当前服务器时间。</li></ul></li><li>尝试实现一个 POST 接口：<ul><li>接收 JSON 数据，返回原数据。</li></ul></li></ol><h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h3 id="gorm操作"><a href="#gorm操作" class="headerlink" title="gorm操作"></a>gorm操作</h3><ul><li><p>增</p></li><li><p>删</p></li><li><p>改</p></li><li><p>查</p></li><li><p>事务处理</p></li></ul><h3 id="练习任务"><a href="#练习任务" class="headerlink" title="练习任务"></a><strong>练习任务</strong></h3><ol><li><strong>创建一个用户模型</strong>，并进行基本的 CRUD 操作。</li><li><strong>为订单表设计一个与用户的一对多关系</strong>，完成用户与订单的相关操作。</li><li><strong>实现数据的事务处理</strong>，模拟一个修改用户与订单的操作，如果失败则回滚。</li></ol><h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis主要是进行短期存储，虽然提供了持久化选项（如 RDB 快照和 AOF 日志），但其主要设计目标是高性能的内存操作。常用于缓存、消息队列、会话管理等场景。</p><p><strong>context</strong></p><ul><li><p><code>context</code> 是管理操作生命周期的核心工具。</p></li><li><p>四种 context 创建方式满足不同需求（根、取消、超时、存储值）。</p></li><li><p>常用于控制 goroutine、网络请求、数据库操作的生命周期。</p></li></ul><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p><strong>JWT 介绍</strong><br>JWT 是一种用于安全地传输信息的令牌，由三部分组成：</p><ul><li><strong>Header</strong>：声明令牌类型和加密算法。</li><li><strong>Payload</strong>：包含声明（例如用户信息）。</li><li><strong>Signature</strong>：用密钥签名确保数据的完整性。</li></ul><p><strong>JWT 的工作原理</strong>：</p><ul><li>用户登录后，服务器验证身份并生成 JWT Token。</li><li>客户端在后续请求中携带 Token，服务器验证 Token 以确认用户身份。</li></ul><h3 id="练习任务-1"><a href="#练习任务-1" class="headerlink" title="练习任务"></a><strong>练习任务</strong></h3><ol><li><strong>Redis 缓存练习</strong><ul><li>将用户信息存储到 Redis 中，并模拟缓存失效后从数据库重新获取数据。</li></ul></li><li><strong>JWT 登录功能</strong><ul><li>编写一个模拟登录接口，通过用户名生成 JWT Token，并验证 Token 的有效性。</li></ul></li><li><strong>Redis 与 JWT 结合</strong><ul><li>使用 Redis 存储已登录用户的 Token，模拟 Token 的过期或强制下线。</li></ul></li></ol><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><ul><li>Gin 框架中间件与配置模块</li></ul><ol><li>理解 Gin 框架中间件的工作原理，学习如何编写自定义中间件。</li><li>掌握常用中间件的实现，如日志记录、跨域处理、JWT 鉴权等。</li><li>学习如何设计和使用全局配置模块，管理项目的配置信息。</li></ol><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>日志</li><li>跨域</li><li>鉴权（JWT）</li></ul><h3 id="配置模式设计"><a href="#配置模式设计" class="headerlink" title="配置模式设计"></a>配置模式设计</h3><ul><li>config-config.go</li><li>yaml</li></ul><h3 id="练习任务-2"><a href="#练习任务-2" class="headerlink" title="练习任务"></a>练习任务</h3><ol><li><strong>日志中间件</strong><ul><li>编写一个日志中间件，记录请求方法、路径、客户端 IP、响应时间等信息。</li></ul></li><li><strong>跨域支持</strong><ul><li>实现一个跨域中间件，允许特定域名的请求。</li></ul></li><li><strong>配置模块</strong><ul><li>创建一个 <code>config.yaml</code>，加载数据库和 Redis 配置信息。</li><li>在主函数中调用配置，并打印配置信息。</li></ul></li><li><strong>综合练习</strong><ul><li>编写一个具有日志、跨域和 JWT 鉴权功能的 Gin 服务。</li></ul></li></ol><h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><ul><li>用户管理</li></ul><h3 id="用户列表分页作用"><a href="#用户列表分页作用" class="headerlink" title="用户列表分页作用"></a>用户列表分页作用</h3><h4 id="1-提升用户体验"><a href="#1-提升用户体验" class="headerlink" title="1. 提升用户体验"></a>1. <strong>提升用户体验</strong></h4><ul><li><strong>减少加载时间</strong>：如果用户列表包含成百上千的用户，一次性加载所有数据会导致页面加载缓慢。分页可以显著减少每次请求的数据量，提高加载速度。</li><li><strong>便于浏览</strong>：分页将用户列表分成多个页面，方便用户逐页查看，避免信息过载。</li></ul><h4 id="2-节省资源"><a href="#2-节省资源" class="headerlink" title="2. 节省资源"></a>2. <strong>节省资源</strong></h4><ul><li><strong>降低服务器负载</strong>：分页可以减少每次从数据库查询和返回的数据量，降低服务器内存和网络资源的占用。</li><li><strong>优化前端性能</strong>：前端渲染大量数据会导致性能下降。分页让前端只需渲染当前页的数据，减轻浏览器负担。</li></ul><h4 id="3-支持数据检索和管理"><a href="#3-支持数据检索和管理" class="headerlink" title="3. 支持数据检索和管理"></a>3. <strong>支持数据检索和管理</strong></h4><ul><li><strong>便于查找特定用户</strong>：结合分页和搜索功能，用户可以快速定位目标用户，而不需要滚动浏览整个列表。</li><li><strong>便于排序和过滤</strong>：分页让用户可以对数据进行动态排序或过滤，而无需等待整个列表重新加载。</li></ul><h4 id="4-增强数据的可控性"><a href="#4-增强数据的可控性" class="headerlink" title="4. 增强数据的可控性"></a>4. <strong>增强数据的可控性</strong></h4><ul><li><strong>分步加载</strong>：分页实现了按需加载数据的机制，避免一次性加载所有数据可能带来的错误或系统崩溃。</li><li><strong>支持无限滚动</strong>：虽然是分页的另一种形式，基于分页的无限滚动可以提供更现代的交互体验，同时保持分页的性能优势。</li></ul><hr><p>实现了：</p><ul><li>数据操作层</li><li>业务逻辑层</li><li>控制器层</li></ul><p><code>Query</code>：用于获取 URL 查询字符串（<code>?key=value</code>）。</p><p><code>Param</code>：用于获取 URL 路径中的动态部分（<code>/path/:param</code>）</p><h2 id="day6、day7"><a href="#day6、day7" class="headerlink" title="day6、day7"></a>day6、day7</h2><ul><li>Swagger：多用几次就会了</li></ul><h3 id="CAPTCHA"><a href="#CAPTCHA" class="headerlink" title="CAPTCHA"></a>CAPTCHA</h3><p> 是 “Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写。它是一种安全机制，用于确定与网站或应用程序交互的是人类还是自动化程序（如机器人）。CAPTCHA 的主要目的是保护在线资源免受滥用，例如防止自动注册、评论垃圾信息、票务抢购等。</p>]]></content>
      
      
      <categories>
          
          <category> 后端项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> gin </tag>
            
            <tag> gorm </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> swagger </tag>
            
            <tag> jwt </tag>
            
            <tag> base64Captcha </tag>
            
            <tag> yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（5）</title>
      <link href="/2024/12/02/mei-ri-xue-xi-5/"/>
      <url>/2024/12/02/mei-ri-xue-xi-5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="21-合并二叉树"><a href="#21-合并二叉树" class="headerlink" title="21. 合并二叉树"></a>21. 合并二叉树</h4><p>两棵树跟着一起遍历，左对左，右对右。依旧是递归遍历为基础，加上变式。</p><h4 id="22-二叉搜索树的搜索"><a href="#22-二叉搜索树的搜索" class="headerlink" title="22. 二叉搜索树的搜索"></a>22. 二叉搜索树的搜索</h4><p>根据值的大小来选择往左还是往右遍历</p><h4 id="23-验证二叉搜索树"><a href="#23-验证二叉搜索树" class="headerlink" title="23. 验证二叉搜索树"></a>23. 验证二叉搜索树</h4><p>先用中序递归遍历收集值，再判断是否为二叉搜索树（单调递增就是）</p><h4 id="24-二叉搜索树的最小绝对差"><a href="#24-二叉搜索树的最小绝对差" class="headerlink" title="24. 二叉搜索树的最小绝对差"></a>24. 二叉搜索树的最小绝对差</h4><p>一样中序递归收集值，再左右相减比较最小的差值就行</p><h4 id="25-二叉搜索树中的众数"><a href="#25-二叉搜索树中的众数" class="headerlink" title="25. 二叉搜索树中的众数"></a>25. 二叉搜索树中的众数</h4><p>中序递归收集值，再用map存，再选出最多的append到res里面 </p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTP-2牛逼在哪"><a href="#HTTP-2牛逼在哪" class="headerlink" title="HTTP&#x2F;2牛逼在哪"></a>HTTP&#x2F;2牛逼在哪</h3><ul><li><p>兼容HTTP&#x2F;1.1</p></li><li><p>头部压缩：使用HPACK算法：（1）静态字典（2）动态字典（3）Huffman编码（压缩算法）</p><ul><li>静态字典：k-v</li></ul></li><li><p>二进制帧：将一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码（head+data）</p></li><li><p>并发传输：stream流（一条TCP连接传输多个stream，一个stream可以包含多个message（里面是请求或响应），message包含一个或多个Frame（存放的是压缩的头和body）</p></li><li><p>服务器主动推送资源：请求一个html，服务器可以主动发送css等。</p></li></ul><p>注：项目有点学不来</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（4）</title>
      <link href="/2024/12/01/mei-ri-xue-xi-4/"/>
      <url>/2024/12/01/mei-ri-xue-xi-4/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="18-从中序和后序遍历序列构造二叉树"><a href="#18-从中序和后序遍历序列构造二叉树" class="headerlink" title="18. 从中序和后序遍历序列构造二叉树"></a>18. 从中序和后序遍历序列构造二叉树</h4><p>主要是用到后序遍历的那个数组，用来找到根节点。然后通过中序遍历的那个数组找到根节点位置与左右子树他们的范围长度。并且用<code>map</code>存中序数组的位置，供每次遍历的时候找到根节点和左右子树。重点其实就是划分子树长度、应该怎么取端点位置。然后就按照基础的遍历顺序来遍历</p><h4 id="19-最大二叉树"><a href="#19-最大二叉树" class="headerlink" title="19. 最大二叉树"></a>19. 最大二叉树</h4><p>18题会了，19题就会。19比18简单，因为更好划分。</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTPS如何优化"><a href="#HTTPS如何优化" class="headerlink" title="HTTPS如何优化"></a>HTTPS如何优化</h3><p>先分析性能损耗，再来看怎么优化：</p><p>耗能阶段：</p><ul><li>TLS握手过程</li><li>握手后的对称加密包文传输</li></ul><p>多角度：</p><ul><li>硬件优化<ul><li>https是计算密集型，搞好一点的cpu，算得快</li></ul></li><li>软件优化<ul><li>软件升级：相对于协议优化，成本开销大</li><li>协议优化</li></ul></li><li>协议优化<ul><li>就是对密钥交换过程优化：<ul><li>算法优化：RSA换成ECDHE（2RTT-&gt;1RTT）时间减少，安全性增加</li><li>TLS升级：TLS1.2变为TLS1.3，TLS握手只要1RTT。因为1.3在客户端第一次握手时就将公钥交换这些发送给客户端了。</li></ul></li></ul></li><li>证书优化<ul><li>证书传输：用ECDHE证书，相同安全度下，密钥比RSA更短</li><li>证书验证：使用OCSP Stapling作为验证（验证证书是否还有效，可能被吊销）</li></ul></li><li>会话复用<ul><li>Session ID：双方都缓存会话密钥，并用Session ID唯一标识，再次连接时客户端hello消息带上这个Session ID，服务器匹配上就可以只需要发送一个消息返回就建立安全连接了。</li><li>Session Ticket：为了减少服务端的缓存，服务端将会话密钥加密放在客户端这里保存。然后再次建立连接时，客户端发送Ticket，服务器解密并验证有效期，就可建立安全通信。</li><li>上述两种都需要1RTT才可以建立， TLS1.3重连只需要0RTT，使用<strong>Pre-shared Key</strong>方法。客户端会把 Ticket 和 HTTP 请求一同发送给服务端。</li><li>注：会话复用不支持前向安全，且用重放攻击危险</li></ul></li></ul><h2 id="课程作业"><a href="#课程作业" class="headerlink" title="课程作业"></a>课程作业</h2><ul><li>项目申请书</li><li>联邦学习介绍需要的PPT</li><li>网课选择题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> 课程作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（3）</title>
      <link href="/2024/11/29/mei-ri-xue-xi-3/"/>
      <url>/2024/11/29/mei-ri-xue-xi-3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="16-找树左下角的值"><a href="#16-找树左下角的值" class="headerlink" title="16. 找树左下角的值"></a>16. 找树左下角的值</h4><p>先找出最大深度，再左边。可以先dfs，再用队列</p><h4 id="17-路径总和"><a href="#17-路径总和" class="headerlink" title="17. 路径总和"></a>17. 路径总和</h4><p>同15一样，遍历基础上加判断条件</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTPS-RSA握手解析"><a href="#HTTPS-RSA握手解析" class="headerlink" title="HTTPS RSA握手解析"></a>HTTPS RSA握手解析</h3><p><strong>RTT</strong>(往返时延)：发送端发送一个数据包到接收端，接收端返回确认包到发送端的整个时间。</p><p>整个TLS握手过程前面已经总结</p><p>补充以下：</p><ul><li><p>四次握手，需要2个RTT时延</p></li><li><p>密码套件基本形式为：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</p></li><li><p>CA进行签名过程为：对持有者的公钥等信息进行打包，然后对这个包进行hash计算，得到hash值，然后用私钥对这个值进行加密。</p></li><li><p>第三次握手，最后客户端发送的摘要信息，使用的是会话密钥加密。目的是验证加密通信是否可用和前面整个握手信息是否有被篡改。</p></li><li><p>RSA不支持前向保密，私钥一旦泄密，以前的所有TLS密文都被破解。</p></li></ul><p>前向保密：即使密钥被泄露，过去的信息也不会被解密。每次通信生成的都是临时密钥。</p><h3 id="HTTPS-ECDHE-握手解析"><a href="#HTTPS-ECDHE-握手解析" class="headerlink" title="HTTPS ECDHE 握手解析"></a>HTTPS ECDHE 握手解析</h3><p>算法核心思想：离散对数</p><p>ECDHE算法具有前向安全，现在被广泛使用。</p><p>DH-&gt;DHE-&gt;ECDHE</p><p>ECDHE算法实在DHE算法基础上使用了ECC椭圆曲线特性，用更少的计算量计算出公钥和最终的会话密钥。</p><p>TLS第一次握手，客户端：（1）TLS版本号（2）支持的密码套件（3）生成的随机数</p><p>TLS第二次握手，服务器:（1）确认TLS版本号（2）随机数（3）选择密码套件（4）数字证书（5）发送Server Key Exchange 消息</p><ul><li>Server Key Exchange 消息包括：<ul><li>选好了椭圆曲线（基点G也确定）</li><li>服务端椭圆曲线公钥</li></ul></li></ul><p>TLS第三次握手，客户端:（1）发送Client Key Exchange消息（2）发送后续改用对称算法加密通信（3）摘要信息使用对称密钥加密发送</p><ul><li>Client Key Exchange消息包括：<ul><li>客户端椭圆曲线公钥</li></ul></li></ul><p>TLS第四次握手，服务端:（1）发送改用对称算法加密通信（2）摘要信息使用对称密钥加密发送</p><p>注：</p><ol><li><p>会话密钥&#x3D;客户端随机数+服务端随机数+椭圆曲线生成的共享密钥</p></li><li><p>RSA在TLS完成四次握手后才能进行应用数据的传输；而ECDHE算法，客户端可以不等服务器最后一次TLS握手就进行加密HTTP数据传送，节省一个RTT时间。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-Vue通用后台管理</title>
      <link href="/2024/11/28/go-vue/"/>
      <url>/2024/11/28/go-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-Vue通用后台管理"><a href="#Go-Vue通用后台管理" class="headerlink" title="Go-Vue通用后台管理"></a>Go-Vue通用后台管理</h1><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><h3 id="1-在db-go中"><a href="#1-在db-go中" class="headerlink" title="1. 在db.go中"></a>1. 在db.go中</h3><h4 id="1-Db-err-gorm-Open-mysql-Open-url-gorm-Config-）"><a href="#1-Db-err-gorm-Open-mysql-Open-url-gorm-Config-）" class="headerlink" title="1.Db, err &#x3D; gorm.Open(mysql.Open(url), &amp;gorm.Config{}）"></a>1.Db, err &#x3D; gorm.Open(mysql.Open(url), &amp;gorm.Config{}）</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">Db<span class="token punctuation">,</span> err <span class="token operator">=</span> gorm<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>mysql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>gorm<span class="token punctuation">.</span>Config<span class="token punctuation">&#123;</span>Logger<span class="token punctuation">:</span> logger<span class="token punctuation">.</span>Default<span class="token punctuation">.</span><span class="token function">LogMode</span><span class="token punctuation">(</span>logger<span class="token punctuation">.</span>Info<span class="token punctuation">)</span><span class="token punctuation">,</span>DisableForeignKeyConstraintWhenMigrating<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-gorm-Open"><a href="#1-gorm-Open" class="headerlink" title="1. gorm.Open"></a>1. <strong><code>gorm.Open</code></strong></h5><ul><li>GORM 是一个流行的 Golang ORM（对象关系映射）框架，用于简化数据库操作。</li><li><code>gorm.Open</code> 用于初始化数据库连接。</li></ul><h5 id="2-mysql-Open-url"><a href="#2-mysql-Open-url" class="headerlink" title="2. mysql.Open(url)"></a>2. <strong><code>mysql.Open(url)</code></strong></h5><ul><li><code>mysql.Open(url)</code> 指定了数据库的驱动和数据源。</li><li><code>url</code> 是之前构造的 MySQL 数据库连接字符串。</li><li><code>mysql</code> 是 <code>gorm.io/driver/mysql</code> 驱动，用于支持 MySQL 数据库。</li></ul><h5 id="3-gorm-Config"><a href="#3-gorm-Config" class="headerlink" title="3. &amp;gorm.Config{}"></a>3. <strong><code>&amp;gorm.Config&#123;&#125;</code></strong></h5><ul><li>传入一个配置结构体，用于定制 GORM 的行为。</li><li>在这里，配置了两个重要选项：</li><li>**<code>Logger: logger.Default.LogMode(logger.Info)</code>**：<ul><li>配置 GORM 的日志级别。</li><li><code>logger.Default</code> 是默认日志记录器。</li><li><code>LogMode(logger.Info)</code>设置日志模式为  <code>Info</code> 级别，这会输出一些基本的 SQL 查询和执行信息。<ul><li>例如：INSERT、UPDATE、DELETE 语句和时间消耗等。</li></ul></li></ul></li><li>**<code>DisableForeignKeyConstraintWhenMigrating: true</code>**：<ul><li>关闭迁移时的外键约束创建。</li><li>默认情况下，GORM 在迁移（比如 <code>db.AutoMigrate</code>）时，会自动为模型中的外键创建数据库级别的外键约束。</li><li>设置为 <code>true</code> 后，会跳过这一步。</li><li>这种配置通常用于提高迁移速度，或因为某些数据库（如 MySQL）对外键约束的支持可能影响性能或灵活性。</li></ul></li></ul><h5 id="4-Db-和-err"><a href="#4-Db-和-err" class="headerlink" title="4. Db 和 err"></a>4. <strong><code>Db</code> 和 <code>err</code></strong></h5><ul><li><code>Db</code> 是全局变量，用于保存数据库连接实例，通常是一个 <code>*gorm.DB</code> 类型。</li><li><code>err</code> 是可能发生的错误，表示连接或配置是否成功。如果连接失败，<code>err</code> 将不为 <code>nil</code>。</li></ul><h3 id="2-cors-go"><a href="#2-cors-go" class="headerlink" title="2. cors.go"></a>2. cors.go</h3><p> chatgpt说：<code>c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)</code>和<code>c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</code>不可同时存在。</p><h3 id="3-authMiddleware-go"><a href="#3-authMiddleware-go" class="headerlink" title="3. authMiddleware.go"></a>3. authMiddleware.go</h3><p><code>c.Abort()</code>：是用来终止当前请求的处理，并且阻止后续的中间件或处理函数继续执行。这个方法通常用于某些特殊场景，例如当请求没有通过鉴权或验证时，终止请求</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="跨域中间件"><a href="#跨域中间件" class="headerlink" title="跨域中间件"></a>跨域中间件</h3><p>跨域就是允许客户端（浏览器）从一个域向另一个域的服务器发起跨域请求并成功接收响应。</p><p>因为前后端分离部署时，请求接口不同。比如：</p><p>前端运行在 <code>http://localhost:3000</code></p><p>后端运行在 <code>http://localhost:8080</code></p><p>跨域中间件相当于允许客户端在3000这个端口请求8000这个端口的响应</p><h4 id="跨域中间件通过HTTP响应头来实现"><a href="#跨域中间件通过HTTP响应头来实现" class="headerlink" title="跨域中间件通过HTTP响应头来实现"></a>跨域中间件通过HTTP响应头来实现</h4><ul><li><p>允许客户端安全地发起跨域请求。</p></li><li><p>响应浏览器的跨域策略检查。</p></li><li><p>提高开发效率，简化跨域相关配置。</p></li></ul><p>是前后端分离项目不可或缺的一部分</p><p>发送<code>OPPTIONS</code>请求，用于询问服务器是否允许跨域请求。</p><h3 id="鉴权中间件"><a href="#鉴权中间件" class="headerlink" title="鉴权中间件"></a>鉴权中间件</h3><ul><li><p><strong>鉴权中间件</strong> 是用来验证请求是否有有效的身份认证信息的中间件，通常用于保护需要身份认证的资源。</p></li><li><p>它在请求进入业务逻辑处理之前执行，确保只有通过认证的用户才能继续访问。</p></li><li><p>通过使用鉴权中间件，可以实现基于 Token（如 JWT）、Session 或 API Key 的认证方法。</p></li><li><p><strong>JWT</strong> 是现代 Web 应用中常用的鉴权机制，它通过在每个请求中携带 token 来进行身份验证。</p></li></ul><h3 id="config-yaml"><a href="#config-yaml" class="headerlink" title="config.yaml"></a>config.yaml</h3><p><code>config.yaml</code> 文件的主要作用是作为应用程序的配置文件，用于存储和管理应用的各种配置信息。它使得开发、运维人员可以灵活地调整应用程序的行为，而不需要修改源代码或重新编译程序。以下是 <code>config.yaml</code> 文件的作用总结：</p><h4 id="1-配置管理："><a href="#1-配置管理：" class="headerlink" title="1. 配置管理："></a>1. <strong>配置管理</strong>：</h4><ul><li><strong>集中管理配置</strong>：通过 <code>config.yaml</code> 文件，可以集中管理应用程序的配置信息，如数据库连接、服务器端口、API 密钥等。</li><li><strong>灵活调整</strong>：配置文件的修改不需要改变应用程序的代码，只需要修改配置文件即可改变应用行为。</li></ul><h4 id="2-人类可读："><a href="#2-人类可读：" class="headerlink" title="2. 人类可读："></a>2. <strong>人类可读</strong>：</h4><ul><li><strong>易于理解和编辑</strong>：YAML 格式比 JSON 更加简洁和易读，适合开发人员和运维人员编辑。配置项可以直观地表示应用程序的行为，如 <code>server.host</code>、<code>database.password</code> 等。</li></ul><h4 id="3-环境适配："><a href="#3-环境适配：" class="headerlink" title="3. 环境适配："></a>3. <strong>环境适配</strong>：</h4><ul><li><strong>支持不同环境的配置</strong>：<code>config.yaml</code> 可以根据不同的部署环境（如开发、测试、生产等）提供不同的配置文件。例如，开发环境和生产环境可能使用不同的数据库配置或服务端口。</li><li><strong>易于切换</strong>：不同环境的配置文件可以在部署时灵活切换，帮助应用程序适应不同的运行环境。</li></ul><h4 id="4-解耦应用程序与配置："><a href="#4-解耦应用程序与配置：" class="headerlink" title="4. 解耦应用程序与配置："></a>4. <strong>解耦应用程序与配置</strong>：</h4><ul><li><strong>与源代码解耦</strong>：将配置从源代码中分离，使得开发人员无需修改代码或重新编译就可以改变程序的行为。例如，更改数据库连接或日志级别。</li></ul><h4 id="5-提高可维护性："><a href="#5-提高可维护性：" class="headerlink" title="5. 提高可维护性："></a>5. <strong>提高可维护性</strong>：</h4><ul><li><strong>简化管理</strong>：在应用程序的生命周期中，配置文件的修改频率通常远高于源代码的修改频率。通过集中管理配置，可以更容易地调整和维护系统。</li><li><strong>版本控制</strong>：<code>config.yaml</code> 可以纳入版本控制系统（如 Git），使得团队能够共享和管理配置变更。</li></ul><h4 id="6-支持动态配置更新："><a href="#6-支持动态配置更新：" class="headerlink" title="6. 支持动态配置更新："></a>6. <strong>支持动态配置更新</strong>：</h4><ul><li>配置文件可以支持动态加载和更新，某些配置管理工具（如 Consul 或 Etcd）可以通过 <code>config.yaml</code> 实现配置的动态更新，不需要停机或重启应用程序。</li></ul><h4 id="7-提高部署和调试效率："><a href="#7-提高部署和调试效率：" class="headerlink" title="7. 提高部署和调试效率："></a>7. <strong>提高部署和调试效率</strong>：</h4><ul><li>通过直接修改配置文件，开发和运维人员能够快速调整应用程序的参数（如服务端口、日志级别等），提高调试和部署的效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>config.yaml</code> 文件的核心作用是提供一个灵活、可管理、易于编辑的方式来配置应用程序的行为。它通过将配置信息与代码解耦，使得开发人员、运维人员能够在不修改源代码的情况下调整和管理应用程序配置，支持不同的环境和需求。</p>]]></content>
      
      
      <categories>
          
          <category> 后端项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> gin </tag>
            
            <tag> gorm </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（2）</title>
      <link href="/2024/11/28/mei-ri-xue-xi-2/"/>
      <url>/2024/11/28/mei-ri-xue-xi-2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="14-二叉树的所有路径"><a href="#14-二叉树的所有路径" class="headerlink" title="14. 二叉树的所有路径"></a>14. 二叉树的所有路径</h3><p>在go语言中，append相当于新开辟地址，如果里面是b &#x3D; append(b,…)这种，在递归中会回溯，只作用在当前函数，不会影响外部函数，外部原切片地址没有增加。使用*b时就会对原切片进行改变。</p><h3 id="15-左子树之和"><a href="#15-左子树之和" class="headerlink" title="15. 左子树之和"></a>15. 左子树之和</h3><p>递归遍历变式，相当于在递归遍历的基础上加上一些判断条件，这道题就是加入判断</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">root<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTP-1-1如何优化"><a href="#HTTP-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h3><p>三方面考虑：</p><ol><li>尽量避免发送HTTP请求</li><li>需要请求时，尽量少发</li><li>减少服务器HTTP响应</li></ol><h4 id="1-避免发送请求"><a href="#1-避免发送请求" class="headerlink" title="1. 避免发送请求"></a>1. 避免发送请求</h4><p>有一些对于请求重复数据的请求就可以存在本地的缓冲中，直接读取本地的数据就行。</p><p>需要<strong>缓存技术</strong>：</p><p>客户端将第一次请求和响应保存在本地磁盘，请求的URL作为key，响应作为value。并且为了防止响应的数据过期，服务器会发送一个估算的过期时间，过期就重新发起请求。</p><p>并且为了提高协议性能，客户端重新发起请求时在<strong>Etag</strong>头部带上第一次响应头部的摘要，让服务器对比本地资源的摘要。如果不同，返回新资源。如果相同，返回不包含体的304响应，让服务器继续使用缓存数据。</p><h4 id="2-减少HTTP请求次数"><a href="#2-减少HTTP请求次数" class="headerlink" title="2. 减少HTTP请求次数"></a>2. 减少HTTP请求次数</h4><ul><li>减少重定向请求次数</li><li>合并请求</li><li>延迟发送请求</li></ul><h5 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h5><p>重定向：当资源迁移时，资源从url1到url2。客户端不知道情况，就需要先发送请求到url1（302响应码），再发送请求到url2。</p><p>服务端一般不只一台，源服务器上一级为代理服务器。</p><p>客户端-&gt;代理服务器-&gt;原服务器</p><p>将重定向的工作交给代理服务器完成，就可以减少HTTP请求次数，并且代理服务器知晓重定向规则后，可以进一步减少消息传递次数。</p><p>注：可以看小林coding上面的图</p><h5 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h5><p>将资源合并，用一个大的资源请求获取多个小资源请求。比如需要请求多个图片，可以用技术把它们合并成一个图片，只需要一个请求就行了。</p><h5 id="延时发送请求"><a href="#延时发送请求" class="headerlink" title="延时发送请求"></a>延时发送请求</h5><p>按需获取方式，当前不需要的资源，就不提前请求。需要的时候再请求。比如网页资源。</p><h4 id="3-减少HTTP响应数据大小"><a href="#3-减少HTTP响应数据大小" class="headerlink" title="3. 减少HTTP响应数据大小"></a>3. 减少HTTP响应数据大小</h4><p>压缩：</p><ul><li>无损压缩：文本文件、程序可执行文件、源代码</li><li>有损压缩：音频、图片、视频等</li></ul><h2 id="Go-Vue通用后台管理"><a href="#Go-Vue通用后台管理" class="headerlink" title="Go-Vue通用后台管理"></a>Go-Vue通用后台管理</h2><h3 id="跨域中间件"><a href="#跨域中间件" class="headerlink" title="跨域中间件"></a>跨域中间件</h3><p>跨域就是允许客户端（浏览器）从一个域向另一个域的服务器发起跨域请求并成功接收响应。</p><p>因为前后端分离部署时，请求接口不同。比如：</p><p>前端运行在 <code>http://localhost:3000</code></p><p>后端运行在 <code>http://localhost:8080</code></p><p>跨域中间件相当于允许客户端在3000这个端口请求8000这个端口的响应</p><h4 id="跨域中间件通过HTTP响应头来实现"><a href="#跨域中间件通过HTTP响应头来实现" class="headerlink" title="跨域中间件通过HTTP响应头来实现"></a>跨域中间件通过HTTP响应头来实现</h4><ul><li><p>允许客户端安全地发起跨域请求。</p></li><li><p>响应浏览器的跨域策略检查。</p></li><li><p>提高开发效率，简化跨域相关配置。</p></li></ul><p>是前后端分离项目不可或缺的一部分</p><p>发送<code>OPPTIONS</code>请求，用于询问服务器是否允许跨域请求。</p><h3 id="鉴权中间件"><a href="#鉴权中间件" class="headerlink" title="鉴权中间件"></a>鉴权中间件</h3><ul><li><p><strong>鉴权中间件</strong> 是用来验证请求是否有有效的身份认证信息的中间件，通常用于保护需要身份认证的资源。</p></li><li><p>它在请求进入业务逻辑处理之前执行，确保只有通过认证的用户才能继续访问。</p></li><li><p>通过使用鉴权中间件，可以实现基于 Token（如 JWT）、Session 或 API Key 的认证方法。</p></li><li><p><strong>JWT</strong> 是现代 Web 应用中常用的鉴权机制，它通过在每个请求中携带 token 来进行身份验证。</p></li></ul><h3 id="config-yaml"><a href="#config-yaml" class="headerlink" title="config.yaml"></a>config.yaml</h3><p><code>config.yaml</code> 文件的主要作用是作为应用程序的配置文件，用于存储和管理应用的各种配置信息。它使得开发、运维人员可以灵活地调整应用程序的行为，而不需要修改源代码或重新编译程序。以下是 <code>config.yaml</code> 文件的作用总结：</p><h4 id="1-配置管理："><a href="#1-配置管理：" class="headerlink" title="1. 配置管理："></a>1. <strong>配置管理</strong>：</h4><ul><li><strong>集中管理配置</strong>：通过 <code>config.yaml</code> 文件，可以集中管理应用程序的配置信息，如数据库连接、服务器端口、API 密钥等。</li><li><strong>灵活调整</strong>：配置文件的修改不需要改变应用程序的代码，只需要修改配置文件即可改变应用行为。</li></ul><h4 id="2-人类可读："><a href="#2-人类可读：" class="headerlink" title="2. 人类可读："></a>2. <strong>人类可读</strong>：</h4><ul><li><strong>易于理解和编辑</strong>：YAML 格式比 JSON 更加简洁和易读，适合开发人员和运维人员编辑。配置项可以直观地表示应用程序的行为，如 <code>server.host</code>、<code>database.password</code> 等。</li></ul><h4 id="3-环境适配："><a href="#3-环境适配：" class="headerlink" title="3. 环境适配："></a>3. <strong>环境适配</strong>：</h4><ul><li><strong>支持不同环境的配置</strong>：<code>config.yaml</code> 可以根据不同的部署环境（如开发、测试、生产等）提供不同的配置文件。例如，开发环境和生产环境可能使用不同的数据库配置或服务端口。</li><li><strong>易于切换</strong>：不同环境的配置文件可以在部署时灵活切换，帮助应用程序适应不同的运行环境。</li></ul><h4 id="4-解耦应用程序与配置："><a href="#4-解耦应用程序与配置：" class="headerlink" title="4. 解耦应用程序与配置："></a>4. <strong>解耦应用程序与配置</strong>：</h4><ul><li><strong>与源代码解耦</strong>：将配置从源代码中分离，使得开发人员无需修改代码或重新编译就可以改变程序的行为。例如，更改数据库连接或日志级别。</li></ul><h4 id="5-提高可维护性："><a href="#5-提高可维护性：" class="headerlink" title="5. 提高可维护性："></a>5. <strong>提高可维护性</strong>：</h4><ul><li><strong>简化管理</strong>：在应用程序的生命周期中，配置文件的修改频率通常远高于源代码的修改频率。通过集中管理配置，可以更容易地调整和维护系统。</li><li><strong>版本控制</strong>：<code>config.yaml</code> 可以纳入版本控制系统（如 Git），使得团队能够共享和管理配置变更。</li></ul><h4 id="6-支持动态配置更新："><a href="#6-支持动态配置更新：" class="headerlink" title="6. 支持动态配置更新："></a>6. <strong>支持动态配置更新</strong>：</h4><ul><li>配置文件可以支持动态加载和更新，某些配置管理工具（如 Consul 或 Etcd）可以通过 <code>config.yaml</code> 实现配置的动态更新，不需要停机或重启应用程序。</li></ul><h4 id="7-提高部署和调试效率："><a href="#7-提高部署和调试效率：" class="headerlink" title="7. 提高部署和调试效率："></a>7. <strong>提高部署和调试效率</strong>：</h4><ul><li>通过直接修改配置文件，开发和运维人员能够快速调整应用程序的参数（如服务端口、日志级别等），提高调试和部署的效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>config.yaml</code> 文件的核心作用是提供一个灵活、可管理、易于编辑的方式来配置应用程序的行为。它通过将配置信息与代码解耦，使得开发人员、运维人员能够在不修改源代码的情况下调整和管理应用程序配置，支持不同的环境和需求。</p><h3 id="cors-go"><a href="#cors-go" class="headerlink" title="cors.go"></a>cors.go</h3><p> chatgpt说：<code>c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)</code>和<code>c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)</code>不可同时存在。</p><h3 id="authMiddleware-go"><a href="#authMiddleware-go" class="headerlink" title="authMiddleware.go"></a>authMiddleware.go</h3><p><code>c.Abort()</code>：是用来终止当前请求的处理，并且阻止后续的中间件或处理函数继续执行。这个方法通常用于某些特殊场景，例如当请求没有通过鉴权或验证时，终止请求</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
            <tag> go-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文方面</title>
      <link href="/2024/11/27/lun-wen-zhi-shi/"/>
      <url>/2024/11/27/lun-wen-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="论文知识"><a href="#论文知识" class="headerlink" title="论文知识"></a>论文知识</h1><h2 id="后门检测与消除"><a href="#后门检测与消除" class="headerlink" title="后门检测与消除"></a>后门检测与消除</h2><p><strong>后门检测</strong>是指在计算机系统、软件或网络中，检测是否存在被恶意植入的后门程序或漏洞的过程。</p><p><strong>后门消除</strong>是指采取措施来移除或修复被检测到的后门程序或漏洞，以确保系统的安全性。</p><h2 id="IID"><a href="#IID" class="headerlink" title="IID"></a><strong>IID</strong></h2><ul><li><strong>独立同分布（IID）</strong>表示数据样本是相互独立的，并且它们来自同一个概率分布。</li><li>在这种情况下，数据集中的每个样本都是随机采样的，且采样过程之间没有相互依赖性。例如，在图像分类任务中，每类图像样本的分布是均匀的，所有参与方的数据都能代表整体数据分布。</li><li>在联邦学习中，如果所有参与方的数据都是IID的，那么每个参与方的数据集都可以被看作是全局数据集的一个小规模但有代表性的样本。</li></ul><h2 id="Non-IID"><a href="#Non-IID" class="headerlink" title="Non-IID"></a><strong>Non-IID</strong></h2><ul><li><strong>非独立同分布（Non-IID）</strong>表示数据样本之间存在某种依赖关系或数据分布不均匀。</li><li>在这种情况下，不同参与方的数据集可能有不同的特征或分布。例如，在手写数字识别任务中，一个参与方的数据可能主要包含“0”和“1”，而另一个参与方的数据可能主要包含“8”和“9”。</li><li>Non-IID情况在联邦学习中非常常见，因为各个参与方的数据通常反映的是特定用户的行为或环境数据，数据分布自然会有所不同。</li></ul><h2 id="IID和Non-IID在联邦学习中的影响"><a href="#IID和Non-IID在联邦学习中的影响" class="headerlink" title="IID和Non-IID在联邦学习中的影响"></a><strong>IID和Non-IID在联邦学习中的影响</strong></h2><ul><li><strong>IID</strong>：有助于全局模型快速收敛，因为每个参与方的数据都能很好地代表整体数据分布。</li><li><strong>Non-IID</strong>：会导致模型训练的挑战，因为不同参与方的数据分布差异较大，模型在聚合时可能会难以找到一个统一的全局最优解。这种情况下，模型的性能可能会下降，并且训练过程可能变得不稳定。</li></ul><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><ul><li><strong>标签翻转（Label-flipping attack）</strong>：攻击者通过修改训练数据标签来误导模型训练。</li><li><strong>高斯攻击（Gaussian attack）</strong>：使用高斯分布扰动模型参数，使得模型表现异常。</li><li><strong>LIE攻击（LIE attack）</strong>：通过精确的扰动策略在不易察觉的范围内对模型施加破坏。</li><li><strong>缩放攻击（Scaling attack）</strong>：恶意调整客户端更新的缩放系数，影响全局模型。</li><li><strong>女巫攻击（Sybil attack）</strong>：通过创建多个虚假客户端来操控联邦学习过程。</li></ul><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降是一种优化算法，用于最小化机器学习模型的损失函数。它通过迭代调整模型参数（如权重），逐步接近损失函数的最小值。算法的核心思想是沿着损失函数的负梯度方向更新参数，使损失值逐渐降低。</p><h2 id="对抗模型（Adversarial-Model）"><a href="#对抗模型（Adversarial-Model）" class="headerlink" title="对抗模型（Adversarial Model）"></a>对抗模型（Adversarial Model）</h2><p>对抗模型（Adversarial Model）通常是指一种用于生成对抗性示例或进行对抗性攻击的机器学习模型。这些模型旨在找到或生成可以欺骗机器学习模型的输入，从而导致模型输出错误的结果。对抗模型在对抗性机器学习和生成对抗网络（GANs）中有重要的应用。</p><h3 id="1-对抗性示例（Adversarial-Examples）"><a href="#1-对抗性示例（Adversarial-Examples）" class="headerlink" title="1. 对抗性示例（Adversarial Examples）"></a>1. 对抗性示例（Adversarial Examples）</h3><p>对抗性示例是通过对输入数据进行细微的、有针对性的修改而生成的，它们可以误导模型做出错误的分类或预测。对抗性攻击利用这种示例来测试模型的鲁棒性和安全性。对抗模型用于生成这些示例，目的是找出使模型误判的输入。</p><h3 id="2-生成对抗网络（GAN）"><a href="#2-生成对抗网络（GAN）" class="headerlink" title="2. 生成对抗网络（GAN）"></a>2. 生成对抗网络（GAN）</h3><p>生成对抗网络是一种由两部分组成的深度学习模型：生成器（Generator）和判别器（Discriminator）。</p><ul><li><strong>生成器</strong>：试图生成逼真的数据，目的是欺骗判别器，使其无法分辨生成的数据和真实数据。</li><li><strong>判别器</strong>：用于区分生成的数据和真实数据。判别器的目标是提高辨别的准确性。</li></ul><p>在训练过程中，生成器和判别器相互对抗，不断改进，使生成器生成的数据越来越真实，而判别器的判断能力也越来越强。这种对抗训练提高了生成数据的质量，是GANs的核心思想。</p><p>对抗模型在提升机器学习模型的鲁棒性、改进数据生成技术和安全性测试等方面有广泛的应用。</p><h2 id="差分隐私（Differential-Privacy-DP）"><a href="#差分隐私（Differential-Privacy-DP）" class="headerlink" title="差分隐私（Differential Privacy, DP）"></a>差分隐私（Differential Privacy, DP）</h2><p>差分隐私是一种数据隐私保护技术，用于在数据分析或机器学习过程中保护个体数据的隐私。其核心思想是在数据分析的结果中引入随机噪声，以防止攻击者通过查询结果推断出单个数据记录的信息。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>差分隐私的基本定义是，如果对两个仅有一个记录不同的相邻数据集进行分析，其输出结果的分布应该非常相似。这意味着，即使数据集中添加或移除某个个体的数据记录，分析的结果仍然保持几乎不变，从而使得攻击者无法确定某个个体是否存在于数据集中。</p><h2 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a><strong>泛化能力</strong></h2><p>指的是机器学习模型在训练数据之外的<strong>新数据</strong>上表现良好的能力。</p><p><strong>Shamir秘密分享（Shamir’s Secret Sharing, SSS）</strong> 是一种加密技术，用于将一个秘密（如加密密钥）分成多个部分（称为“分享”），使得只有达到一定数量的分享（即阈值）时，才能够恢复原始的秘密。Shamir秘密分享方案基于多项式插值理论，广泛用于分布式系统、加密密钥管理和安全多方计算中，以保证数据的安全性和可靠性。</p><h2 id="Shamir秘密分享的基本原理"><a href="#Shamir秘密分享的基本原理" class="headerlink" title="Shamir秘密分享的基本原理"></a>Shamir秘密分享的基本原理</h2><p>Shamir秘密分享的关键在于利用多项式函数来生成和恢复分享。它具有以下特点：</p><ol><li><strong>秘密分割</strong>：将秘密表示为一个多项式函数的常数项，通过多项式的其他点来生成各个分享。</li><li><strong>阈值恢复</strong>：通过设定一个阈值 k，只有收集到至少 k个分享，才能通过多项式插值来重建原始秘密。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>假设要将一个秘密 s 分成 n 份，并设置阈值 k（即至少需要 k 个分享才能恢复秘密）。Shamir秘密分享的步骤如下：</p><ol><li><p><strong>生成多项式</strong>：</p><ul><li>$$<ul><li>随机生成一个最高次项为 k−1的多项式<br>f(x) &#x3D; a_0 + a_1 x + a_2 x^2 + \dots + a_{k-1}其中常数项a_0 &#x3D; s为秘密。</li><li>系数a_1, a_2, \dots, a_{k-1} 随机选取。<br>$$</li></ul></li></ul></li><li><p><strong>生成分享</strong>：</p><ul><li>$$<br>将 x 代入多项式f(x) 中，生成 n 个点 (x_1, f(x_1)), (x_2, f(x_2)), \dots, (x_n, f(x_n))，这些点就是分享。<br>$$</li></ul></li><li><p><strong>秘密恢复</strong>：</p><ul><li>收集至少 k 个分享后，通过<strong>拉格朗日插值</strong>法可以重构出多项式 f(x)f(x)f(x)，进而得到常数项 a_0，即秘密 s。</li><li>拉格朗日插值使用 k 个点即可精确确定一个 k−1 次多项式，因此在不满足阈值 k 的情况下，无法恢复秘密。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个秘密 s&#x3D;1234，希望将其分成 5 份（即 n&#x3D;5），并设定阈值为 3（即 k&#x3D;3）。</p><ol><li><p><strong>生成多项式</strong>：选择一个随机的二次多项式 f(x)&#x3D;1234+5x+3x2。</p></li><li><p><strong>生成分享</strong>：计算<br>$$<br>f(1), f(2), \dots, f(5)<br>$$<br>得到5个分享，如<br>$$<br>(1, 1242), (2, 1254), \dots, (5, 1314)<br>$$</p></li><li><p><strong>恢复秘密</strong>：任意三个分享点通过拉格朗日插值可以还原多项式 f(x)，进而得到常数项 1234，即秘密。</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>安全性</strong>：攻击者无法通过少量分享恢复秘密，保证了数据的安全。</li><li><strong>可靠性</strong>：即使部分分享丢失，只要达到阈值，秘密依然可以恢复。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>密钥管理</strong>：将加密密钥分成多份，由多个参与方持有，防止单点泄露。</li><li><strong>分布式系统</strong>：在分布式环境中保护数据的安全，如区块链中的密钥共享。</li><li><strong>安全多方计算（MPC）</strong>：用于在多方计算中保护隐私，使每方无法单独恢复计算数据。</li></ul><p>Shamir秘密分享是实现分布式数据安全的重要技术，尤其在隐私保护和分布式加密应用中广泛使用。</p><p><strong>加法秘密分享（Additive Secret Sharing）</strong> 是一种简单但有效的秘密共享方案，将一个秘密分成多个部分（称为“分享”），使得只有将所有分享相加才能恢复出原始秘密。加法秘密分享广泛用于多方计算和分布式系统中，以保证参与方在不泄露自己数据的情况下协同计算。</p><h2 id="加法秘密分享的基本原理"><a href="#加法秘密分享的基本原理" class="headerlink" title="加法秘密分享的基本原理"></a>加法秘密分享的基本原理</h2><p>假设有一个秘密 s，我们希望将其分成 n 份，以保证只有所有分享都被收集到时，才能恢复出秘密。加法秘密分享的基本步骤如下：</p><ol><li><p><strong>生成分享</strong>：</p><p>$$<br>随机生成n−1个分享，这些分享可以是任意数值，通常从有限域中随机选取。<br>$$</p><ul><li>第 n 个分享通过计算使得所有分享的和等于秘密 s。</li></ul><p>具体来说，假设要将秘密 s 分成 n 份：<br>$$<br>s_1, s_2, \dots, s_{n-1}<br>$$<br>是前 n−1个随机生成的分享，第 n个分享 s_n计算为：</p><p>$$<br>s_n &#x3D; s - (s_1 + s_2 + \dots + s_{n-1})<br>$$<br>这样，所有分享的和满足：</p><p>$$<br>s_ns&#x3D;s_1+s_2+⋯+s_n<br>$$</p></li><li><p><strong>恢复秘密</strong>：</p><ul><li>收集到所有的 n 个分享后，将其相加即可恢复原始秘密 s：</li></ul><p>$$<br>s_1 + s_2 + \dots + s_ns&#x3D;s1+s2+⋯+sn<br>$$</p><p>在此过程中，单独的分享没有泄露关于秘密 sss 的信息，因为每个分享都是随机的。</p></li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个秘密 s&#x3D;123，并希望将其分成 3 份，即 n&#x3D;3：</p><ol><li>随机生成前两个分享：假设<br>$$<br>s_1 &#x3D; 50，s_2 &#x3D; 30<br>$$<br>。</li><li>计算第三个分享<br>$$<br>s_3 &#x3D; 123 - (50 + 30) &#x3D; 43<br>$$</li></ol><p>  这样，我们得到了三个分享<br>$$<br>s_1 &#x3D; 50、s_2 &#x3D; 30、s_3 &#x3D; 43<br>$$<br>  只有当所有分享相加时才能恢复原始秘密：</p><p>$$<br>s&#x3D;50+30+43&#x3D;123<br>$$</p><h3 id="加法秘密分享的优点"><a href="#加法秘密分享的优点" class="headerlink" title="加法秘密分享的优点"></a>加法秘密分享的优点</h3><ul><li><strong>简单高效</strong>：加法秘密分享的生成和恢复操作非常简单，只涉及加法运算，适合有限计算资源的场景。</li><li><strong>无信息泄露</strong>：单个分享没有任何关于秘密的信息，只有所有分享组合在一起才能恢复秘密。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>安全多方计算（MPC）</strong>：在多方计算中使用加法秘密分享，使各方持有的分享共同计算结果而不泄露原始输入。</li><li><strong>分布式加密和密钥管理</strong>：将密钥分成多份存储在不同地方，保证只有全部分享才能恢复密钥。</li><li><strong>隐私保护机器学习</strong>：在机器学习的联邦学习中使用加法秘密分享分割模型参数或梯度信息，使各客户端保持数据隐私。</li></ol><p>加法秘密分享是一种简单但有效的数据分割技术，尤其适用于需要保护数据隐私的分布式计算和协作环境。</p><p><strong>安全多方计算（Secure Multi-Party Computation, MPC）</strong> 是一种密码学技术，使得多个参与方可以在<strong>不泄露各自私有数据</strong>的情况下，<strong>共同计算</strong>一个函数的结果。MPC确保每个参与方的输入在整个计算过程中都是私密的，其他参与方无法直接访问这些数据。计算完成后，所有参与方仅能得到最终的计算结果，而不会获知其他人的输入内容。</p><h2 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h2><h3 id="安全多方计算的基本原理"><a href="#安全多方计算的基本原理" class="headerlink" title="安全多方计算的基本原理"></a>安全多方计算的基本原理</h3><p>安全多方计算的核心思想是将每个参与方的私有输入<strong>加密或分割成多个部分</strong>（称为“分享”），这些分享在多个参与方之间传递，并用于计算。整个计算过程使用这些分享进行而不直接访问原始数据，从而保证数据隐私。</p><p>例如，假设有两个参与方希望计算彼此输入的总和，但不希望泄露各自的输入。安全多方计算可以让双方安全地计算出总和，而无需彼此交换原始数据。</p><h3 id="常用的MPC协议"><a href="#常用的MPC协议" class="headerlink" title="常用的MPC协议"></a>常用的MPC协议</h3><p>MPC协议有多种实现方式，常见的协议包括：</p><ol><li><strong>加法秘密分享</strong>：将每个参与方的输入分割成若干个随机分享，这些分享在多方之间传递，用于计算各自的子结果，最终合并得到完整结果。</li><li><strong>Shamir秘密共享</strong>：将数据分成多个份数，通过多项式插值的方法实现秘密共享。只需要满足一定的门限数量（如至少 t 份）就可以重构秘密。</li><li><strong>同态加密（Homomorphic Encryption）</strong>：使用同态加密技术，允许在密文状态下直接执行计算，计算完成后才解密，保证计算过程对各方不可见。</li><li><strong>混淆电路（Garbled Circuits）</strong>：将计算过程设计为布尔电路，使用加密方式混淆电路的内部信息，只有输出结果对参与方可见。</li></ol><h3 id="安全多方计算的工作流程"><a href="#安全多方计算的工作流程" class="headerlink" title="安全多方计算的工作流程"></a>安全多方计算的工作流程</h3><p>假设有两方（A和B）希望计算各自的输入数据之和，而不想暴露数据。MPC的流程可能如下：</p><ol><li><strong>数据分享</strong>：A和B将各自的输入分割成若干随机分享，并与对方交换这些分享。</li><li><strong>协同计算</strong>：A和B利用接收到的分享在本地计算各自的子结果。</li><li><strong>结果合并</strong>：将子结果组合后得到最终的结果（即A和B的输入之和），而不需要暴露彼此的原始输入。</li></ol><h3 id="优势与缺点"><a href="#优势与缺点" class="headerlink" title="优势与缺点"></a>优势与缺点</h3><ul><li><strong>优点</strong>：<ul><li><strong>隐私保护</strong>：各方输入数据保持私密，仅计算结果可见。</li><li><strong>去中心化</strong>：不需要信任的第三方，全体参与者共同完成计算。</li><li><strong>数据安全</strong>：即使有参与方恶意行为，也难以获取其他人的数据。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>计算复杂度高</strong>：MPC涉及复杂的加密和解密操作，计算效率较低。</li><li><strong>通信开销大</strong>：多次交换分享和中间结果，带来较高的通信成本。</li></ul></li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>隐私保护机器学习</strong>：在联邦学习和加密模型训练中，MPC可以用于安全地聚合各方的模型参数或梯度。</li><li><strong>金融数据分析</strong>：多方之间联合计算各自的金融数据指标，如信用评分、交易数据分析等，确保数据隐私。</li><li><strong>医疗数据分析</strong>：多家医疗机构可以在不交换患者数据的情况下进行联合分析，如疾病预测、药物试验数据统计等。</li><li><strong>电子投票系统</strong>：利用MPC确保投票的私密性，同时实现投票结果的透明统计。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全多方计算在数据隐私和多方协作场景中起到了关键作用，能够在保障数据安全和隐私的前提下完成联合计算，适用于金融、医疗、人工智能等对数据隐私要求严格的领域。</p><h2 id="对抗性攻击"><a href="#对抗性攻击" class="headerlink" title="对抗性攻击"></a>对抗性攻击</h2><h3 id="搭便车攻击"><a href="#搭便车攻击" class="headerlink" title="搭便车攻击"></a>搭便车攻击</h3><p>在计算环境中只训练少量的数据，以极少的资源消耗从全局模型中获取更大的利益</p><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><p>数据表示（Data Representation），在机器学习和深度学习中，是指将原始数据转换为一种结构化的形式，使其能够更好地被模型理解和利用。在模型训练中，数据表示通常以特征向量、嵌入（embedding）或更高级的特征形式出现，帮助模型从数据中提取出有用的信息，同时降低数据的维度或复杂性。</p><h2 id="向量内积、L2-范数、均值"><a href="#向量内积、L2-范数、均值" class="headerlink" title="向量内积、L2 范数、均值"></a>向量内积、L2 范数、均值</h2><p>在联邦学习（Federated Learning, FL）中，<strong>向量内积（Inner Product）</strong>、<strong>L2 范数（L2 Norm）</strong> 和 <strong>均值（Mean Value）</strong> 是模型聚合、鲁棒性分析和数据分布管理中的重要数学工具。它们通常用于以下场景：</p><hr><h3 id="1-向量内积（Inner-Product）"><a href="#1-向量内积（Inner-Product）" class="headerlink" title="1. 向量内积（Inner Product）"></a>1. <strong>向量内积（Inner Product）</strong></h3><p>向量内积主要用于评估两个向量之间的相似性，并在以下方面具有应用：</p><h4 id="1-1-计算相似性"><a href="#1-1-计算相似性" class="headerlink" title="1.1 计算相似性"></a><strong>1.1 计算相似性</strong></h4><ul><li><p>在鲁棒聚合规则（AGR）中，服务器通过计算客户端上传的模型更新（向量）与基准模型的内积，来评估两者的相似性或偏离程度。</p></li><li><p>相似性计算的指标包括：</p><ul><li><p><strong>余弦相似性（Cosine Similarity）</strong>：<br>$$<br>cos(a,b)&#x3D;⟨a,b⟩∥a∥∥b∥\text{cos}(a, b) &#x3D; \frac{\langle a, b \rangle}{|a| |b|}cos(a,b)&#x3D;∥a∥∥b∥⟨a,b⟩<br>$$</p></li><li><p><strong>欧几里得距离（Euclidean Distance）</strong>：<br>$$<br>∥a−b∥&#x3D;∥a∥2+∥b∥2−2⟨a,b⟩|a - b| &#x3D; \sqrt{|a|^2 + |b|^2 - 2 \langle a, b \rangle}∥a−b∥&#x3D;∥a∥2+∥b∥2−2⟨a,b⟩<br>$$</p></li></ul></li></ul><h4 id="1-2-过滤异常更新"><a href="#1-2-过滤异常更新" class="headerlink" title="1.2 过滤异常更新"></a><strong>1.2 过滤异常更新</strong></h4><ul><li>在防御恶意攻击（如中毒攻击、标注翻转攻击）时，服务器利用内积计算过滤掉偏离全局模型的异常更新，从而保护模型性能和完整性。</li></ul><h4 id="1-3-权重更新与聚合"><a href="#1-3-权重更新与聚合" class="headerlink" title="1.3 权重更新与聚合"></a><strong>1.3 权重更新与聚合</strong></h4><ul><li>内积计算可以用于动态调整客户端权重，将更高相似性的客户端更新赋予更大的权重，增强聚合的鲁棒性。</li></ul><hr><h3 id="2-L2-范数（L2-Norm）"><a href="#2-L2-范数（L2-Norm）" class="headerlink" title="2. L2 范数（L2 Norm）"></a>2. <strong>L2 范数（L2 Norm）</strong></h3><p>L2 范数衡量向量的长度，在以下场景中尤为关键：</p><h4 id="2-1-验证更新规范化"><a href="#2-1-验证更新规范化" class="headerlink" title="2.1 验证更新规范化"></a><strong>2.1 验证更新规范化</strong></h4><ul><li>在许多聚合规则中，要求客户端上传的模型更新具有统一的规范化形式（例如单位长度）。</li><li>通过 L2 范数校验，服务器可以过滤掉未规范化或恶意操纵的模型更新。</li></ul><h4 id="2-2-判定恶意更新"><a href="#2-2-判定恶意更新" class="headerlink" title="2.2 判定恶意更新"></a><strong>2.2 判定恶意更新</strong></h4><ul><li>某些攻击（如缩放攻击）可能通过放大或缩小模型更新的幅度来影响全局模型。服务器通过 L2 范数检测这些异常值，并将其排除在聚合过程中。</li></ul><h4 id="2-3-动态聚合"><a href="#2-3-动态聚合" class="headerlink" title="2.3 动态聚合"></a><strong>2.3 动态聚合</strong></h4><ul><li>服务器可以利用 L2 范数对客户端更新进行动态裁剪（clipping），防止过大的更新对全局模型造成负面影响。</li></ul><hr><h3 id="3-均值（Mean-Value）"><a href="#3-均值（Mean-Value）" class="headerlink" title="3. 均值（Mean Value）"></a>3. <strong>均值（Mean Value）</strong></h3><p>均值在聚合过程和鲁棒性分析中扮演了重要角色：</p><h4 id="3-1-模型更新的简单平均"><a href="#3-1-模型更新的简单平均" class="headerlink" title="3.1 模型更新的简单平均"></a><strong>3.1 模型更新的简单平均</strong></h4><ul><li>最经典的联邦学习算法 FedAvg 中，服务器计算所有客户端模型更新的简单平均：<br>$$<br>w(t+1)&#x3D;1N∑i&#x3D;1Nwi(t)w^{(t+1)} &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N w_i^{(t)}w(t+1)&#x3D;N1i&#x3D;1∑Nwi(t)<br>$$<br> 这种操作本质上是对模型参数的均值计算。</li></ul><h4 id="3-2-过滤异常更新"><a href="#3-2-过滤异常更新" class="headerlink" title="3.2 过滤异常更新"></a><strong>3.2 过滤异常更新</strong></h4><ul><li>在某些鲁棒 AGR（如 Trimmed Mean 和 Median）中，服务器对客户端上传的参数进行裁剪后，计算均值以减少异常值的影响。</li></ul><h4 id="3-3-数据分布估计"><a href="#3-3-数据分布估计" class="headerlink" title="3.3 数据分布估计"></a><strong>3.3 数据分布估计</strong></h4><ul><li>均值也用于分析客户端数据分布，帮助服务器了解数据是否均匀分布以及客户端是否存在非独立同分布（Non-IID）问题，从而调整聚合策略。</li></ul><hr><h3 id="文献中的具体应用"><a href="#文献中的具体应用" class="headerlink" title="文献中的具体应用"></a><strong>文献中的具体应用</strong></h3><p>在文献《AegisFL》中，这三个操作被用作设计和实现灵活聚合规则（AGR）的基础组件：</p><ol><li><strong>灵活性</strong>：通过计算内积、L2 范数和均值，AegisFL 能够支持多种聚合规则，如余弦相似性、欧几里得距离、皮尔逊相关系数等。</li><li><strong>鲁棒性</strong>：这些操作帮助服务器在加密态下评估客户端更新的质量，从而过滤恶意更新。</li><li><strong>高效性</strong>：利用特殊编码技术，这些计算能够在同态加密下以单次多项式运算完成，显著提高效率。</li></ol><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>向量内积</strong>：用于相似性度量和异常检测。</li><li><strong>L2 范数</strong>：用于更新规范化和攻击防御。</li><li><strong>均值</strong>：用于全局模型更新和数据分布分析。</li></ul><p>它们共同构成了联邦学习中鲁棒聚合和隐私保护的数学基础。</p><h1 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h1><h2 id="1-兼顾鲁棒性和隐私性的联邦学习研究"><a href="#1-兼顾鲁棒性和隐私性的联邦学习研究" class="headerlink" title="1.兼顾鲁棒性和隐私性的联邦学习研究"></a>1.兼顾鲁棒性和隐私性的联邦学习研究</h2><p>​鲁棒性与隐私性是联邦学习系统在实际应用中需要考虑的两个维度指标,两者缺一不可。然而鲁棒性提升与隐私性增强之间存在矛盾,例如很多隐私保护手段试图尽量减少不同用户梯度信息的差异,而这常常会阻碍一些鲁棒性提升方法对异常数据的识别。因此,如何处理这个矛盾是联邦学习在大规模应用之前面临的重要问题。</p><h2 id="2-权衡隐私保护的效率和模型的精度"><a href="#2-权衡隐私保护的效率和模型的精度" class="headerlink" title="2.权衡隐私保护的效率和模型的精度"></a>2.权衡隐私保护的效率和模型的精度</h2><h2 id="隐私威胁"><a href="#隐私威胁" class="headerlink" title="隐私威胁"></a>隐私威胁</h2><h3 id="1-恶意参与方获取隐私"><a href="#1-恶意参与方获取隐私" class="headerlink" title="1. 恶意参与方获取隐私"></a>1. 恶意参与方获取隐私</h3><h4 id="1-1-隐私推断攻击"><a href="#1-1-隐私推断攻击" class="headerlink" title="1.1 隐私推断攻击"></a>1.1 隐私推断攻击</h4><h4 id="1-2-提取重构攻击"><a href="#1-2-提取重构攻击" class="headerlink" title="1.2 提取重构攻击"></a>1.2 提取重构攻击</h4><h4 id="1-3-窃取反演攻击"><a href="#1-3-窃取反演攻击" class="headerlink" title="1.3 窃取反演攻击"></a>1.3 窃取反演攻击</h4><h4 id="1-4-参与方GAN攻击"><a href="#1-4-参与方GAN攻击" class="headerlink" title="1.4 参与方GAN攻击"></a>1.4 参与方GAN攻击</h4><h3 id="2-恶意中央服务器泄露"><a href="#2-恶意中央服务器泄露" class="headerlink" title="2. 恶意中央服务器泄露"></a>2. 恶意中央服务器泄露</h3><h4 id="2-1-服务器泄露隐私"><a href="#2-1-服务器泄露隐私" class="headerlink" title="2.1 服务器泄露隐私"></a>2.1 服务器泄露隐私</h4><h4 id="2-2-服务器GAN攻击"><a href="#2-2-服务器GAN攻击" class="headerlink" title="2.2 服务器GAN攻击"></a>2.2 服务器GAN攻击</h4><h3 id="3-恶意多方合谋获取隐私"><a href="#3-恶意多方合谋获取隐私" class="headerlink" title="3. 恶意多方合谋获取隐私"></a>3. 恶意多方合谋获取隐私</h3><h4 id="3-1-多参与方恶意合谋"><a href="#3-1-多参与方恶意合谋" class="headerlink" title="3.1 多参与方恶意合谋"></a>3.1 多参与方恶意合谋</h4><h4 id="3-2-参与方和中央服务器的恶意合谋"><a href="#3-2-参与方和中央服务器的恶意合谋" class="headerlink" title="3.2 参与方和中央服务器的恶意合谋"></a>3.2 参与方和中央服务器的恶意合谋</h4><h2 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h2><h3 id="1-差分隐私"><a href="#1-差分隐私" class="headerlink" title="1. 差分隐私"></a>1. 差分隐私</h3><h3 id="2-同态加密"><a href="#2-同态加密" class="headerlink" title="2. 同态加密"></a>2. 同态加密</h3><h3 id="3-安全多方计算"><a href="#3-安全多方计算" class="headerlink" title="3. 安全多方计算"></a>3. 安全多方计算</h3><h3 id="4-对抗性训练"><a href="#4-对抗性训练" class="headerlink" title="4. 对抗性训练"></a>4. 对抗性训练</h3><h3 id="5-模型压缩"><a href="#5-模型压缩" class="headerlink" title="5. 模型压缩"></a>5. 模型压缩</h3><h1 id="国内外期刊会议"><a href="#国内外期刊会议" class="headerlink" title="国内外期刊会议"></a>国内外期刊会议</h1><h2 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h2><ol><li><p>‌**[IEEE Transactions on Knowledge and Data Engineering (TKDE)](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=IEEE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=IEEE</a> Transactions on Knowledge and Data Engineering (TKDE)&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：该期刊涵盖计算机科学、人工智能、电气工程等领域的知识和数据工程，影响因子为8.9，审稿速度较快，平均4个月，录用难度较大‌1。</p></li><li><p>‌**<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Neurocomputing&rsv_pq=bfc3e01700ddd81f&oq=%E5%9B%BD%E5%86%85%E5%A4%96%E8%AE%A4%E5%8F%AF%E5%BA%A6%E9%AB%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E6%9C%9F%E5%88%8A%E4%BC%9A%E8%AE%AE&rsv_t=3e05TA2Dx/55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&tn=baiduhome_pg&ie=utf-8">Neurocomputing</a>**‌：主要发表神经计算领域的文章，影响因子为5.5，审稿速度较快，接收后5天内即可发表‌1。</p></li><li><p>‌**[Expert Systems with Applications](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Expert">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=Expert</a> Systems with Applications&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：专注于专家系统和智能系统的设计、开发、测试等，影响因子为7.5，审稿速度较快‌1。</p></li><li><p>‌**[IEEE Access](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=IEEE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=IEEE</a> Access&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：涵盖计算机科学与工程等多个学科，影响因子为3.4，审稿周期较短，录用率较高‌2。</p></li><li><p>‌**[Pattern Recognition Letters](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Pattern">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=Pattern</a> Recognition Letters&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：专注于模式识别领域，影响因子为3.9，适合计算机视觉和AI领域的学者‌2。</p></li><li><p>‌**[Journal of Artificial Intelligence Research](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=Journal">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=Journal</a> of Artificial Intelligence Research&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：涵盖AI领域的广泛内容，影响因子为4.5，录用率较高‌2。</p></li><li><p>‌**[International Journal of Computer Vision](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=International">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=International</a> Journal of Computer Vision&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：计算机视觉领域的顶级期刊，影响因子为11.6，录用率较低但影响力高‌2。</p></li><li><p>‌**[ACM Transactions on Graphics](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=ACM">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=ACM</a> Transactions on Graphics&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：图形学和视觉计算领域的顶级期刊，影响因子为7.8，录用率较低但质量高‌2。</p></li><li><p>Data Science and Engineering</p><p>主编：Bin Cui,Timos<br>Sellis主办单位：中国计算机学会(CCF)ISSN：2364-1185创刊时间：2015年05月出版周期：季刊</p></li><li><p>CCF Transactions on Pervasive Computing and Interaction</p><p>主编：Zhiwen Yu,Anind Dey主办单位：中国计算机学会(CCF)ISSN：2524-521X出版周期：季刊</p></li><li><p>CCF Transactions on High Performance Computing</p><p>主编：Depei Qian,Dhabaleswar K. Panda主办单位：中国计算机学会(CCF)ISSN：2524-4930出版周期：季刊</p></li><li><p>Journal of Computer Science and Technology</p><p>主编：Zhi-Wei Xu主办单位：中国科学院计算技术研究所ISSN：1000-9000CN：11-2296&#x2F;TP出版周期：双月刊</p></li><li><p>计算机技术与发展</p><p>主编：陈锐主办单位：中国计算机学会微机专业委员会;陕西省计算机学会</p></li><li><p>数据与计算发展前沿</p><p>主编：钱德沛主管单位：中国科学院主办单位：中国科学院计算机网络信息中心;中国科技出版传媒股份有限公司</p></li><li><p>计算机工程</p><p>主编：江波主管单位：中国电子科技集团公司主办单位：华东计算技术研究所;上海市计算机学会ISSN：1000-33428CN：31-1289&#x2F;TP创刊时间：1975年出版周期：月刊</p></li><li><p>计算机应用研究</p><p>主编：刘营主管单位：四川省科技厅主办单位：四川省计算机研究院ISSN：1001-3695CN：51-1196&#x2F;TP创刊时间：1984年出版周期：月刊</p></li></ol><h2 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h2><ol><li>‌**[第三届IEEE云计算、大数据应用与软件工程国际学术会议 (CBASE 2024)](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E7%AC%AC%E4%B8%89%E5%B1%8AIEEE%E4%BA%91%E8%AE%A1%E7%AE%97%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=第三届IEEE云计算、大数据应用与软件工程国际学术会议</a> (CBASE 2024)&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：会议时间为2024年10月18-20日，地点在中国杭州。征稿主题包括云计算、物联网、AI、大数据的应用、数据分析与挖掘、机器学习等‌3。</li><li>‌**[第五届人工智能与计算工程国际学术会议 (ICAICE 2024)](<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E7%AC%AC%E4%BA%94%E5%B1%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%B7%A5%E7%A8%8B%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE">https://www.baidu.com/s?sa=re_dqa_generate&amp;wd=第五届人工智能与计算工程国际学术会议</a> (ICAICE 2024)&amp;rsv_pq&#x3D;bfc3e01700ddd81f&amp;oq&#x3D;国内外认可度高的计算机类期刊会议&amp;rsv_t&#x3D;3e05TA2Dx&#x2F;55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&amp;tn&#x3D;baiduhome_pg&amp;ie&#x3D;utf-8)**‌：会议时间为2024年11月8-10日，地点在中国芜湖。征稿主题包括人工智能应用与技术、机器学习、计算机视觉等‌3。</li><li>‌**<a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE&rsv_pq=bfc3e01700ddd81f&oq=%E5%9B%BD%E5%86%85%E5%A4%96%E8%AE%A4%E5%8F%AF%E5%BA%A6%E9%AB%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E6%9C%9F%E5%88%8A%E4%BC%9A%E8%AE%AE&rsv_t=3e05TA2Dx/55Do557Diu3DyhSiDoihiR1VJVfwkm08ibhOtGiiyH3z8fT9aAkfns6Ty0&tn=baiduhome_pg&ie=utf-8">第二届数学与机器学习国际学术会议</a>**‌：虽然未提供具体时间信息，但该会议由南京大学主办，征稿主题涉及数学与机器学习领域‌3。</li></ol><p>这些期刊和会议在计算机领域具有较高的认可度和影响力，适合不同研究方向的学者投稿和参加。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 联邦学习 </tag>
            
            <tag> 会议期刊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/11/27/suan-fa/"/>
      <url>/2024/11/27/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>”空间换时间“</p><h4 id="1-穷举法（dfs暴力）"><a href="#1-穷举法（dfs暴力）" class="headerlink" title="1.穷举法（dfs暴力）"></a>1.穷举法（dfs暴力）</h4><p>类似                                                                                                                                    ·· </p><h4 id="2-记忆化搜索（递归）"><a href="#2-记忆化搜索（递归）" class="headerlink" title="2.记忆化搜索（递归）"></a>2.记忆化搜索（递归）</h4><p>记忆化搜索 &#x3D; 暴力dfs+记录答案</p><h4 id="3-迭代形式（递推dp）"><a href="#3-迭代形式（递推dp）" class="headerlink" title="3.迭代形式（递推dp）"></a>3.迭代形式（递推dp）</h4><p>递推 &#x3D; dfs向下递归的公式</p><p>递推数组的初始值 &#x3D; 递归的边界</p><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><h5 id="1-暴力搜索"><a href="#1-暴力搜索" class="headerlink" title="1.暴力搜索"></a>1.暴力搜索</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：暴力搜索 */</span><span class="token keyword">func</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> c <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若超过背包容量，则只能选择不放入背包</span>    <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算不放入和放入物品 i 的最大价值</span>    no <span class="token operator">:=</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    yes <span class="token operator">:=</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment">// 返回两种方案中价值更大的那一个</span>    <span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2.记忆化搜索"></a>2.记忆化搜索</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：记忆化搜索 */</span><span class="token keyword">func</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> mem <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> c <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若已有记录，则直接返回</span>    <span class="token keyword">if</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 若超过背包容量，则只能选择不放入背包</span>    <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算不放入和放入物品 i 的最大价值</span>    no <span class="token operator">:=</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>    yes <span class="token operator">:=</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment">// 返回两种方案中价值更大的那一个</span>    mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：动态规划 */</span><span class="token keyword">func</span> <span class="token function">knapsackDP</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过背包容量，则不选物品 i</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-空间优化-不熟"><a href="#4-空间优化-不熟" class="headerlink" title="4.空间优化(不熟)"></a>4.空间优化(不熟)</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 0-1 背包：空间优化后的动态规划 */</span><span class="token keyword">func</span> <span class="token function">knapsackDPComp</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 倒序遍历</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> c<span class="token operator">--</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h5><h5 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">unboundedKnapsackDP</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过背包容量，则不选物品 i</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">unboundedKnapsackDPComp</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>wgt<span class="token punctuation">)</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token builtin">cap</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> c <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过背包容量，则不选物品 i</span>                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token operator">-</span>wgt<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多重背包</strong></p><h4 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h4><h5 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChangeDP</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>    max <span class="token operator">:=</span> amt <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移：首行首列</span>    <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> max    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移：其余行和列</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过目标金额，则不选硬币 i</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选硬币 i 这两种方案的较小值</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amt<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amt<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="优化空间-1"><a href="#优化空间-1" class="headerlink" title="优化空间"></a>优化空间</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChangeDPComp</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>    max <span class="token operator">:=</span> amt <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 初始化 dp 表</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max    <span class="token punctuation">&#125;</span>    <span class="token comment">// 状态转移</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 正序遍历</span>        <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt<span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a <span class="token punctuation">&#123;</span>                <span class="token comment">// 若超过目标金额，则不选硬币 i</span>                dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不选和选硬币 i 这两种方案的较小值</span>                dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>a<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>amt<span class="token punctuation">]</span> <span class="token operator">!=</span> max <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amt<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="零钱兑换问题-II"><a href="#零钱兑换问题-II" class="headerlink" title="零钱兑换问题 II"></a>零钱兑换问题 II</h4><h5 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChangeIIDP</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> amt <span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> amt <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>amt<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="优化空间-2"><a href="#优化空间-2" class="headerlink" title="优化空间"></a>优化空间</h5><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><strong>leetcode：</strong></p><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><p><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><h2 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>不用哈希表的算法</p><p>用<strong>双指针法</strong>：</p><p>首先对数组进行排序，方便后续指针操作 </p><p>a + b + c &#x3D; 0 （大小顺序从左向右依次增大）</p><p>i指向a，l指向b，r指向c</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">如果一开始 a <span class="token operator">></span> <span class="token number">0</span>，则可以退出了i去重：判断nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">></span> <span class="token number">0</span>，r<span class="token operator">--</span><span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token keyword">else</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">==</span> <span class="token number">0</span> 时，先收集数组<span class="token punctuation">,</span>然后对bc进行去重<span class="token keyword">for</span> r <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> l<span class="token operator">++</span><span class="token keyword">for</span> r <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> r<span class="token operator">--</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>同上</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词"></a>反转字符串里的单词</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">例如：  输入：s <span class="token operator">=</span> <span class="token string">"the sky is blue"</span>输出：<span class="token string">"blue is sky the"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>运用两次反转：第一次整体反转，第二次对每个单词进行反转。</li><li>删除多余空格，每个单词之间只保留一个，用双指针法（快慢指针进行处理 既：覆盖）</li></ol><h4 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h4><h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>前缀：不包含尾字母的字串</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">aabaaf的前缀<span class="token punctuation">:</span>aaaaabaabaaabaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后缀：不包含首字母的字串</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">aabaaf的后缀<span class="token punctuation">:</span>fafaafbaafabaaf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长相等前后缀长度（即模式串的前缀表）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token number">0</span>aa<span class="token number">1</span>aab<span class="token number">0</span>aaba<span class="token number">1</span>aabaa<span class="token number">2</span>aabaaf<span class="token number">0</span>前缀表为：<span class="token number">010120</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般用next数组存前缀表</p><p>注： 代码待定</p><h4 id="重复字串"><a href="#重复字串" class="headerlink" title="重复字串"></a>重复字串</h4><p>注：需要学习KMP算法</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="2-用栈实现队列"><a href="#2-用栈实现队列" class="headerlink" title="2. 用栈实现队列"></a>2. 用栈实现队列</h4><p>两个栈实现正确顺序，注意的是In栈将全部数据传入Out栈后，当Out栈的数据没pop完，就可以直接对O栈进行处理。push正常传入In栈就行了，等Out栈里面没有了再将In栈里面的全部传入Out栈，并且pop完In栈里面的。</p><h4 id="3-用队列实现栈"><a href="#3-用队列实现栈" class="headerlink" title="3. 用队列实现栈"></a>3. 用队列实现栈</h4><p>两个队列，一个来放，另一个复制除了最后一个元素的所有元素，然后再将另一个复制回原来的队列，再将复制队列置空。</p><h4 id="7-滑动最大窗口"><a href="#7-滑动最大窗口" class="headerlink" title="7. 滑动最大窗口"></a>7. 滑动最大窗口</h4><p>双端队列（从左到右依次减小的单调性）</p><p>队列存的是索引，方便判断头队列是否出队。</p><ol><li>入队：保证单调性，只有比最左边小的才入队，比最左边大的要把最左边的剔除出去，直到比最左边小或者队列为空。</li><li>出队：当（头队列的索引-当前的i） &gt;&#x3D; k了，就要出队，因为已经超过窗口了</li><li>收集：只有i &gt;&#x3D; k-1时才收集，此时才满足一个窗口。</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="5-层序遍历"><a href="#5-层序遍历" class="headerlink" title="5. 层序遍历"></a>5. 层序遍历</h4><h5 id="102-层序遍历I"><a href="#102-层序遍历I" class="headerlink" title="102. 层序遍历I"></a>102. 层序遍历I</h5><p>使用队列，循环判断为队列长度是否大于0，使用切片来作为队列。有两种处理方式：</p><ol><li>每一个新创建一个队列，然后将弹出的树的左右子树加入队列</li><li>将弹出树的左右子树加入原来队列，再进行切片操作[len(原长):]</li></ol><p>注意：一开始要判断root是否为nil</p><h5 id="107-层序遍历II"><a href="#107-层序遍历II" class="headerlink" title="107. 层序遍历II"></a>107. 层序遍历II</h5><p>同上，只是最后的数组进行反转。（go二维数组反转和一维一样的操作）</p><h5 id="199-右视图"><a href="#199-右视图" class="headerlink" title="199. 右视图"></a>199. 右视图</h5><p>判断层序遍历是否达到该层最后一个，是就加入res</p><h4 id="8-对称二叉树"><a href="#8-对称二叉树" class="headerlink" title="8. 对称二叉树"></a>8. 对称二叉树</h4><p>左右子树反转完全相等就是对称，左边顺序为中左右，右边顺序为中右左。</p><h4 id="12-平衡二叉树"><a href="#12-平衡二叉树" class="headerlink" title="12. 平衡二叉树"></a>12. 平衡二叉树</h4><p>递归三部曲：</p><ol><li>确定参数和返回值</li><li>确定终止条件</li><li>确定单层递归逻辑</li></ol><p>1.参数为节点，返回值为以该节点为根节点的树的高度（不是平衡二叉树返回-1）</p><p>2.空节点就终止</p><p>3.左子树高度，右子树高度，相差是否&lt;&#x3D;1</p><h4 id="14-二叉树的所有路径"><a href="#14-二叉树的所有路径" class="headerlink" title="14. 二叉树的所有路径"></a>14. 二叉树的所有路径</h4><p>在go语言中，append相当于新开辟地址，如果里面是b &#x3D; append(b,…)这种，在递归中会回溯，只作用在当前函数，不会影响外部函数，外部原切片地址没有增加。使用*b时就会对原切片进行改变。</p><h4 id="15-左子树之和"><a href="#15-左子树之和" class="headerlink" title="15. 左子树之和"></a>15. 左子树之和</h4><p>递归遍历变式，相当于在递归遍历的基础上加上一些判断条件，这道题就是加入判断</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">root<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="16-找树左下角的值"><a href="#16-找树左下角的值" class="headerlink" title="16. 找树左下角的值"></a>16. 找树左下角的值</h4><p>先找出最大深度，再左边。可以先dfs，再用队列</p><h4 id="17-路径总和"><a href="#17-路径总和" class="headerlink" title="17. 路径总和"></a>17. 路径总和</h4><p>同15一样，遍历基础上加判断条件</p><h4 id="18-从中序和后序遍历序列构造二叉树"><a href="#18-从中序和后序遍历序列构造二叉树" class="headerlink" title="18. 从中序和后序遍历序列构造二叉树"></a>18. 从中序和后序遍历序列构造二叉树</h4><p>主要是用到后序遍历的那个数组，用来找到根节点。然后通过中序遍历的那个数组找到根节点位置与左右子树他们的范围长度。并且用<code>map</code>存中序数组的位置，供每次遍历的时候找到根节点和左右子树。重点其实就是划分子树长度、应该怎么取端点位置。然后就按照基础的遍历顺序来遍历</p><h4 id="19-最大二叉树"><a href="#19-最大二叉树" class="headerlink" title="19. 最大二叉树"></a>19. 最大二叉树</h4><p>18题会了，19题就会。19比18简单，因为更好划分。</p><h4 id="21-合并二叉树"><a href="#21-合并二叉树" class="headerlink" title="21. 合并二叉树"></a>21. 合并二叉树</h4><p>两棵树跟着一起遍历，左对左，右对右。依旧是递归遍历为基础，加上变式。</p><h4 id="22-二叉搜索树的搜索"><a href="#22-二叉搜索树的搜索" class="headerlink" title="22. 二叉搜索树的搜索"></a>22. 二叉搜索树的搜索</h4><p>根据值的大小来选择往左还是往右遍历</p><h4 id="23-验证二叉搜索树"><a href="#23-验证二叉搜索树" class="headerlink" title="23. 验证二叉搜索树"></a>23. 验证二叉搜索树</h4><p>先用中序递归遍历收集值，再判断是否为二叉搜索树（单调递增就是）</p><h4 id="24-二叉搜索树的最小绝对差"><a href="#24-二叉搜索树的最小绝对差" class="headerlink" title="24. 二叉搜索树的最小绝对差"></a>24. 二叉搜索树的最小绝对差</h4><p>一样中序递归收集值，再左右相减比较最小的差值就行</p><h4 id="25-二叉搜索树中的众数"><a href="#25-二叉搜索树中的众数" class="headerlink" title="25. 二叉搜索树中的众数"></a>25. 二叉搜索树中的众数</h4><p>中序递归收集值，再用map存，再选出最多的append到res里面 </p><h4 id="26-二叉树就的最近公共祖先"><a href="#26-二叉树就的最近公共祖先" class="headerlink" title="26. 二叉树就的最近公共祖先"></a>26. 二叉树就的最近公共祖先</h4><p>只要找到有p、q就往上返回，相当于回溯（从下往上回），然后判断左右子树是不是不为空，不为空就是最近公共祖先。这个过程包括了p或q本身为公共祖先，因为最终返回的结果只有一个。</p><h4 id="28-二叉搜索树的最近公共祖先"><a href="#28-二叉搜索树的最近公共祖先" class="headerlink" title="28. 二叉搜索树的最近公共祖先"></a>28. 二叉搜索树的最近公共祖先</h4><p>找到第一个在p、q集合里面的就行（包括两端点）</p><h4 id="29-二叉搜索树的插入操作"><a href="#29-二叉搜索树的插入操作" class="headerlink" title="29. 二叉搜索树的插入操作"></a>29. 二叉搜索树的插入操作</h4><p>记住递归三部曲，然后往里面套。一直往下走，直到为空，就可以将节点插入。</p><h4 id="30-删除二叉搜索树中的节点"><a href="#30-删除二叉搜索树中的节点" class="headerlink" title="30. 删除二叉搜索树中的节点"></a>30. 删除二叉搜索树中的节点</h4><p>要用left &#x3D; ….，right&#x3D;….，并且对要删除的节点分情况：</p><ul><li>左右都为空（叶子节点）<ul><li>返回nil</li></ul></li><li>左不为空，右为空<ul><li>返回左子树</li></ul></li><li>左为空，右不为空<ul><li>返回右子树</li></ul></li><li>左右都不为空（最复杂）<ul><li>将左子树移动到右子树最左边，返回右子树</li></ul></li></ul><h4 id="31-修剪二叉搜索树"><a href="#31-修剪二叉搜索树" class="headerlink" title="31. 修剪二叉搜索树"></a>31. 修剪二叉搜索树</h4><ul><li>最搞笑的一题，莫名其妙就做出来了</li></ul><p>就是仿上一题，将所有不满足的节点都删掉。</p><h4 id="32-将有序数组转换为二叉搜索树（平衡二叉树）"><a href="#32-将有序数组转换为二叉搜索树（平衡二叉树）" class="headerlink" title="32. 将有序数组转换为二叉搜索树（平衡二叉树）"></a>32. 将有序数组转换为二叉搜索树（平衡二叉树）</h4><p>要将数组一直划分成两份，就像搜索树左右大小不同一样，也是越往下越是划分左右大小。</p><p>三部曲中：</p><ul><li>判断终止条件为nums为空</li></ul><h4 id="33-把二叉搜索树转换为累加树"><a href="#33-把二叉搜索树转换为累加树" class="headerlink" title="33. 把二叉搜索树转换为累加树"></a>33. 把二叉搜索树转换为累加树</h4><ul><li>使用右中左递归顺序，来依次累加。</li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul><li><p>回溯和递归是相辅相成的</p></li><li><p>纯暴力搜索</p><ul><li>组合问题（组合是无序的）</li><li>切割问题</li><li>子集问题</li><li>排列问题（强调顺序）</li><li>棋盘问题</li></ul></li><li><p>抽象为树形结构（n叉树）   </p></li><li><p>模板</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        存放结果<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        处理节点<span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>        回溯，撤销处理结果    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>剪枝优化：替换for循环里面小于等于的那个数</p></li></ul><h4 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2. 组合问题"></a>2. 组合问题</h4><ul><li>使用模板就可解题，回溯相当于n层for循环，只是在最开始的if判断就是终止条件。</li></ul><h4 id="4-组合总和III"><a href="#4-组合总和III" class="headerlink" title="4. 组合总和III"></a>4. 组合总和III</h4><ul><li>模板解题</li></ul><h4 id="5-电话号码的字母组合"><a href="#5-电话号码的字母组合" class="headerlink" title="5. 电话号码的字母组合"></a>5. 电话号码的字母组合</h4><ul><li>模板解题，注意string-&gt;[]byte</li></ul><h4 id="7-组合总和"><a href="#7-组合总和" class="headerlink" title="7. 组合总和"></a>7. 组合总和</h4><ul><li>保证无重复的数组：需要有<code>start</code>，并且<code>start=i</code></li></ul><h4 id="8-组合总和II"><a href="#8-组合总和II" class="headerlink" title="8. 组合总和II"></a>8. 组合总和II</h4><ul><li>重点是去重（同层的重复去掉）</li></ul><h4 id="9-分割回文串"><a href="#9-分割回文串" class="headerlink" title="9. 分割回文串"></a>9. 分割回文串</h4><p>和组合类似，但是记住是<strong>分割</strong>。重点是</p><ul><li>划分字串判断回文：<code>str = s[start:i+1]</code></li><li>终止条件：<code>start = len(s)</code></li></ul><h4 id="10-复原IP地址"><a href="#10-复原IP地址" class="headerlink" title="10. 复原IP地址"></a>10. 复原IP地址</h4><ul><li>和9很类似，只是注意终止条件多加一个<code>len(path) == 4</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/11/27/ji-suan-ji-wang-luo/"/>
      <url>/2024/11/27/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h2><h3 id="HTTP常见面试题"><a href="#HTTP常见面试题" class="headerlink" title="HTTP常见面试题"></a>HTTP常见面试题</h3><h4 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h4><p>通过SSL&#x2F;TLS协议建立，也就是TLS握手阶段</p><p><strong>TLS四次通信</strong></p><p>第一次：客户端发送:（1）支持的TLS版本（2）生成的随机数（3）支持的加密算法。</p><p>第二次：服务端发送:（1）确认TLS版本（不持支关闭加密通信）（2）生成的随机数（3）确认支持的加密算法（4）数字证书</p><p>第三次：客户端发送:（1）将更改通信加密方式（2）发送一个随机数（3）握手结束通知，发送之前内容总结，供校验</p><p>第四次：服务端发送:（1)确认更改（2）握手结束通知，发送总结，供校验</p><p>在第二次的时候会进行服务器的数字证书验证：</p><p>计算证书内容hash值，使用CA提供的公钥（通常浏览器和操作系统集成了CA公钥）对CA的签名进行解密，对比hash值是否相同，相同即证明可信赖。</p><p>其中通过这三个随机数生成了最终的<strong>会话密钥</strong>（对称加密）</p><p>证书验证过程通常存在<strong>证书信任链问题</strong>：</p><p>如根证书-&gt;中间证书-&gt;百度证书三级</p><p>一般用根证书的公钥去验证中间证书是否可信，再通过中间证书的公钥验证百度证书是否可信。</p><h4 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h4><p>TLS实现包括<strong>握手协议</strong>和<strong>记录协议</strong>两个两层</p><p>握手就是四次通信过程，记录协议就是保护数据并对完整性和来源进行验证（加密就在这里实现）</p><p>记录协议过程：</p><p>（1）消息切片、压缩</p><p>（2）每个片段加上消息认证码（MAC值，hash算法生成）保证完整性和可靠性。</p><p>（3）加密每一个片段</p><p>（4）加密数据加上数据类型、版本号、压缩后的长度作为报头形成报文</p><h4 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h4><h5 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能</h5><p>（1）使用长连接</p><p>（2）支持管道网络传输（请求发出去不必等返回就可再发送请求）</p><h5 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h5><p>HTTP&#x2F;2是基于https</p><p>（1）压缩头部：用索引号代替重复字段</p><p>（2）二进制格式：head和body都变成二进制（帧）</p><p>（3）并发传输：同一个tcp连接传多个stream（多个头＋体），即并行交错进行请求和响应，避免响应的队头阻塞</p><p>（4）服务器推送：服务器主动发送信息给客户端</p><h5 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h5><p>将TCP协议变成UDP协议，并且使用基于UDP的QUIC协议</p><p>QUIC特点</p><ul><li>无队头堵塞（stream丢包，只堵塞这个流，不像HTTP&#x2F;2堵塞TCP整个队头）</li><li>更快的连接方式（HTTP&#x2F;2先TCP握手，再TLS握手；HTTP&#x2F;3，QUIC握手里面包括了TLS内容）</li><li>连接迁移（从数据连接切换到WIFI连接因为IP改变，所以TCP连接重新建立，耗时；HTTP&#x2F;3通过<strong>连接ID</strong>绑定通信端点，只要保留原上下文（连接ID，TLS密钥等），就可以继续原链接。）</li></ul><p>QUIC是UDP上：伪TCP+TLS+HTTP&#x2F;2的多路复用协议</p><p>注：<strong>SSL&#x2F;TLS1.2</strong>需要4次握手，<strong>SSL&#x2F;TLS1.3</strong>只需要3次握手</p><h3 id="HTTP-1-1如何优化"><a href="#HTTP-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h3><p>三方面考虑：</p><ol><li>尽量避免发送HTTP请求</li><li>需要请求时，尽量少发</li><li>减少服务器HTTP响应</li></ol><h4 id="1-避免发送请求"><a href="#1-避免发送请求" class="headerlink" title="1. 避免发送请求"></a>1. 避免发送请求</h4><p>有一些对于请求重复数据的请求就可以存在本地的缓冲中，直接读取本地的数据就行。</p><p>需要<strong>缓存技术</strong>：</p><p>客户端将第一次请求和响应保存在本地磁盘，请求的URL作为key，响应作为value。并且为了防止响应的数据过期，服务器会发送一个估算的过期时间，过期就重新发起请求。</p><p>并且为了提高协议性能，客户端重新发起请求时在<strong>Etag</strong>头部带上第一次响应头部的摘要，让服务器对比本地资源的摘要。如果不同，返回新资源。如果相同，返回不包含体的304响应，让服务器继续使用缓存数据。</p><h4 id="2-减少HTTP请求次数"><a href="#2-减少HTTP请求次数" class="headerlink" title="2. 减少HTTP请求次数"></a>2. 减少HTTP请求次数</h4><ul><li>减少重定向请求次数</li><li>合并请求</li><li>延迟发送请求</li></ul><h5 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h5><p>重定向：当资源迁移时，资源从url1到url2。客户端不知道情况，就需要先发送请求到url1（302响应码），再发送请求到url2。</p><p>服务端一般不只一台，源服务器上一级为代理服务器。</p><p>客户端-&gt;代理服务器-&gt;原服务器</p><p>将重定向的工作交给代理服务器完成，就可以减少HTTP请求次数，并且代理服务器知晓重定向规则后，可以进一步减少消息传递次数。</p><p>注：可以看小林coding上面的图</p><h5 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h5><p>将资源合并，用一个大的资源请求获取多个小资源请求。比如需要请求多个图片，可以用技术把它们合并成一个图片，只需要一个请求就行了。</p><h5 id="延时发送请求"><a href="#延时发送请求" class="headerlink" title="延时发送请求"></a>延时发送请求</h5><p>按需获取方式，当前不需要的资源，就不提前请求。需要的时候再请求。比如网页资源。</p><h4 id="3-减少HTTP响应数据大小"><a href="#3-减少HTTP响应数据大小" class="headerlink" title="3. 减少HTTP响应数据大小"></a>3. 减少HTTP响应数据大小</h4><p>压缩：</p><ul><li>无损压缩：文本文件、程序可执行文件、源代码</li><li>有损压缩：音频、图片、视频等</li></ul><h3 id="HTTPS-RSA握手解析"><a href="#HTTPS-RSA握手解析" class="headerlink" title="HTTPS RSA握手解析"></a>HTTPS RSA握手解析</h3><p><strong>RTT</strong>(往返时延)：发送端发送一个数据包到接收端，接收端返回确认包到发送端的整个时间。</p><p>整个TLS握手过程前面已经总结</p><p>补充以下：</p><ul><li><p>四次握手，需要2个RTT时延</p></li><li><p>密码套件基本形式为：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</p></li><li><p>CA进行签名过程为：对持有者的公钥等信息进行打包，然后对这个包进行hash计算，得到hash值，然后用私钥对这个值进行加密。</p></li><li><p>第三次握手，最后客户端发送的摘要信息，使用的是会话密钥加密。目的是验证加密通信是否可用和前面整个握手信息是否有被篡改。</p></li><li><p>RSA不支持前向保密，私钥一旦泄密，以前的所有TLS密文都被破解。</p></li></ul><p>前向保密：即使密钥被泄露，过去的信息也不会被解密。每次通信生成的都是临时密钥。</p><h3 id="HTTPS-ECDHE-握手解析"><a href="#HTTPS-ECDHE-握手解析" class="headerlink" title="HTTPS ECDHE 握手解析"></a>HTTPS ECDHE 握手解析</h3><p>算法核心思想：离散对数</p><p>ECDHE算法具有前向安全，现在被广泛使用。</p><p>DH-&gt;DHE-&gt;ECDHE</p><p>ECDHE算法实在DHE算法基础上使用了ECC椭圆曲线特性，用更少的计算量计算出公钥和最终的会话密钥。</p><p>TLS第一次握手，客户端：（1）TLS版本号（2）支持的密码套件（3）生成的随机数</p><p>TLS第二次握手，服务器:（1）确认TLS版本号（2）随机数（3）选择密码套件（4）数字证书（5）发送Server Key Exchange 消息</p><ul><li>Server Key Exchange 消息包括：<ul><li>选好了椭圆曲线（基点G也确定）</li><li>服务端椭圆曲线公钥</li></ul></li></ul><p>TLS第三次握手，客户端:（1）发送Client Key Exchange消息（2）发送后续改用对称算法加密通信（3）摘要信息使用对称密钥加密发送</p><ul><li>Client Key Exchange消息包括：<ul><li>客户端椭圆曲线公钥</li></ul></li></ul><p>TLS第四次握手，服务端:（1）发送改用对称算法加密通信（2）摘要信息使用对称密钥加密发送</p><p>注：</p><ol><li><p>会话密钥&#x3D;客户端随机数+服务端随机数+椭圆曲线生成的共享密钥</p></li><li><p>RSA在TLS完成四次握手后才能进行应用数据的传输；而ECDHE算法，客户端可以不等服务器最后一次TLS握手就进行加密HTTP数据传送，节省一个RTT时间。</p></li></ol><h3 id="HTTPS如何优化"><a href="#HTTPS如何优化" class="headerlink" title="HTTPS如何优化"></a>HTTPS如何优化</h3><p>先分析性能损耗，再来看怎么优化：</p><p>耗能阶段：</p><ul><li>TLS握手过程</li><li>握手后的对称加密包文传输</li></ul><p>多角度：</p><ul><li>硬件优化<ul><li>https是计算密集型，搞好一点的cpu，算得快</li></ul></li><li>软件优化<ul><li>软件升级：相对于协议优化，成本开销大</li><li>协议优化</li></ul></li><li>协议优化<ul><li>就是对密钥交换过程优化：<ul><li>算法优化：RSA换成ECDHE（2RTT-&gt;1RTT）时间减少，安全性增加</li><li>TLS升级：TLS1.2变为TLS1.3，TLS握手只要1RTT。因为1.3在客户端第一次握手时就将公钥交换这些发送给客户端了。</li></ul></li></ul></li><li>证书优化<ul><li>证书传输：用ECDHE证书，相同安全度下，密钥比RSA更短</li><li>证书验证：使用OCSP Stapling作为验证（验证证书是否还有效，可能被吊销）</li></ul></li><li>会话复用<ul><li>Session ID：双方都缓存会话密钥，并用Session ID唯一标识，再次连接时客户端hello消息带上这个Session ID，服务器匹配上就可以只需要发送一个消息返回就建立安全连接了。</li><li>Session Ticket：为了减少服务端的缓存，服务端将会话密钥加密放在客户端这里保存。然后再次建立连接时，客户端发送Ticket，服务器解密并验证有效期，就可建立安全通信。</li><li>上述两种都需要1RTT才可以建立， TLS1.3重连只需要0RTT，使用<strong>Pre-shared Key</strong>方法。客户端会把 Ticket 和 HTTP 请求一同发送给服务端。</li><li>注：会话复用不支持前向安全，且用重放攻击危险</li></ul></li></ul><h3 id="HTTP-2牛逼在哪"><a href="#HTTP-2牛逼在哪" class="headerlink" title="HTTP&#x2F;2牛逼在哪"></a>HTTP&#x2F;2牛逼在哪</h3><ul><li><p>兼容HTTP&#x2F;1.1</p></li><li><p>头部压缩：使用HPACK算法：（1）静态字典（2）动态字典（3）Huffman编码（压缩算法）</p><ul><li>静态字典：k-v</li></ul></li><li><p>二进制帧：将一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码（head+data）</p></li><li><p>并发传输：stream流（一条TCP连接传输多个stream，一个stream可以包含多个message（里面是请求或响应），message包含一个或多个Frame（存放的是压缩的头和body）</p></li><li><p>服务器主动推送资源：请求一个html，服务器可以主动发送css等。</p></li></ul><h3 id="3-7-HTTP-3-强势来袭"><a href="#3-7-HTTP-3-强势来袭" class="headerlink" title="3.7 HTTP&#x2F;3 强势来袭"></a>3.7 HTTP&#x2F;3 强势来袭</h3><h3 id="3-8-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#3-8-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="3.8 既然有 HTTP 协议，为什么还要有 RPC？"></a>3.8 既然有 HTTP 协议，为什么还要有 RPC？</h3><h3 id="3-9-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#3-9-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="3.9 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>3.9 既然有 HTTP 协议，为什么还要有 WebSocket？</h3><p>这三个直接看小林coding总结部分</p><ul><li>3.7：<a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%80%BB%E7%BB%93</a></li><li>3.8：<a href="https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_rpc.html#%E6%80%BB%E7%BB%93</a></li><li>3.9：<a href="https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/network/2_http/http_websocket.html#%E6%80%BB%E7%BB%93</a></li></ul><h2 id="TCP篇"><a href="#TCP篇" class="headerlink" title="TCP篇"></a>TCP篇</h2><h3 id="4-1-TCP三次握手与四次挥手面试题"><a href="#4-1-TCP三次握手与四次挥手面试题" class="headerlink" title="4.1 TCP三次握手与四次挥手面试题"></a>4.1 TCP三次握手与四次挥手面试题</h3><h4 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h4><h5 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h5><p><strong>区别：</strong></p><ul><li>连接<ul><li>TCP面向连接、传输前要建立连接</li><li>UDP直接传输</li></ul></li><li>服务对象<ul><li>TCP一对一</li><li>UDP一对一、一对多、多对多</li></ul></li><li>可靠性<ul><li>TCP传输可靠数据</li><li>UDP不保证（但是可通过QUIC等协议实现可靠传输）</li></ul></li><li>拥塞控制、流量控制<ul><li>TCP有，保证数据安全</li><li>UDP无，网络再堵，不影响它发送</li></ul></li><li>首部开销<ul><li>TCP首部可变（开销大）</li><li>UDP固定不变（8个字节，开销小）</li></ul></li><li>传输方式<ul><li>流式传输，无边界，可保证顺序和可靠</li><li>包发送，有边界，可能丢包和乱序</li></ul></li><li>分片不同<ul><li>TCP的数据大于MSS，传输层分片</li><li>UDP的数据大于MTU，IP层分片</li></ul></li></ul><p><strong>应用场景</strong>：</p><ul><li>TCP<ul><li>FTP文件传输</li><li>HTPP&#x2F;HTTPS</li></ul></li><li>UDP<ul><li>DNS，SNMP</li><li>视频、音频等多媒体</li><li>广播通信</li></ul></li></ul><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><ul><li>UDP头部固定、无需额外记录</li><li>TCP头部有个选项，该长度可变，导致TCP头部不固定，需要记录。</li></ul><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><ul><li>TCP数据长度&#x3D;IP总长-IP首部长度-TCP首部长度，这三个长度都是已知的，可以直接算出，不需要额外算出来。</li><li>UDP由于方便处理，需要保证首部长度是4的整数倍，补充了包长度。</li></ul><h5 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h5><p>可以</p><p>TCP 和UDP，在内核中是两个完全独立的软件模块。</p><p>TCP和UDP各自端口号是独立的，他们的80端口是不一样的。</p><p>注：后续还有更详细的内容</p><h4 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h4><h5 id="TCP三次握手过程是怎么样的"><a href="#TCP三次握手过程是怎么样的" class="headerlink" title="TCP三次握手过程是怎么样的"></a>TCP三次握手过程是怎么样的</h5><p>SYN–&gt;ACK、SYN–&gt;ACK</p><ul><li>第一次：客户端发送包文，里面的SYN置1，生成随机序列号（假设为A），不带应用层数据，自己状态变为SYN–SENT</li><li>第二次：服务端发送包文，里面的ACK、SYN置1，生成随机序列号（假设为B），包文的确认应答号设为（A+1），不带应用层数据，自己状态变为SYN–RCVD</li><li>第三次：客户端发送报文，ACK置1，确认应答号设为（B+1），可带应用层数据，状态设为ESTABLISHED</li><li>服务端收到包文，状态也设为ESTABLISHED</li></ul><p>注：在第三次握手的时候就可以携带数据，前两次不行。状态都为ESTABLISHED时，就可互相发送数据了。</p><h5 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h5><p><code>etstat -napt</code>命令查看</p><h5 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h5><ol><li><strong>避免历史连接</strong></li></ol><p>可能由于客户端宕机，第一次发送的请求就失效了，但是第一次发送的请求已经到达服务器，服务器就会返回一个对第一个连接的ACK。同时客户端已经发送了新的请求，接收到服务器对原来请求的ACK，发现不是新连接需要的。就会发送RET，这样服务器就知道原来的没用了，就会接收新的。避免了历史连接。</p><ol start="2"><li><strong>同步双方初始序列号</strong></li></ol><p>序列号是可靠传输的关键，两次握手只能保证一方的初始序列号能被对方接受。                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><p>序列号作用：</p><ul><li>接收方除去重复数据</li><li>接收方根据数据包的序列号按序接收</li><li>可以知道发出去的数据包哪些被正确接收</li></ul><ol start="3"><li><strong>避免资源浪费</strong></li></ol><p>只有两次握手会导致建立多的连接，浪费资源。</p><p>综上，三次握手可以避免历史连接，减少不必要的开销以及同步双方初始序列号。</p><p>两次不能实现避免历<del>、减少</del>、同步~</p><p>而对于四次握手，三次握手就是理论最少握手次数，不需要更多通信次数。</p><h5 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h5><ul><li>防止历史报文被下一个相同四元组的连接接收（主要方面）</li><li>为了安全性，防止黑客伪造相同序列号的TCP被接收</li></ul><h5 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h5><p>基于计时器</p><p>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)</p><p>M是计时器，随着时间要增加</p><h5 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h5><ul><li>IP层进行分片传输，效率很低。因为一个IP分片丢了，整个IP报文分片都需要重传。并且IP层本身没有超时重传机制，只能等传输层TCP来负责。就会重传整个TCP报文，效率太低。</li><li>通过协商MSS值后，只会进行TCP切片，形成的包不会大于MTU，就不会进行IP分片。即便重传也只是以MSS单位，不会重传所有分片。</li><li>MSS最长为1500字节</li></ul><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><ul><li>会进行重传SYN，SYN报文的序列号是一样的。并且重传的SYN的次数限制由内核的<code>tcp_syn_retries</code>参数控制，默认为5。最后一次重传在等待一段时间还是没有收到ACK报文就会断开连接。</li><li>每次重传是在上次的两倍后（1s, 2s, 4s, 8s….）</li></ul><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><ul><li>客户端和服务端都会触发超时重传机制。因为客户端没收到ACK，服务端也没收到ACK。并且同样重传次数由参数控制<code>tcp_syn_retries</code>和<code>tcp_synack_retries</code>，默认值都为5。</li><li>并且某一个超时重传次数过了就直接会断开连接。</li></ul><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><ul><li>服务端触发超时重传机制，重发SYN_ACK报文，知道收到ACK或者断开连接。</li></ul><h5 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h5><ul><li>恶意客户端一直发送SYN报文，占满服务器的半连接队列（内核里），导致后续的SYN报文直接被丢弃。</li><li>避免<ul><li>调大netdev_max_backlog</li><li>增大TCP半连接队列</li><li>开启net.ipv4.tcp_syncookies</li><li>减少 SYN+ACK 重传次数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计网面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习（1）</title>
      <link href="/2024/11/27/mei-ri-xue-xi-1/"/>
      <url>/2024/11/27/mei-ri-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="8-对称二叉树"><a href="#8-对称二叉树" class="headerlink" title="8. 对称二叉树"></a>8. 对称二叉树</h3><p>左右子树反转完全相等就是对称，左边顺序为中左右，右边顺序为中右左。</p><h3 id="12-平衡二叉树"><a href="#12-平衡二叉树" class="headerlink" title="12. 平衡二叉树"></a>12. 平衡二叉树</h3><p>递归三部曲：</p><ol><li>确定参数和返回值</li><li>确定终止条件</li><li>确定单层递归逻辑</li></ol><p>1.参数为节点，返回值为以该节点为根节点的树的高度（不是平衡二叉树返回-1）</p><p>2.空节点就终止</p><p>3.左子树高度，右子树高度，相差是否&lt;&#x3D;1</p><h2 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h2><h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p>将TCP协议变成UDP协议，并且使用基于UDP的QUIC协议</p><p>QUIC特点</p><ul><li>无队头堵塞（stream丢包，只堵塞这个流，不像HTTP&#x2F;2堵塞TCP整个队头）</li><li>更快的连接方式（HTTP&#x2F;2先TCP握手，再TLS握手；HTTP&#x2F;3，QUIC握手里面包括了TLS内容）</li><li>连接迁移（从数据连接切换到WIFI连接因为IP改变，所以TCP连接重新建立，耗时；HTTP&#x2F;3通过<strong>连接ID</strong>绑定通信端点，只要保留原上下文（连接ID，TLS密钥等），就可以继续原链接。）</li></ul><p>QUIC是UDP上：伪TCP+TLS+HTTP&#x2F;2的多路复用协议</p><p>注：<strong>SSL&#x2F;TLS1.2</strong>需要4次握手，<strong>SSL&#x2F;TLS1.3</strong>只需要3次握手</p>]]></content>
      
      
      <categories>
          
          <category> 每日学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode（二叉树） </tag>
            
            <tag> 小林coding（计算机网络） </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
